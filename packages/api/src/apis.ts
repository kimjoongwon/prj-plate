/**
 * Generated by orval v7.17.2 ğŸº
 * Do not edit manually.
 * Plate
 * API ë¬¸ì„œì…ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ ì—”ë“œí¬ì¸íŠ¸ëŠ” ì¿ í‚¤ ê¸°ë°˜ JWT ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. (@Public ë°ì½”ë ˆì´í„°ê°€ ìˆëŠ” ì—”ë“œí¬ì¸íŠ¸ëŠ” ì˜ˆì™¸)
 * OpenAPI spec version: 1.0.0
 */
import {
	useMutation,
	useQuery,
	useSuspenseInfiniteQuery,
	useSuspenseQuery,
} from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	InfiniteData,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseInfiniteQueryOptions,
	UseSuspenseInfiniteQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";

import type {
	GetAll200AllOf,
	GetNewToken200AllOf,
	Login200AllOf,
	LoginPayloadDto,
	RefreshToken200AllOf,
	SignUpPayloadDto,
	SignUpUser201AllOf,
	VerifyToken200AllOf,
} from "./model";

import { customInstance } from "./libs/customAxios";
import type { ErrorType, BodyType } from "./libs/customAxios";
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¡œ ë¡œê·¸ì¸í•˜ì—¬ JWT í† í°ì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
 * @summary ì‚¬ìš©ì ë¡œê·¸ì¸
 */
export const login = (
	loginPayloadDto: BodyType<LoginPayloadDto>,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<Login200AllOf>(
		{
			url: `/api/v1/auth/login`,
			method: "POST",
			headers: { "Content-Type": "application/json" },
			data: loginPayloadDto,
			signal,
		},
		options,
	);
};

export const getLoginMutationOptions = <
	TError = ErrorType<void>,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof login>>,
		TError,
		{ data: BodyType<LoginPayloadDto> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginPayloadDto> },
	TContext
> => {
	const mutationKey = ["login"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof login>>,
		{ data: BodyType<LoginPayloadDto> }
	> = (props) => {
		const { data } = props ?? {};

		return login(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
	Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = BodyType<LoginPayloadDto>;
export type LoginMutationError = ErrorType<void>;

/**
 * @summary ì‚¬ìš©ì ë¡œê·¸ì¸
 */
export const useLogin = <TError = ErrorType<void>, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof login>>,
			TError,
			{ data: BodyType<LoginPayloadDto> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof login>>,
	TError,
	{ data: BodyType<LoginPayloadDto> },
	TContext
> => {
	const mutationOptions = getLoginMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * ë¦¬í”„ë ˆì‹œ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ì•¡ì„¸ìŠ¤ í† í°ê³¼ ë¦¬í”„ë ˆì‹œ í† í°ì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
 * @summary í† í° ì¬ë°œê¸‰
 */
export const refreshToken = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<RefreshToken200AllOf>(
		{ url: `/api/v1/auth/token/refresh`, method: "POST", signal },
		options,
	);
};

export const getRefreshTokenMutationOptions = <
	TError = ErrorType<void>,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof refreshToken>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof refreshToken>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ["refreshToken"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof refreshToken>>,
		void
	> = () => {
		return refreshToken(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type RefreshTokenMutationResult = NonNullable<
	Awaited<ReturnType<typeof refreshToken>>
>;

export type RefreshTokenMutationError = ErrorType<void>;

/**
 * @summary í† í° ì¬ë°œê¸‰
 */
export const useRefreshToken = <TError = ErrorType<void>, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof refreshToken>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof refreshToken>>,
	TError,
	void,
	TContext
> => {
	const mutationOptions = getRefreshTokenMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * ì¸ì¦ëœ ì‚¬ìš©ìì˜ ë¦¬í”„ë ˆì‹œ í† í°ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ì•¡ì„¸ìŠ¤ í† í°ì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
 * @summary ì¸ì¦ëœ ì‚¬ìš©ì í† í° ê°±ì‹ 
 */
export const getNewToken = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<GetNewToken200AllOf>(
		{ url: `/api/v1/auth/new-token`, method: "GET", signal },
		options,
	);
};

export const getGetNewTokenQueryKey = () => {
	return [`/api/v1/auth/new-token`] as const;
};

export const getGetNewTokenInfiniteQueryKey = () => {
	return ["infinite", `/api/v1/auth/new-token`] as const;
};

export const getGetNewTokenQueryOptions = <
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetNewTokenQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({
		signal,
	}) => getNewToken(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getNewToken>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNewTokenQueryResult = NonNullable<
	Awaited<ReturnType<typeof getNewToken>>
>;
export type GetNewTokenQueryError = ErrorType<void>;

export function useGetNewToken<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getNewToken>>,
					TError,
					Awaited<ReturnType<typeof getNewToken>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewToken<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getNewToken>>,
					TError,
					Awaited<ReturnType<typeof getNewToken>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewToken<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ì¸ì¦ëœ ì‚¬ìš©ì í† í° ê°±ì‹ 
 */

export function useGetNewToken<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetNewTokenQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getGetNewTokenSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof getNewToken>>,
			TError,
			TData
		>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetNewTokenQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({
		signal,
	}) => getNewToken(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getNewToken>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNewTokenSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getNewToken>>
>;
export type GetNewTokenSuspenseQueryError = ErrorType<void>;

export function useGetNewTokenSuspense<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspense<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspense<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ì¸ì¦ëœ ì‚¬ìš©ì í† í° ê°±ì‹ 
 */

export function useGetNewTokenSuspense<
	TData = Awaited<ReturnType<typeof getNewToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetNewTokenSuspenseQueryOptions(options);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getGetNewTokenSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseSuspenseInfiniteQueryOptions<
			Awaited<ReturnType<typeof getNewToken>>,
			TError,
			TData
		>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetNewTokenInfiniteQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({
		signal,
	}) => getNewToken(requestOptions, signal);

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getNewToken>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNewTokenSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getNewToken>>
>;
export type GetNewTokenSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetNewTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary ì¸ì¦ëœ ì‚¬ìš©ì í† í° ê°±ì‹ 
 */

export function useGetNewTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getNewToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetNewTokenSuspenseInfiniteQueryOptions(options);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * ìƒˆë¡œìš´ ì‚¬ìš©ì ê³„ì •ì„ ìƒì„±í•˜ê³  JWT í† í°ì„ ë°œê¸‰ë°›ìŠµë‹ˆë‹¤.
 * @summary íšŒì›ê°€ì…
 */
export const signUpUser = (
	signUpPayloadDto: BodyType<SignUpPayloadDto>,
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<SignUpUser201AllOf>(
		{
			url: `/api/v1/auth/sign-up`,
			method: "POST",
			headers: { "Content-Type": "application/json" },
			data: signUpPayloadDto,
			signal,
		},
		options,
	);
};

export const getSignUpUserMutationOptions = <
	TError = ErrorType<void>,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof signUpUser>>,
		TError,
		{ data: BodyType<SignUpPayloadDto> },
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof signUpUser>>,
	TError,
	{ data: BodyType<SignUpPayloadDto> },
	TContext
> => {
	const mutationKey = ["signUpUser"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof signUpUser>>,
		{ data: BodyType<SignUpPayloadDto> }
	> = (props) => {
		const { data } = props ?? {};

		return signUpUser(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SignUpUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof signUpUser>>
>;
export type SignUpUserMutationBody = BodyType<SignUpPayloadDto>;
export type SignUpUserMutationError = ErrorType<void>;

/**
 * @summary íšŒì›ê°€ì…
 */
export const useSignUpUser = <TError = ErrorType<void>, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof signUpUser>>,
			TError,
			{ data: BodyType<SignUpPayloadDto> },
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof signUpUser>>,
	TError,
	{ data: BodyType<SignUpPayloadDto> },
	TContext
> => {
	const mutationOptions = getSignUpUserMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * í˜„ì¬ ìš”ì²­ì˜ ì•¡ì„¸ìŠ¤ í† í°ì´ ìœ íš¨í•œì§€ ê²€ì¦í•©ë‹ˆë‹¤.
 * @summary í† í° ìœ íš¨ì„± ê²€ì¦
 */
export const verifyToken = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<VerifyToken200AllOf>(
		{ url: `/api/v1/auth/verify-token`, method: "GET", signal },
		options,
	);
};

export const getVerifyTokenQueryKey = () => {
	return [`/api/v1/auth/verify-token`] as const;
};

export const getVerifyTokenInfiniteQueryKey = () => {
	return ["infinite", `/api/v1/auth/verify-token`] as const;
};

export const getVerifyTokenQueryOptions = <
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getVerifyTokenQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({
		signal,
	}) => verifyToken(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof verifyToken>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VerifyTokenQueryResult = NonNullable<
	Awaited<ReturnType<typeof verifyToken>>
>;
export type VerifyTokenQueryError = ErrorType<void>;

export function useVerifyToken<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof verifyToken>>,
					TError,
					Awaited<ReturnType<typeof verifyToken>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyToken<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof verifyToken>>,
					TError,
					Awaited<ReturnType<typeof verifyToken>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyToken<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary í† í° ìœ íš¨ì„± ê²€ì¦
 */

export function useVerifyToken<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getVerifyTokenQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getVerifyTokenSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof verifyToken>>,
			TError,
			TData
		>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getVerifyTokenQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({
		signal,
	}) => verifyToken(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof verifyToken>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VerifyTokenSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof verifyToken>>
>;
export type VerifyTokenSuspenseQueryError = ErrorType<void>;

export function useVerifyTokenSuspense<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspense<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspense<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary í† í° ìœ íš¨ì„± ê²€ì¦
 */

export function useVerifyTokenSuspense<
	TData = Awaited<ReturnType<typeof verifyToken>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getVerifyTokenSuspenseQueryOptions(options);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getVerifyTokenSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseSuspenseInfiniteQueryOptions<
			Awaited<ReturnType<typeof verifyToken>>,
			TError,
			TData
		>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getVerifyTokenInfiniteQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({
		signal,
	}) => verifyToken(requestOptions, signal);

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof verifyToken>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VerifyTokenSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof verifyToken>>
>;
export type VerifyTokenSuspenseInfiniteQueryError = ErrorType<void>;

export function useVerifyTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary í† í° ìœ íš¨ì„± ê²€ì¦
 */

export function useVerifyTokenSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof verifyToken>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getVerifyTokenSuspenseInfiniteQueryOptions(options);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * í˜„ì¬ ì‚¬ìš©ìë¥¼ ë¡œê·¸ì•„ì›ƒí•˜ê³  ëª¨ë“  ì¸ì¦ ì¿ í‚¤ë¥¼ ì‚­ì œí•˜ê³  í† í°ì„ ë¬´íš¨í™”í•©ë‹ˆë‹¤.
 * @summary ë¡œê·¸ì•„ì›ƒ
 */
export const logout = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<void>(
		{ url: `/api/v1/auth/logout`, method: "POST", signal },
		options,
	);
};

export const getLogoutMutationOptions = <
	TError = ErrorType<unknown>,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof logout>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof logout>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ["logout"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof logout>>,
		void
	> = () => {
		return logout(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LogoutMutationResult = NonNullable<
	Awaited<ReturnType<typeof logout>>
>;

export type LogoutMutationError = ErrorType<unknown>;

/**
 * @summary ë¡œê·¸ì•„ì›ƒ
 */
export const useLogout = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof logout>>,
			TError,
			void,
			TContext
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof logout>>,
	TError,
	void,
	TContext
> => {
	const mutationOptions = getLogoutMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * ëª¨ë“  Ground ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
 * @summary Ground ëª©ë¡ ì¡°íšŒ
 */
export const getAll = (
	options?: SecondParameter<typeof customInstance>,
	signal?: AbortSignal,
) => {
	return customInstance<GetAll200AllOf>(
		{ url: `/api/v1/grounds/grounds`, method: "GET", signal },
		options,
	);
};

export const getGetAllQueryKey = () => {
	return [`/api/v1/grounds/grounds`] as const;
};

export const getGetAllInfiniteQueryKey = () => {
	return ["infinite", `/api/v1/grounds/grounds`] as const;
};

export const getGetAllQueryOptions = <
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAllQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({
		signal,
	}) => getAll(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllQueryResult = NonNullable<Awaited<ReturnType<typeof getAll>>>;
export type GetAllQueryError = ErrorType<void>;

export function useGetAll<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAll>>,
					TError,
					Awaited<ReturnType<typeof getAll>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAll<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof getAll>>,
					TError,
					Awaited<ReturnType<typeof getAll>>
				>,
				"initialData"
			>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAll<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ground ëª©ë¡ ì¡°íšŒ
 */

export function useGetAll<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetAllQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getGetAllSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAllQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({
		signal,
	}) => getAll(requestOptions, signal);

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof getAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAll>>
>;
export type GetAllSuspenseQueryError = ErrorType<void>;

export function useGetAllSuspense<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllSuspense<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllSuspense<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ground ëª©ë¡ ì¡°íšŒ
 */

export function useGetAllSuspense<
	TData = Awaited<ReturnType<typeof getAll>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAll>>, TError, TData>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetAllSuspenseQueryOptions(options);

	const query = useSuspenseQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getGetAllSuspenseInfiniteQueryOptions = <
	TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
	TError = ErrorType<void>,
>(options?: {
	query?: Partial<
		UseSuspenseInfiniteQueryOptions<
			Awaited<ReturnType<typeof getAll>>,
			TError,
			TData
		>
	>;
	request?: SecondParameter<typeof customInstance>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetAllInfiniteQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll>>> = ({
		signal,
	}) => getAll(requestOptions, signal);

	return {
		queryKey,
		queryFn,
		...queryOptions,
	} as UseSuspenseInfiniteQueryOptions<
		Awaited<ReturnType<typeof getAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllSuspenseInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof getAll>>
>;
export type GetAllSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetAllSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
	TError = ErrorType<void>,
>(
	options: {
		query: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAll>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAll>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAllSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAll>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ground ëª©ë¡ ì¡°íšŒ
 */

export function useGetAllSuspenseInfinite<
	TData = InfiniteData<Awaited<ReturnType<typeof getAll>>>,
	TError = ErrorType<void>,
>(
	options?: {
		query?: Partial<
			UseSuspenseInfiniteQueryOptions<
				Awaited<ReturnType<typeof getAll>>,
				TError,
				TData
			>
		>;
		request?: SecondParameter<typeof customInstance>;
	},
	queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGetAllSuspenseInfiniteQueryOptions(options);

	const query = useSuspenseInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseSuspenseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}
