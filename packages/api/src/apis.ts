/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Plate
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query';

import type {
  CreateCategory200AllOf,
  CreateCategoryDto,
  CreateExercise200AllOf,
  CreateExerciseDto,
  CreateFile201AllOf,
  CreateFileClassification200AllOf,
  CreateFileClassificationDto,
  CreateFileDto,
  CreateGroundDto,
  CreateProgram200AllOf,
  CreateRole200AllOf,
  CreateRoleDto,
  CreateRoutine200AllOf,
  CreateSession200AllOf,
  CreateSpace200AllOf,
  CreateSpaceClassification200AllOf,
  CreateSpaceClassificationDto,
  CreateSpaceDto,
  CreateSubject200AllOf,
  CreateTenant200AllOf,
  CreateTenantDto,
  CreateTimeline200AllOf,
  CreateUser200AllOf,
  CreateUserDto,
  DeleteCategoryById200AllOf,
  DeleteExercise200AllOf,
  DeleteFileClassification200AllOf,
  DeleteGroup200AllOf,
  DeleteProgramById200AllOf,
  DeleteRole200AllOf,
  DeleteRoutine200AllOf,
  DeleteSession200AllOf,
  DeleteSpace200AllOf,
  DeleteSpaceClassification200AllOf,
  DeleteSubject200AllOf,
  DeleteTenant200AllOf,
  DeleteTimeline200AllOf,
  DeleteUser200AllOf,
  GetCategoriesByQuery200AllOf,
  GetCategoriesByQueryParams,
  GetCategoryById200AllOf,
  GetCurrentSpace200AllOf,
  GetExercise200AllOf,
  GetExercisesByQuery200AllOf,
  GetExercisesByQueryParams,
  GetFileById200AllOf,
  GetFileClassification200AllOf,
  GetFileClassificationsByQuery200AllOf,
  GetFileClassificationsByQueryParams,
  GetGroundsByQuery200AllOf,
  GetGroundsByQueryParams,
  GetGroupById200AllOf,
  GetGroupsByQuery200AllOf,
  GetMyTenants200AllOf,
  GetNewToken200AllOf,
  GetProgramById200AllOf,
  GetProgramsByQuery200AllOf,
  GetRole200AllOf,
  GetRoleClassificationsByQueryParams,
  GetRolesByQuery200AllOf,
  GetRolesByQueryParams,
  GetRoutine200AllOf,
  GetRoutinesByQuery200AllOf,
  GetSession200AllOf,
  GetSessionsByQuery200AllOf,
  GetSpace200AllOf,
  GetSpaceClassification200AllOf,
  GetSpaceClassificationsByQuery200AllOf,
  GetSpaceClassificationsByQueryParams,
  GetSpacesByQuery200AllOf,
  GetSpacesByQueryParams,
  GetSubject200AllOf,
  GetSubjectsByQuery200AllOf,
  GetTenantById200AllOf,
  GetTenantsByQuery200AllOf,
  GetTenantsByQueryParams,
  GetTimeline200AllOf,
  GetTimelinesByQuery200AllOf,
  GetUser200AllOf,
  GetUsersByQuery200AllOf,
  GetUsersByQueryParams,
  GroupDto,
  Login200AllOf,
  LoginPayloadDto,
  Logout200AllOf,
  RefreshToken200AllOf,
  RemoveExercise200AllOf,
  RemoveFileById200AllOf,
  RemoveFileClassification200AllOf,
  RemoveGroups200AllOf,
  RemoveProgramById200AllOf,
  RemoveRole200AllOf,
  RemoveRoutine200AllOf,
  RemoveSession200AllOf,
  RemoveSessions200AllOf,
  RemoveSpace200AllOf,
  RemoveSpaceClassification200AllOf,
  RemoveSubject200AllOf,
  RemoveSubjects200AllOf,
  RemoveTenantById200AllOf,
  RemoveTimeline200AllOf,
  RemoveTimelines200AllOf,
  RemoveUser200AllOf,
  RemoveUsers200AllOf,
  SignUpPayloadDto,
  SignUpUser201AllOf,
  UpdateCategoryById200AllOf,
  UpdateCategoryDto,
  UpdateExercise200AllOf,
  UpdateExerciseDto,
  UpdateFileById200AllOf,
  UpdateFileByIdBody,
  UpdateFileClassification200AllOf,
  UpdateFileClassificationDto,
  UpdateGroundDto,
  UpdateGroupById200AllOf,
  UpdateProgramById200AllOf,
  UpdateRole200AllOf,
  UpdateRoleDto,
  UpdateRoutine200AllOf,
  UpdateSession200AllOf,
  UpdateSpace200AllOf,
  UpdateSpaceClassification200AllOf,
  UpdateSpaceClassificationDto,
  UpdateSpaceDto,
  UpdateSubject200AllOf,
  UpdateTenantById200AllOf,
  UpdateTenantDto,
  UpdateTimeline200AllOf,
  UpdateUser200AllOf,
  UpdateUserDto,
  VerifyToken200AllOf
} from './model';

import { customInstance } from './libs/customAxios';
import type { ErrorType , BodyType } from './libs/customAxios';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary ÏÉàÎ°úÏö¥ Ground ÏÉùÏÑ±
 */
export const createGround = (
    createGroundDto: BodyType<CreateGroundDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/grounds`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createGroundDto, signal
    },
      options);
    }
  


export const getCreateGroundMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGround>>, TError,{data: BodyType<CreateGroundDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createGround>>, TError,{data: BodyType<CreateGroundDto>}, TContext> => {

const mutationKey = ['createGround'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGround>>, {data: BodyType<CreateGroundDto>}> = (props) => {
          const {data} = props ?? {};

          return  createGround(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGroundMutationResult = NonNullable<Awaited<ReturnType<typeof createGround>>>
    export type CreateGroundMutationBody = BodyType<CreateGroundDto>
    export type CreateGroundMutationError = ErrorType<unknown>

    /**
 * @summary ÏÉàÎ°úÏö¥ Ground ÏÉùÏÑ±
 */
export const useCreateGround = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGround>>, TError,{data: BodyType<CreateGroundDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createGround>>,
        TError,
        {data: BodyType<CreateGroundDto>},
        TContext
      > => {

      const mutationOptions = getCreateGroundMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ground Î™©Î°ù Ï°∞Ìöå
 */
export const getGroundsByQuery = (
    params?: GetGroundsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroundsByQuery200AllOf>(
      {url: `/api/v1/grounds`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGroundsByQueryQueryKey = (params?: GetGroundsByQueryParams,) => {
    return [`/api/v1/grounds`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGroundsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroundsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroundsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroundsByQuery>>> = ({ signal }) => getGroundsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroundsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getGroundsByQuery>>>
export type GetGroundsByQueryQueryError = ErrorType<unknown>


export function useGetGroundsByQuery<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroundsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroundsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundsByQuery<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroundsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundsByQuery<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ground Î™©Î°ù Ï°∞Ìöå
 */

export function useGetGroundsByQuery<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroundsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroundsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroundsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroundsByQuery>>> = ({ signal }) => getGroundsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroundsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroundsByQuery>>>
export type GetGroundsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetGroundsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroundsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ground Î™©Î°ù Ï°∞Ìöå
 */

export function useGetGroundsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroundsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroundsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroundsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>, TError = ErrorType<unknown>>(params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroundsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroundsByQuery>>> = ({ signal }) => getGroundsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroundsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroundsByQuery>>>
export type GetGroundsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroundsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroundsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Ground Î™©Î°ù Ï°∞Ìöå
 */

export function useGetGroundsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroundsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroundsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary IDÎ°ú Ground Ï°∞Ìöå
 */
export const getGroundById = (
    groundId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/grounds/${groundId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetGroundByIdQueryKey = (groundId?: string,) => {
    return [`/api/v1/grounds/${groundId}`] as const;
    }

    
export const getGetGroundByIdQueryOptions = <TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(groundId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroundByIdQueryKey(groundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroundById>>> = ({ signal }) => getGroundById(groundId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groundId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroundByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGroundById>>>
export type GetGroundByIdQueryError = ErrorType<unknown>


export function useGetGroundById<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundById>>,
          TError,
          Awaited<ReturnType<typeof getGroundById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundById<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundById>>,
          TError,
          Awaited<ReturnType<typeof getGroundById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundById<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary IDÎ°ú Ground Ï°∞Ìöå
 */

export function useGetGroundById<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroundByIdQueryOptions(groundId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroundByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(groundId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroundByIdQueryKey(groundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroundById>>> = ({ signal }) => getGroundById(groundId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroundByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroundById>>>
export type GetGroundByIdSuspenseQueryError = ErrorType<unknown>


export function useGetGroundByIdSuspense<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundByIdSuspense<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundByIdSuspense<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary IDÎ°ú Ground Ï°∞Ìöå
 */

export function useGetGroundByIdSuspense<TData = Awaited<ReturnType<typeof getGroundById>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroundByIdSuspenseQueryOptions(groundId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroundByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroundById>>>, TError = ErrorType<unknown>>(groundId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroundByIdQueryKey(groundId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroundById>>> = ({ signal }) => getGroundById(groundId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroundByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroundById>>>
export type GetGroundByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroundByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundById>>>, TError = ErrorType<unknown>>(
 groundId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundById>>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroundByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundById>>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary IDÎ°ú Ground Ï°∞Ìöå
 */

export function useGetGroundByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroundById>>>, TError = ErrorType<unknown>>(
 groundId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroundById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroundByIdSuspenseInfiniteQueryOptions(groundId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary IDÎ°ú Ground ÏàòÏ†ï
 */
export const updateGroundById = (
    groundId: string,
    updateGroundDto: BodyType<UpdateGroundDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/grounds/${groundId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateGroundDto
    },
      options);
    }
  


export const getUpdateGroundByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroundById>>, TError,{groundId: string;data: BodyType<UpdateGroundDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateGroundById>>, TError,{groundId: string;data: BodyType<UpdateGroundDto>}, TContext> => {

const mutationKey = ['updateGroundById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGroundById>>, {groundId: string;data: BodyType<UpdateGroundDto>}> = (props) => {
          const {groundId,data} = props ?? {};

          return  updateGroundById(groundId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGroundByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateGroundById>>>
    export type UpdateGroundByIdMutationBody = BodyType<UpdateGroundDto>
    export type UpdateGroundByIdMutationError = ErrorType<unknown>

    /**
 * @summary IDÎ°ú Ground ÏàòÏ†ï
 */
export const useUpdateGroundById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroundById>>, TError,{groundId: string;data: BodyType<UpdateGroundDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateGroundById>>,
        TError,
        {groundId: string;data: BodyType<UpdateGroundDto>},
        TContext
      > => {

      const mutationOptions = getUpdateGroundByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary IDÎ°ú Ground ÏôÑÏ†Ñ ÏÇ≠Ï†ú (hard delete)
 */
export const deleteGroundById = (
    groundId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/grounds/${groundId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteGroundByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroundById>>, TError,{groundId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroundById>>, TError,{groundId: string}, TContext> => {

const mutationKey = ['deleteGroundById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroundById>>, {groundId: string}> = (props) => {
          const {groundId} = props ?? {};

          return  deleteGroundById(groundId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroundByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroundById>>>
    
    export type DeleteGroundByIdMutationError = ErrorType<unknown>

    /**
 * @summary IDÎ°ú Ground ÏôÑÏ†Ñ ÏÇ≠Ï†ú (hard delete)
 */
export const useDeleteGroundById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroundById>>, TError,{groundId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroundById>>,
        TError,
        {groundId: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroundByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary IDÎ°ú Ground ÏÇ≠Ï†ú (soft delete)
 */
export const removeGroundById = (
    groundId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/grounds/${groundId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveGroundByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroundById>>, TError,{groundId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeGroundById>>, TError,{groundId: string}, TContext> => {

const mutationKey = ['removeGroundById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeGroundById>>, {groundId: string}> = (props) => {
          const {groundId} = props ?? {};

          return  removeGroundById(groundId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveGroundByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeGroundById>>>
    
    export type RemoveGroundByIdMutationError = ErrorType<unknown>

    /**
 * @summary IDÎ°ú Ground ÏÇ≠Ï†ú (soft delete)
 */
export const useRemoveGroundById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroundById>>, TError,{groundId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeGroundById>>,
        TError,
        {groundId: string},
        TContext
      > => {

      const mutationOptions = getRemoveGroundByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Ïó≠Ìï† Î∂ÑÎ•ò ÏÉùÏÑ±
 */
export const createRoleClassification = (
    createRoleClassificationBody: BodyType<string>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/roles/classifications`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createRoleClassificationBody, signal
    },
      options);
    }
  


export const getCreateRoleClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoleClassification>>, TError,{data: BodyType<string>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createRoleClassification>>, TError,{data: BodyType<string>}, TContext> => {

const mutationKey = ['createRoleClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoleClassification>>, {data: BodyType<string>}> = (props) => {
          const {data} = props ?? {};

          return  createRoleClassification(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoleClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createRoleClassification>>>
    export type CreateRoleClassificationMutationBody = BodyType<string>
    export type CreateRoleClassificationMutationError = ErrorType<unknown>

    /**
 * @summary Ïó≠Ìï† Î∂ÑÎ•ò ÏÉùÏÑ±
 */
export const useCreateRoleClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoleClassification>>, TError,{data: BodyType<string>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoleClassification>>,
        TError,
        {data: BodyType<string>},
        TContext
      > => {

      const mutationOptions = getCreateRoleClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary ÏøºÎ¶¨ Ï°∞Í±¥ÏúºÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Î™©Î°ù Ï°∞Ìöå
 */
export const getRoleClassificationsByQuery = (
    params?: GetRoleClassificationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/roles/classifications`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRoleClassificationsByQueryQueryKey = (params?: GetRoleClassificationsByQueryParams,) => {
    return [`/api/v1/roles/classifications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRoleClassificationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>> = ({ signal }) => getRoleClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleClassificationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>
export type GetRoleClassificationsByQueryQueryError = ErrorType<unknown>


export function useGetRoleClassificationsByQuery<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetRoleClassificationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoleClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRoleClassificationsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationsByQuery<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoleClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRoleClassificationsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationsByQuery<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏøºÎ¶¨ Ï°∞Í±¥ÏúºÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Î™©Î°ù Ï°∞Ìöå
 */

export function useGetRoleClassificationsByQuery<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleClassificationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleClassificationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>> = ({ signal }) => getRoleClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleClassificationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>
export type GetRoleClassificationsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetRoleClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetRoleClassificationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏøºÎ¶¨ Ï°∞Í±¥ÏúºÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Î™©Î°ù Ï°∞Ìöå
 */

export function useGetRoleClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleClassificationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleClassificationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>, TError = ErrorType<unknown>>(params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>> = ({ signal }) => getRoleClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleClassificationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>
export type GetRoleClassificationsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetRoleClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetRoleClassificationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary ÏøºÎ¶¨ Ï°∞Í±¥ÏúºÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Î™©Î°ù Ï°∞Ìöå
 */

export function useGetRoleClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetRoleClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleClassificationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Ï°∞Ìöå
 */
export const getRoleClassificationById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/roles/classifications/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoleClassificationByIdQueryKey = (id?: string,) => {
    return [`/api/v1/roles/classifications/${id}`] as const;
    }

    
export const getGetRoleClassificationByIdQueryOptions = <TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleClassificationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleClassificationById>>> = ({ signal }) => getRoleClassificationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleClassificationByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleClassificationById>>>
export type GetRoleClassificationByIdQueryError = ErrorType<unknown>


export function useGetRoleClassificationById<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoleClassificationById>>,
          TError,
          Awaited<ReturnType<typeof getRoleClassificationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationById<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoleClassificationById>>,
          TError,
          Awaited<ReturnType<typeof getRoleClassificationById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationById<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Ï°∞Ìöå
 */

export function useGetRoleClassificationById<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleClassificationByIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleClassificationByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleClassificationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleClassificationById>>> = ({ signal }) => getRoleClassificationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleClassificationByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleClassificationById>>>
export type GetRoleClassificationByIdSuspenseQueryError = ErrorType<unknown>


export function useGetRoleClassificationByIdSuspense<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationByIdSuspense<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationByIdSuspense<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Ï°∞Ìöå
 */

export function useGetRoleClassificationByIdSuspense<TData = Awaited<ReturnType<typeof getRoleClassificationById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleClassificationByIdSuspenseQueryOptions(id,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleClassificationByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationById>>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleClassificationByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleClassificationById>>> = ({ signal }) => getRoleClassificationById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleClassificationByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRoleClassificationById>>>
export type GetRoleClassificationByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetRoleClassificationByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationById>>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationById>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleClassificationByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationById>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò Ï°∞Ìöå
 */

export function useGetRoleClassificationByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoleClassificationById>>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoleClassificationById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleClassificationByIdSuspenseInfiniteQueryOptions(id,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò ÏàòÏ†ï
 */
export const updateRoleClassificationById = (
    id: BodyType<string>,
    updateRoleClassificationByIdBody: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/roles/classifications/${id}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateRoleClassificationByIdBody
    },
      options);
    }
  


export const getUpdateRoleClassificationByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoleClassificationById>>, TError,{id: string;data: BodyType<string>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRoleClassificationById>>, TError,{id: string;data: BodyType<string>}, TContext> => {

const mutationKey = ['updateRoleClassificationById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoleClassificationById>>, {id: string;data: BodyType<string>}> = (props) => {
          const {id,data} = props ?? {};

          return  updateRoleClassificationById(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoleClassificationByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoleClassificationById>>>
    export type UpdateRoleClassificationByIdMutationBody = BodyType<string>
    export type UpdateRoleClassificationByIdMutationError = ErrorType<unknown>

    /**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò ÏàòÏ†ï
 */
export const useUpdateRoleClassificationById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoleClassificationById>>, TError,{id: string;data: BodyType<string>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoleClassificationById>>,
        TError,
        {id: string;data: BodyType<string>},
        TContext
      > => {

      const mutationOptions = getUpdateRoleClassificationByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò ÏôÑÏ†Ñ ÏÇ≠Ï†ú
 */
export const deleteRoleClassificationById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/roles/classifications/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoleClassificationByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleClassificationById>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoleClassificationById>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteRoleClassificationById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoleClassificationById>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteRoleClassificationById(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleClassificationByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoleClassificationById>>>
    
    export type DeleteRoleClassificationByIdMutationError = ErrorType<unknown>

    /**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò ÏôÑÏ†Ñ ÏÇ≠Ï†ú
 */
export const useDeleteRoleClassificationById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoleClassificationById>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoleClassificationById>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoleClassificationByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò ÏÇ≠Ï†ú (ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú)
 */
export const removeRoleClassificationById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<null>(
      {url: `/api/v1/roles/classifications/${id}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveRoleClassificationByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRoleClassificationById>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeRoleClassificationById>>, TError,{id: string}, TContext> => {

const mutationKey = ['removeRoleClassificationById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRoleClassificationById>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  removeRoleClassificationById(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveRoleClassificationByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeRoleClassificationById>>>
    
    export type RemoveRoleClassificationByIdMutationError = ErrorType<unknown>

    /**
 * @summary IDÎ°ú Ïó≠Ìï† Î∂ÑÎ•ò ÏÇ≠Ï†ú (ÏÜåÌîÑÌä∏ ÏÇ≠Ï†ú)
 */
export const useRemoveRoleClassificationById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRoleClassificationById>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeRoleClassificationById>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getRemoveRoleClassificationByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createFileClassification = (
    createFileClassificationDto: BodyType<CreateFileClassificationDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateFileClassification200AllOf>(
      {url: `/api/v1/files/classifications`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createFileClassificationDto, signal
    },
      options);
    }
  


export const getCreateFileClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFileClassification>>, TError,{data: BodyType<CreateFileClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createFileClassification>>, TError,{data: BodyType<CreateFileClassificationDto>}, TContext> => {

const mutationKey = ['createFileClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFileClassification>>, {data: BodyType<CreateFileClassificationDto>}> = (props) => {
          const {data} = props ?? {};

          return  createFileClassification(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFileClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createFileClassification>>>
    export type CreateFileClassificationMutationBody = BodyType<CreateFileClassificationDto>
    export type CreateFileClassificationMutationError = ErrorType<unknown>

    export const useCreateFileClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFileClassification>>, TError,{data: BodyType<CreateFileClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createFileClassification>>,
        TError,
        {data: BodyType<CreateFileClassificationDto>},
        TContext
      > => {

      const mutationOptions = getCreateFileClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getFileClassificationsByQuery = (
    params?: GetFileClassificationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetFileClassificationsByQuery200AllOf>(
      {url: `/api/v1/files/classifications`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetFileClassificationsByQueryQueryKey = (params?: GetFileClassificationsByQueryParams,) => {
    return [`/api/v1/files/classifications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetFileClassificationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileClassificationsByQuery>>> = ({ signal }) => getFileClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileClassificationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>
export type GetFileClassificationsByQueryQueryError = ErrorType<unknown>


export function useGetFileClassificationsByQuery<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetFileClassificationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationsByQuery<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationsByQuery<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileClassificationsByQuery<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileClassificationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileClassificationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileClassificationsByQuery>>> = ({ signal }) => getFileClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileClassificationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>
export type GetFileClassificationsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetFileClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetFileClassificationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileClassificationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileClassificationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>, TError = ErrorType<unknown>>(params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileClassificationsByQuery>>> = ({ signal }) => getFileClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileClassificationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>
export type GetFileClassificationsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetFileClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetFileClassificationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetFileClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileClassificationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getFileClassification = (
    fileClassificationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetFileClassification200AllOf>(
      {url: `/api/v1/files/classifications/${fileClassificationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFileClassificationQueryKey = (fileClassificationId?: string,) => {
    return [`/api/v1/files/classifications/${fileClassificationId}`] as const;
    }

    
export const getGetFileClassificationQueryOptions = <TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(fileClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileClassificationQueryKey(fileClassificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileClassification>>> = ({ signal }) => getFileClassification(fileClassificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileClassificationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileClassificationQueryResult = NonNullable<Awaited<ReturnType<typeof getFileClassification>>>
export type GetFileClassificationQueryError = ErrorType<unknown>


export function useGetFileClassification<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassification>>,
          TError,
          Awaited<ReturnType<typeof getFileClassification>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassification<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassification>>,
          TError,
          Awaited<ReturnType<typeof getFileClassification>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassification<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileClassification<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileClassificationQueryOptions(fileClassificationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileClassificationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(fileClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileClassificationQueryKey(fileClassificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileClassification>>> = ({ signal }) => getFileClassification(fileClassificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileClassificationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFileClassification>>>
export type GetFileClassificationSuspenseQueryError = ErrorType<unknown>


export function useGetFileClassificationSuspense<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationSuspense<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationSuspense<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileClassificationSuspense<TData = Awaited<ReturnType<typeof getFileClassification>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileClassificationSuspenseQueryOptions(fileClassificationId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileClassificationSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>, TError = ErrorType<unknown>>(fileClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileClassificationQueryKey(fileClassificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileClassification>>> = ({ signal }) => getFileClassification(fileClassificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileClassificationSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFileClassification>>>
export type GetFileClassificationSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetFileClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>, TError = ErrorType<unknown>>(
 fileClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileClassificationSuspenseInfiniteQueryOptions(fileClassificationId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateFileClassification = (
    fileClassificationId: string,
    updateFileClassificationDto: BodyType<UpdateFileClassificationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateFileClassification200AllOf>(
      {url: `/api/v1/files/classifications/${fileClassificationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateFileClassificationDto
    },
      options);
    }
  


export const getUpdateFileClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFileClassification>>, TError,{fileClassificationId: string;data: BodyType<UpdateFileClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateFileClassification>>, TError,{fileClassificationId: string;data: BodyType<UpdateFileClassificationDto>}, TContext> => {

const mutationKey = ['updateFileClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFileClassification>>, {fileClassificationId: string;data: BodyType<UpdateFileClassificationDto>}> = (props) => {
          const {fileClassificationId,data} = props ?? {};

          return  updateFileClassification(fileClassificationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFileClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateFileClassification>>>
    export type UpdateFileClassificationMutationBody = BodyType<UpdateFileClassificationDto>
    export type UpdateFileClassificationMutationError = ErrorType<unknown>

    export const useUpdateFileClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFileClassification>>, TError,{fileClassificationId: string;data: BodyType<UpdateFileClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateFileClassification>>,
        TError,
        {fileClassificationId: string;data: BodyType<UpdateFileClassificationDto>},
        TContext
      > => {

      const mutationOptions = getUpdateFileClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteFileClassification = (
    fileClassificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteFileClassification200AllOf>(
      {url: `/api/v1/files/classifications/${fileClassificationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteFileClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFileClassification>>, TError,{fileClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteFileClassification>>, TError,{fileClassificationId: string}, TContext> => {

const mutationKey = ['deleteFileClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteFileClassification>>, {fileClassificationId: string}> = (props) => {
          const {fileClassificationId} = props ?? {};

          return  deleteFileClassification(fileClassificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteFileClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFileClassification>>>
    
    export type DeleteFileClassificationMutationError = ErrorType<unknown>

    export const useDeleteFileClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteFileClassification>>, TError,{fileClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteFileClassification>>,
        TError,
        {fileClassificationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteFileClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeFileClassification = (
    fileClassificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveFileClassification200AllOf>(
      {url: `/api/v1/files/classifications/${fileClassificationId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveFileClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFileClassification>>, TError,{fileClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFileClassification>>, TError,{fileClassificationId: string}, TContext> => {

const mutationKey = ['removeFileClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFileClassification>>, {fileClassificationId: string}> = (props) => {
          const {fileClassificationId} = props ?? {};

          return  removeFileClassification(fileClassificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFileClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof removeFileClassification>>>
    
    export type RemoveFileClassificationMutationError = ErrorType<unknown>

    export const useRemoveFileClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFileClassification>>, TError,{fileClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFileClassification>>,
        TError,
        {fileClassificationId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFileClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createSpaceClassification = (
    createSpaceClassificationDto: BodyType<CreateSpaceClassificationDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSpaceClassification200AllOf>(
      {url: `/api/v1/spaces/classifications`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSpaceClassificationDto, signal
    },
      options);
    }
  


export const getCreateSpaceClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpaceClassification>>, TError,{data: BodyType<CreateSpaceClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSpaceClassification>>, TError,{data: BodyType<CreateSpaceClassificationDto>}, TContext> => {

const mutationKey = ['createSpaceClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSpaceClassification>>, {data: BodyType<CreateSpaceClassificationDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSpaceClassification(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSpaceClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createSpaceClassification>>>
    export type CreateSpaceClassificationMutationBody = BodyType<CreateSpaceClassificationDto>
    export type CreateSpaceClassificationMutationError = ErrorType<unknown>

    export const useCreateSpaceClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpaceClassification>>, TError,{data: BodyType<CreateSpaceClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSpaceClassification>>,
        TError,
        {data: BodyType<CreateSpaceClassificationDto>},
        TContext
      > => {

      const mutationOptions = getCreateSpaceClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getSpaceClassificationsByQuery = (
    params?: GetSpaceClassificationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpaceClassificationsByQuery200AllOf>(
      {url: `/api/v1/spaces/classifications`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSpaceClassificationsByQueryQueryKey = (params?: GetSpaceClassificationsByQueryParams,) => {
    return [`/api/v1/spaces/classifications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSpaceClassificationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>> = ({ signal }) => getSpaceClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceClassificationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>
export type GetSpaceClassificationsByQueryQueryError = ErrorType<unknown>


export function useGetSpaceClassificationsByQuery<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetSpaceClassificationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationsByQuery<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationsByQuery<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceClassificationsByQuery<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceClassificationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceClassificationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>> = ({ signal }) => getSpaceClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceClassificationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>
export type GetSpaceClassificationsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetSpaceClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetSpaceClassificationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceClassificationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceClassificationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>, TError = ErrorType<unknown>>(params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>> = ({ signal }) => getSpaceClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceClassificationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>
export type GetSpaceClassificationsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSpaceClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetSpaceClassificationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetSpaceClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceClassificationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSpaceClassification = (
    spaceClassificationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpaceClassification200AllOf>(
      {url: `/api/v1/spaces/classifications/${spaceClassificationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSpaceClassificationQueryKey = (spaceClassificationId?: string,) => {
    return [`/api/v1/spaces/classifications/${spaceClassificationId}`] as const;
    }

    
export const getGetSpaceClassificationQueryOptions = <TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(spaceClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceClassificationQueryKey(spaceClassificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaceClassification>>> = ({ signal }) => getSpaceClassification(spaceClassificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceClassificationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceClassificationQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaceClassification>>>
export type GetSpaceClassificationQueryError = ErrorType<unknown>


export function useGetSpaceClassification<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassification>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassification>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassification<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassification>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassification>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassification<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceClassification<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceClassificationQueryOptions(spaceClassificationId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceClassificationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(spaceClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceClassificationQueryKey(spaceClassificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaceClassification>>> = ({ signal }) => getSpaceClassification(spaceClassificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceClassificationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaceClassification>>>
export type GetSpaceClassificationSuspenseQueryError = ErrorType<unknown>


export function useGetSpaceClassificationSuspense<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationSuspense<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationSuspense<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceClassificationSuspense<TData = Awaited<ReturnType<typeof getSpaceClassification>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceClassificationSuspenseQueryOptions(spaceClassificationId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceClassificationSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>, TError = ErrorType<unknown>>(spaceClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceClassificationQueryKey(spaceClassificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpaceClassification>>> = ({ signal }) => getSpaceClassification(spaceClassificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceClassificationSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpaceClassification>>>
export type GetSpaceClassificationSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSpaceClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>, TError = ErrorType<unknown>>(
 spaceClassificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpaceClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceClassificationSuspenseInfiniteQueryOptions(spaceClassificationId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSpaceClassification = (
    spaceClassificationId: string,
    updateSpaceClassificationDto: BodyType<UpdateSpaceClassificationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSpaceClassification200AllOf>(
      {url: `/api/v1/spaces/classifications/${spaceClassificationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSpaceClassificationDto
    },
      options);
    }
  


export const getUpdateSpaceClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpaceClassification>>, TError,{spaceClassificationId: string;data: BodyType<UpdateSpaceClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSpaceClassification>>, TError,{spaceClassificationId: string;data: BodyType<UpdateSpaceClassificationDto>}, TContext> => {

const mutationKey = ['updateSpaceClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSpaceClassification>>, {spaceClassificationId: string;data: BodyType<UpdateSpaceClassificationDto>}> = (props) => {
          const {spaceClassificationId,data} = props ?? {};

          return  updateSpaceClassification(spaceClassificationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSpaceClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateSpaceClassification>>>
    export type UpdateSpaceClassificationMutationBody = BodyType<UpdateSpaceClassificationDto>
    export type UpdateSpaceClassificationMutationError = ErrorType<unknown>

    export const useUpdateSpaceClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpaceClassification>>, TError,{spaceClassificationId: string;data: BodyType<UpdateSpaceClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSpaceClassification>>,
        TError,
        {spaceClassificationId: string;data: BodyType<UpdateSpaceClassificationDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSpaceClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteSpaceClassification = (
    spaceClassificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSpaceClassification200AllOf>(
      {url: `/api/v1/spaces/classifications/${spaceClassificationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSpaceClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpaceClassification>>, TError,{spaceClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSpaceClassification>>, TError,{spaceClassificationId: string}, TContext> => {

const mutationKey = ['deleteSpaceClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSpaceClassification>>, {spaceClassificationId: string}> = (props) => {
          const {spaceClassificationId} = props ?? {};

          return  deleteSpaceClassification(spaceClassificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSpaceClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSpaceClassification>>>
    
    export type DeleteSpaceClassificationMutationError = ErrorType<unknown>

    export const useDeleteSpaceClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpaceClassification>>, TError,{spaceClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSpaceClassification>>,
        TError,
        {spaceClassificationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSpaceClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeSpaceClassification = (
    spaceClassificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSpaceClassification200AllOf>(
      {url: `/api/v1/spaces/classifications/${spaceClassificationId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSpaceClassificationMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpaceClassification>>, TError,{spaceClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSpaceClassification>>, TError,{spaceClassificationId: string}, TContext> => {

const mutationKey = ['removeSpaceClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSpaceClassification>>, {spaceClassificationId: string}> = (props) => {
          const {spaceClassificationId} = props ?? {};

          return  removeSpaceClassification(spaceClassificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSpaceClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof removeSpaceClassification>>>
    
    export type RemoveSpaceClassificationMutationError = ErrorType<unknown>

    export const useRemoveSpaceClassification = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpaceClassification>>, TError,{spaceClassificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSpaceClassification>>,
        TError,
        {spaceClassificationId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSpaceClassificationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getCategoriesByQuery = (
    params?: GetCategoriesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategoriesByQuery200AllOf>(
      {url: `/api/v1/categories`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetCategoriesByQueryQueryKey = (params?: GetCategoriesByQueryParams,) => {
    return [`/api/v1/categories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCategoriesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoriesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQueryQueryError = ErrorType<unknown>


export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetCategoriesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoriesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoriesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetCategoriesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoriesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<unknown>>(params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoriesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetCategoriesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoriesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createCategory = (
    createCategoryDto: BodyType<CreateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateCategory200AllOf>(
      {url: `/api/v1/categories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCategoryDto, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext> => {

const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: BodyType<CreateCategoryDto>}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = BodyType<CreateCategoryDto>
    export type CreateCategoryMutationError = ErrorType<unknown>

    export const useCreateCategory = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCategory>>,
        TError,
        {data: BodyType<CreateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getCategoryById = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategoryById200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByIdQueryKey = (categoryId?: string,) => {
    return [`/api/v1/categories/${categoryId}`] as const;
    }

    
export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorType<unknown>


export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdSuspenseQueryError = ErrorType<unknown>


export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdSuspenseQueryOptions(categoryId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<unknown>>(categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCategoryByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<unknown>>(
 categoryId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<unknown>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCategoryByIdSuspenseInfiniteQueryOptions(categoryId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateCategoryById = (
    categoryId: string,
    updateCategoryDto: BodyType<UpdateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateCategoryById200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateCategoryDto
    },
      options);
    }
  


export const getUpdateCategoryByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategoryById>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCategoryById>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext> => {

const mutationKey = ['updateCategoryById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategoryById>>, {categoryId: string;data: BodyType<UpdateCategoryDto>}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategoryById(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategoryById>>>
    export type UpdateCategoryByIdMutationBody = BodyType<UpdateCategoryDto>
    export type UpdateCategoryByIdMutationError = ErrorType<unknown>

    export const useUpdateCategoryById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategoryById>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCategoryById>>,
        TError,
        {categoryId: string;data: BodyType<UpdateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteCategoryById = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteCategoryById200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCategoryByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategoryById>>, TError,{categoryId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCategoryById>>, TError,{categoryId: string}, TContext> => {

const mutationKey = ['deleteCategoryById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategoryById>>, {categoryId: string}> = (props) => {
          const {categoryId} = props ?? {};

          return  deleteCategoryById(categoryId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCategoryByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategoryById>>>
    
    export type DeleteCategoryByIdMutationError = ErrorType<unknown>

    export const useDeleteCategoryById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategoryById>>, TError,{categoryId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteCategoryById>>,
        TError,
        {categoryId: string},
        TContext
      > => {

      const mutationOptions = getDeleteCategoryByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createGroup = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GroupDto>(
      {url: `/api/v1/groups`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,void, TContext> => {

const mutationKey = ['createGroup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGroup>>, void> = () => {
          

          return  createGroup(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof createGroup>>>
    
    export type CreateGroupMutationError = ErrorType<unknown>

    export const useCreateGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createGroup>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateGroupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getGroupsByQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroupsByQuery200AllOf>(
      {url: `/api/v1/groups`, method: 'GET', signal
    },
      options);
    }
  

export const getGetGroupsByQueryQueryKey = () => {
    return [`/api/v1/groups`] as const;
    }

    
export const getGetGroupsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroupsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQueryQueryError = ErrorType<unknown>


export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroupsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroupsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroupsByQueryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroupsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroupsByQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroupsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroupsByQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGroupById = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroupById200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetGroupByIdQueryKey = (groupId?: string,) => {
    return [`/api/v1/groups/${groupId}`] as const;
    }

    
export const getGetGroupByIdQueryOptions = <TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupByIdQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupById>>> = ({ signal }) => getGroupById(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroupByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupById>>>
export type GetGroupByIdQueryError = ErrorType<unknown>


export function useGetGroupById<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupById>>,
          TError,
          Awaited<ReturnType<typeof getGroupById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupById<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupById>>,
          TError,
          Awaited<ReturnType<typeof getGroupById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupById<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGroupById<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroupByIdQueryOptions(groupId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupByIdQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupById>>> = ({ signal }) => getGroupById(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroupByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupById>>>
export type GetGroupByIdSuspenseQueryError = ErrorType<unknown>


export function useGetGroupByIdSuspense<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupByIdSuspense<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupByIdSuspense<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGroupByIdSuspense<TData = Awaited<ReturnType<typeof getGroupById>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroupByIdSuspenseQueryOptions(groupId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroupById>>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupByIdQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupById>>> = ({ signal }) => getGroupById(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetGroupByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupById>>>
export type GetGroupByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroupByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupById>>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupById>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetGroupByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupById>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetGroupByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupById>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetGroupByIdSuspenseInfiniteQueryOptions(groupId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateGroupById = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateGroupById200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'PATCH'
    },
      options);
    }
  


export const getUpdateGroupByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroupById>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateGroupById>>, TError,{groupId: string}, TContext> => {

const mutationKey = ['updateGroupById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGroupById>>, {groupId: string}> = (props) => {
          const {groupId} = props ?? {};

          return  updateGroupById(groupId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGroupByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateGroupById>>>
    
    export type UpdateGroupByIdMutationError = ErrorType<unknown>

    export const useUpdateGroupById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroupById>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateGroupById>>,
        TError,
        {groupId: string},
        TContext
      > => {

      const mutationOptions = getUpdateGroupByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext> => {

const mutationKey = ['deleteGroup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroup>>, {groupId: string}> = (props) => {
          const {groupId} = props ?? {};

          return  deleteGroup(groupId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroup>>>
    
    export type DeleteGroupMutationError = ErrorType<unknown>

    export const useDeleteGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroup>>,
        TError,
        {groupId: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroupMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeGroups = (
    groupIds: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveGroups200AllOf>(
      {url: `/api/v1/groups/${groupIds}`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveGroupsMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext> => {

const mutationKey = ['removeGroups'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeGroups>>, {groupIds: string[]}> = (props) => {
          const {groupIds} = props ?? {};

          return  removeGroups(groupIds,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof removeGroups>>>
    
    export type RemoveGroupsMutationError = ErrorType<unknown>

    export const useRemoveGroups = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeGroups>>,
        TError,
        {groupIds: string[]},
        TContext
      > => {

      const mutationOptions = getRemoveGroupsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getCurrentSpace = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCurrentSpace200AllOf>(
      {url: `/api/v1/spaces/current`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentSpaceQueryKey = () => {
    return [`/api/v1/spaces/current`] as const;
    }

    
export const getGetCurrentSpaceQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentSpaceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentSpace>>> = ({ signal }) => getCurrentSpace(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentSpaceQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentSpace>>>
export type GetCurrentSpaceQueryError = ErrorType<unknown>


export function useGetCurrentSpace<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentSpace>>,
          TError,
          Awaited<ReturnType<typeof getCurrentSpace>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentSpace<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCurrentSpace>>,
          TError,
          Awaited<ReturnType<typeof getCurrentSpace>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentSpace<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCurrentSpace<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentSpaceQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentSpaceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentSpaceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentSpace>>> = ({ signal }) => getCurrentSpace(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentSpaceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentSpace>>>
export type GetCurrentSpaceSuspenseQueryError = ErrorType<unknown>


export function useGetCurrentSpaceSuspense<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentSpaceSuspense<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentSpaceSuspense<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCurrentSpaceSuspense<TData = Awaited<ReturnType<typeof getCurrentSpace>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentSpaceSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentSpaceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentSpace>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentSpaceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentSpace>>> = ({ signal }) => getCurrentSpace(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCurrentSpaceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentSpace>>>
export type GetCurrentSpaceSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetCurrentSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentSpace>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentSpace>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCurrentSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentSpace>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetCurrentSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCurrentSpace>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCurrentSpaceSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createSpace = (
    createSpaceDto: BodyType<CreateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSpace200AllOf>(
      {url: `/api/v1/spaces`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSpaceDto, signal
    },
      options);
    }
  


export const getCreateSpaceMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext> => {

const mutationKey = ['createSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSpace>>, {data: BodyType<CreateSpaceDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSpace(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof createSpace>>>
    export type CreateSpaceMutationBody = BodyType<CreateSpaceDto>
    export type CreateSpaceMutationError = ErrorType<unknown>

    export const useCreateSpace = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSpace>>,
        TError,
        {data: BodyType<CreateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getCreateSpaceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getSpacesByQuery = (
    params?: GetSpacesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpacesByQuery200AllOf>(
      {url: `/api/v1/spaces`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSpacesByQueryQueryKey = (params?: GetSpacesByQueryParams,) => {
    return [`/api/v1/spaces`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSpacesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpacesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQueryQueryError = ErrorType<unknown>


export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpacesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpacesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpacesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpacesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpacesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<unknown>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpacesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpacesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSpaceQueryKey = (spaceId?: string,) => {
    return [`/api/v1/spaces/${spaceId}`] as const;
    }

    
export const getGetSpaceQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceQueryError = ErrorType<unknown>


export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          Awaited<ReturnType<typeof getSpace>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          Awaited<ReturnType<typeof getSpace>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceQueryOptions(spaceId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseQueryError = ErrorType<unknown>


export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceSuspenseQueryOptions(spaceId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<unknown>>(spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSpaceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<unknown>>(
 spaceId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<unknown>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSpaceSuspenseInfiniteQueryOptions(spaceId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSpace = (
    spaceId: string,
    updateSpaceDto: BodyType<UpdateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSpaceDto
    },
      options);
    }
  


export const getUpdateSpaceMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext> => {

const mutationKey = ['updateSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSpace>>, {spaceId: string;data: BodyType<UpdateSpaceDto>}> = (props) => {
          const {spaceId,data} = props ?? {};

          return  updateSpace(spaceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof updateSpace>>>
    export type UpdateSpaceMutationBody = BodyType<UpdateSpaceDto>
    export type UpdateSpaceMutationError = ErrorType<unknown>

    export const useUpdateSpace = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSpace>>,
        TError,
        {spaceId: string;data: BodyType<UpdateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSpaceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSpaceMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext> => {

const mutationKey = ['deleteSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  deleteSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSpace>>>
    
    export type DeleteSpaceMutationError = ErrorType<unknown>

    export const useDeleteSpace = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSpace>>,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSpaceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSpaceMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext> => {

const mutationKey = ['removeSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  removeSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof removeSpace>>>
    
    export type RemoveSpaceMutationError = ErrorType<unknown>

    export const useRemoveSpace = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSpace>>,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSpaceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createUser = (
    createUserDto: BodyType<CreateUserDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateUser200AllOf>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      options);
    }
  


export const getCreateUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: BodyType<CreateUserDto>}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: BodyType<CreateUserDto>}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = BodyType<CreateUserDto>
    export type CreateUserMutationError = ErrorType<unknown>

    export const useCreateUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: BodyType<CreateUserDto>},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getUsersByQuery = (
    params?: GetUsersByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUsersByQuery200AllOf>(
      {url: `/api/v1/users`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUsersByQueryQueryKey = (params?: GetUsersByQueryParams,) => {
    return [`/api/v1/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQueryQueryError = ErrorType<unknown>


export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          Awaited<ReturnType<typeof getUsersByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          Awaited<ReturnType<typeof getUsersByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<unknown>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUsersByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUsersByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = (userId?: string,) => {
    return [`/api/v1/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorType<unknown>


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseQueryError = ErrorType<unknown>


export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<unknown>>(userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUserSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<unknown>>(
 userId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<unknown>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUserSuspenseInfiniteQueryOptions(userId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateUser = (
    userId: string,
    updateUserDto: BodyType<UpdateUserDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserDto
    },
      options);
    }
  


export const getUpdateUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {userId: string;data: BodyType<UpdateUserDto>}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUser(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = BodyType<UpdateUserDto>
    export type UpdateUserMutationError = ErrorType<unknown>

    export const useUpdateUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {userId: string;data: BodyType<UpdateUserDto>},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = ErrorType<unknown>

    export const useDeleteUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeUsers = (
    removeUsersBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveUsers200AllOf>(
      {url: `/api/v1/users/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeUsersBody
    },
      options);
    }
  


export const getRemoveUsersMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUsers>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeUsers>>, TError,{data: BodyType<string[]>}, TContext> => {

const mutationKey = ['removeUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUsers>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeUsers(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUsersMutationResult = NonNullable<Awaited<ReturnType<typeof removeUsers>>>
    export type RemoveUsersMutationBody = BodyType<string[]>
    export type RemoveUsersMutationError = ErrorType<unknown>

    export const useRemoveUsers = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUsers>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeUsers>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveUsersMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveUser200AllOf>(
      {url: `/api/v1/users/${userId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['removeUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  removeUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserMutationResult = NonNullable<Awaited<ReturnType<typeof removeUser>>>
    
    export type RemoveUserMutationError = ErrorType<unknown>

    export const useRemoveUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getRemoveUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const login = (
    loginPayloadDto: BodyType<LoginPayloadDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Login200AllOf>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginPayloadDto, signal
    },
      options);
    }
  


export const getLoginMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: BodyType<LoginPayloadDto>}, TContext> => {

const mutationKey = ['login'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: BodyType<LoginPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  login(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = BodyType<LoginPayloadDto>
    export type LoginMutationError = ErrorType<unknown>

    export const useLogin = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof login>>,
        TError,
        {data: BodyType<LoginPayloadDto>},
        TContext
      > => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const refreshToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<RefreshToken200AllOf>(
      {url: `/api/v1/auth/token/refresh`, method: 'POST', signal
    },
      options);
    }
  


export const getRefreshTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,void, TContext> => {

const mutationKey = ['refreshToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshToken>>, void> = () => {
          

          return  refreshToken(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenMutationResult = NonNullable<Awaited<ReturnType<typeof refreshToken>>>
    
    export type RefreshTokenMutationError = ErrorType<unknown>

    export const useRefreshToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshToken>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshToken>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getNewToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetNewToken200AllOf>(
      {url: `/api/v1/auth/new-token`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNewTokenQueryKey = () => {
    return [`/api/v1/auth/new-token`] as const;
    }

    
export const getGetNewTokenQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenQueryError = ErrorType<unknown>


export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          Awaited<ReturnType<typeof getNewToken>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          Awaited<ReturnType<typeof getNewToken>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewTokenQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewTokenSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseQueryError = ErrorType<unknown>


export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewTokenSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNewTokenSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetNewTokenSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const signUpUser = (
    signUpPayloadDto: BodyType<SignUpPayloadDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SignUpUser201AllOf>(
      {url: `/api/v1/auth/sign-up`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signUpPayloadDto, signal
    },
      options);
    }
  


export const getSignUpUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext> => {

const mutationKey = ['signUpUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUpUser>>, {data: BodyType<SignUpPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  signUpUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignUpUserMutationResult = NonNullable<Awaited<ReturnType<typeof signUpUser>>>
    export type SignUpUserMutationBody = BodyType<SignUpPayloadDto>
    export type SignUpUserMutationError = ErrorType<unknown>

    export const useSignUpUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof signUpUser>>,
        TError,
        {data: BodyType<SignUpPayloadDto>},
        TContext
      > => {

      const mutationOptions = getSignUpUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const verifyToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<VerifyToken200AllOf>(
      {url: `/api/v1/auth/verify-token`, method: 'GET', signal
    },
      options);
    }
  

export const getVerifyTokenQueryKey = () => {
    return [`/api/v1/auth/verify-token`] as const;
    }

    
export const getVerifyTokenQueryOptions = <TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVerifyTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({ signal }) => verifyToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VerifyTokenQueryResult = NonNullable<Awaited<ReturnType<typeof verifyToken>>>
export type VerifyTokenQueryError = ErrorType<unknown>


export function useVerifyToken<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyToken>>,
          TError,
          Awaited<ReturnType<typeof verifyToken>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyToken<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyToken>>,
          TError,
          Awaited<ReturnType<typeof verifyToken>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyToken<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVerifyToken<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVerifyTokenQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getVerifyTokenSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVerifyTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({ signal }) => verifyToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VerifyTokenSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof verifyToken>>>
export type VerifyTokenSuspenseQueryError = ErrorType<unknown>


export function useVerifyTokenSuspense<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyTokenSuspense<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyTokenSuspense<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVerifyTokenSuspense<TData = Awaited<ReturnType<typeof verifyToken>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVerifyTokenSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getVerifyTokenSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVerifyTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({ signal }) => verifyToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VerifyTokenSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof verifyToken>>>
export type VerifyTokenSuspenseInfiniteQueryError = ErrorType<unknown>


export function useVerifyTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVerifyTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVerifyTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVerifyTokenSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const logout = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Logout200AllOf>(
      {url: `/api/v1/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getLogoutMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext> => {

const mutationKey = ['logout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logout>>, void> = () => {
          

          return  logout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutMutationResult = NonNullable<Awaited<ReturnType<typeof logout>>>
    
    export type LogoutMutationError = ErrorType<unknown>

    export const useLogout = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createRole = (
    createRoleDto: BodyType<CreateRoleDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateRole200AllOf>(
      {url: `/api/v1/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createRoleDto, signal
    },
      options);
    }
  


export const getCreateRoleMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: BodyType<CreateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: BodyType<CreateRoleDto>}, TContext> => {

const mutationKey = ['createRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRole>>, {data: BodyType<CreateRoleDto>}> = (props) => {
          const {data} = props ?? {};

          return  createRole(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createRole>>>
    export type CreateRoleMutationBody = BodyType<CreateRoleDto>
    export type CreateRoleMutationError = ErrorType<unknown>

    export const useCreateRole = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: BodyType<CreateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRole>>,
        TError,
        {data: BodyType<CreateRoleDto>},
        TContext
      > => {

      const mutationOptions = getCreateRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getRolesByQuery = (
    params?: GetRolesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRolesByQuery200AllOf>(
      {url: `/api/v1/roles`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRolesByQueryQueryKey = (params?: GetRolesByQueryParams,) => {
    return [`/api/v1/roles`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRolesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQueryQueryError = ErrorType<unknown>


export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRolesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRolesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRolesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRolesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<unknown>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRolesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRolesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoleQueryKey = (roleId?: string,) => {
    return [`/api/v1/roles/${roleId}`] as const;
    }

    
export const getGetRoleQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleQueryError = ErrorType<unknown>


export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          Awaited<ReturnType<typeof getRole>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          Awaited<ReturnType<typeof getRole>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleQueryOptions(roleId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseQueryError = ErrorType<unknown>


export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleSuspenseQueryOptions(roleId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<unknown>>(roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoleSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<unknown>>(
 roleId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<unknown>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoleSuspenseInfiniteQueryOptions(roleId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateRole = (
    roleId: string,
    updateRoleDto: BodyType<UpdateRoleDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateRoleDto
    },
      options);
    }
  


export const getUpdateRoleMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext> => {

const mutationKey = ['updateRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {roleId: string;data: BodyType<UpdateRoleDto>}> = (props) => {
          const {roleId,data} = props ?? {};

          return  updateRole(roleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = BodyType<UpdateRoleDto>
    export type UpdateRoleMutationError = ErrorType<unknown>

    export const useUpdateRole = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRole>>,
        TError,
        {roleId: string;data: BodyType<UpdateRoleDto>},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoleMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{roleId: string}, TContext> => {

const mutationKey = ['deleteRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  deleteRole(roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = ErrorType<unknown>

    export const useDeleteRole = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRole>>,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveRole200AllOf>(
      {url: `/api/v1/roles/${roleId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveRoleMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{roleId: string}, TContext> => {

const mutationKey = ['removeRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  removeRole(roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveRoleMutationResult = NonNullable<Awaited<ReturnType<typeof removeRole>>>
    
    export type RemoveRoleMutationError = ErrorType<unknown>

    export const useRemoveRole = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeRole>>,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getRemoveRoleMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createSubject = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSubject200AllOf>(
      {url: `/api/v1/subjects`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateSubjectMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,void, TContext> => {

const mutationKey = ['createSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubject>>, void> = () => {
          

          return  createSubject(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof createSubject>>>
    
    export type CreateSubjectMutationError = ErrorType<unknown>

    export const useCreateSubject = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSubject>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateSubjectMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getSubjectsByQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubjectsByQuery200AllOf>(
      {url: `/api/v1/subjects`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubjectsByQueryQueryKey = () => {
    return [`/api/v1/subjects`] as const;
    }

    
export const getGetSubjectsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQueryQueryError = ErrorType<unknown>


export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSubjectsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSubjectsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectsByQueryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectsByQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectsByQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubjectQueryKey = (subjectId?: string,) => {
    return [`/api/v1/subjects/${subjectId}`] as const;
    }

    
export const getGetSubjectQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectQueryError = ErrorType<unknown>


export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectQueryOptions(subjectId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectSuspenseQueryError = ErrorType<unknown>


export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectSuspenseQueryOptions(subjectId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<unknown>>(subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSubjectSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<unknown>>(
 subjectId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSubjectSuspenseInfiniteQueryOptions(subjectId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'PATCH'
    },
      options);
    }
  


export const getUpdateSubjectMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{subjectId: string}, TContext> => {

const mutationKey = ['updateSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  updateSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubject>>>
    
    export type UpdateSubjectMutationError = ErrorType<unknown>

    export const useUpdateSubject = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSubject>>,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getUpdateSubjectMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSubjectMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{subjectId: string}, TContext> => {

const mutationKey = ['deleteSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  deleteSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubject>>>
    
    export type DeleteSubjectMutationError = ErrorType<unknown>

    export const useDeleteSubject = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubject>>,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubjectMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeSubjects = (
    removeSubjectsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSubjects200AllOf>(
      {url: `/api/v1/subjects/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSubjectsBody
    },
      options);
    }
  


export const getRemoveSubjectsMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubjects>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSubjects>>, TError,{data: BodyType<string[]>}, TContext> => {

const mutationKey = ['removeSubjects'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubjects>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSubjects(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSubjectsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubjects>>>
    export type RemoveSubjectsMutationBody = BodyType<string[]>
    export type RemoveSubjectsMutationError = ErrorType<unknown>

    export const useRemoveSubjects = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubjects>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSubjects>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSubjectMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSubject>>, TError,{subjectId: string}, TContext> => {

const mutationKey = ['removeSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  removeSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubject>>>
    
    export type RemoveSubjectMutationError = ErrorType<unknown>

    export const useRemoveSubject = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSubject>>,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createTimeline = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateTimeline200AllOf>(
      {url: `/api/v1/timelines`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateTimelineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTimeline>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTimeline>>, TError,void, TContext> => {

const mutationKey = ['createTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimeline>>, void> = () => {
          

          return  createTimeline(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof createTimeline>>>
    
    export type CreateTimelineMutationError = ErrorType<unknown>

    export const useCreateTimeline = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTimeline>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTimeline>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateTimelineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getTimelinesByQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimelinesByQuery200AllOf>(
      {url: `/api/v1/timelines`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTimelinesByQueryQueryKey = () => {
    return [`/api/v1/timelines`] as const;
    }

    
export const getGetTimelinesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelinesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQueryQueryError = ErrorType<unknown>


export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTimelinesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTimelinesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelinesByQueryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelinesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelinesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelinesByQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelinesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelinesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelinesByQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTimelineQueryKey = (timelineId?: string,) => {
    return [`/api/v1/timelines/${timelineId}`] as const;
    }

    
export const getGetTimelineQueryOptions = <TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineQueryError = ErrorType<unknown>


export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          Awaited<ReturnType<typeof getTimeline>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          Awaited<ReturnType<typeof getTimeline>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelineQueryOptions(timelineId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineSuspenseQueryError = ErrorType<unknown>


export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelineSuspenseQueryOptions(timelineId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<unknown>>(timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTimelineSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<unknown>>(
 timelineId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<unknown>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTimelineSuspenseInfiniteQueryOptions(timelineId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'PATCH'
    },
      options);
    }
  


export const getUpdateTimelineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTimeline>>, TError,{timelineId: string}, TContext> => {

const mutationKey = ['updateTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  updateTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeline>>>
    
    export type UpdateTimelineMutationError = ErrorType<unknown>

    export const useUpdateTimeline = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTimeline>>,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getUpdateTimelineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTimelineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTimeline>>, TError,{timelineId: string}, TContext> => {

const mutationKey = ['deleteTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  deleteTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeline>>>
    
    export type DeleteTimelineMutationError = ErrorType<unknown>

    export const useDeleteTimeline = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTimeline>>,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTimelineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeTimelines = (
    removeTimelinesBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimelines200AllOf>(
      {url: `/api/v1/timelines/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeTimelinesBody
    },
      options);
    }
  


export const getRemoveTimelinesMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelines>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTimelines>>, TError,{data: BodyType<string[]>}, TContext> => {

const mutationKey = ['removeTimelines'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimelines>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeTimelines(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTimelinesMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimelines>>>
    export type RemoveTimelinesMutationBody = BodyType<string[]>
    export type RemoveTimelinesMutationError = ErrorType<unknown>

    export const useRemoveTimelines = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelines>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeTimelines>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveTimelinesMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveTimelineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTimeline>>, TError,{timelineId: string}, TContext> => {

const mutationKey = ['removeTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  removeTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimeline>>>
    
    export type RemoveTimelineMutationError = ErrorType<unknown>

    export const useRemoveTimeline = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeTimeline>>,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTimelineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createSession = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSession200AllOf>(
      {url: `/api/v1/sessions`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,void, TContext> => {

const mutationKey = ['createSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, void> = () => {
          

          return  createSession(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    
    export type CreateSessionMutationError = ErrorType<unknown>

    export const useCreateSession = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getSessionsByQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSessionsByQuery200AllOf>(
      {url: `/api/v1/sessions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionsByQueryQueryKey = () => {
    return [`/api/v1/sessions`] as const;
    }

    
export const getGetSessionsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQueryQueryError = ErrorType<unknown>


export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSessionsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSessionsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionsByQueryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionsByQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionsByQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionQueryKey = (sessionId?: string,) => {
    return [`/api/v1/sessions/${sessionId}`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = ErrorType<unknown>


export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseQueryError = ErrorType<unknown>


export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionSuspenseQueryOptions(sessionId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<unknown>>(sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetSessionSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<unknown>>(
 sessionId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<unknown>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetSessionSuspenseInfiniteQueryOptions(sessionId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'PATCH'
    },
      options);
    }
  


export const getUpdateSessionMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['updateSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  updateSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    
    export type UpdateSessionMutationError = ErrorType<unknown>

    export const useUpdateSession = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSessionMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['deleteSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  deleteSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSession>>>
    
    export type DeleteSessionMutationError = ErrorType<unknown>

    export const useDeleteSession = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeSessions = (
    removeSessionsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSessions200AllOf>(
      {url: `/api/v1/sessions/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSessionsBody
    },
      options);
    }
  


export const getRemoveSessionsMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext> => {

const mutationKey = ['removeSessions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSessions>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSessions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSessions>>>
    export type RemoveSessionsMutationBody = BodyType<string[]>
    export type RemoveSessionsMutationError = ErrorType<unknown>

    export const useRemoveSessions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSessions>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSessionsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSessionMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext> => {

const mutationKey = ['removeSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  removeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof removeSession>>>
    
    export type RemoveSessionMutationError = ErrorType<unknown>

    export const useRemoveSession = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSessionMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createProgram = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateProgram200AllOf>(
      {url: `/api/v1/programs`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateProgramMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgram>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createProgram>>, TError,void, TContext> => {

const mutationKey = ['createProgram'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProgram>>, void> = () => {
          

          return  createProgram(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateProgramMutationResult = NonNullable<Awaited<ReturnType<typeof createProgram>>>
    
    export type CreateProgramMutationError = ErrorType<unknown>

    export const useCreateProgram = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createProgram>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createProgram>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateProgramMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getProgramsByQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetProgramsByQuery200AllOf>(
      {url: `/api/v1/programs`, method: 'GET', signal
    },
      options);
    }
  

export const getGetProgramsByQueryQueryKey = () => {
    return [`/api/v1/programs`] as const;
    }

    
export const getGetProgramsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramsByQuery>>> = ({ signal }) => getProgramsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramsByQuery>>>
export type GetProgramsByQueryQueryError = ErrorType<unknown>


export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getProgramsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getProgramsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramsByQueryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramsByQuery>>> = ({ signal }) => getProgramsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramsByQuery>>>
export type GetProgramsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramsByQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramsByQuery>>> = ({ signal }) => getProgramsByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramsByQuery>>>
export type GetProgramsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramsByQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getProgramById = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetProgramById200AllOf>(
      {url: `/api/v1/programs/${programId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetProgramByIdQueryKey = (programId?: string,) => {
    return [`/api/v1/programs/${programId}`] as const;
    }

    
export const getGetProgramByIdQueryOptions = <TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramByIdQueryKey(programId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramById>>> = ({ signal }) => getProgramById(programId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(programId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramById>>>
export type GetProgramByIdQueryError = ErrorType<unknown>


export function useGetProgramById<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramById>>,
          TError,
          Awaited<ReturnType<typeof getProgramById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramById<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramById>>,
          TError,
          Awaited<ReturnType<typeof getProgramById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramById<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProgramById<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramByIdQueryOptions(programId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramByIdQueryKey(programId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramById>>> = ({ signal }) => getProgramById(programId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramById>>>
export type GetProgramByIdSuspenseQueryError = ErrorType<unknown>


export function useGetProgramByIdSuspense<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramByIdSuspense<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramByIdSuspense<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProgramByIdSuspense<TData = Awaited<ReturnType<typeof getProgramById>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramByIdSuspenseQueryOptions(programId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>, TError = ErrorType<unknown>>(programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramByIdQueryKey(programId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramById>>> = ({ signal }) => getProgramById(programId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetProgramByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramById>>>
export type GetProgramByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetProgramByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>, TError = ErrorType<unknown>>(
 programId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetProgramByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetProgramByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>, TError = ErrorType<unknown>>(
 programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetProgramByIdSuspenseInfiniteQueryOptions(programId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateProgramById = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateProgramById200AllOf>(
      {url: `/api/v1/programs/${programId}`, method: 'PATCH'
    },
      options);
    }
  


export const getUpdateProgramByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramById>>, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateProgramById>>, TError,{programId: string}, TContext> => {

const mutationKey = ['updateProgramById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProgramById>>, {programId: string}> = (props) => {
          const {programId} = props ?? {};

          return  updateProgramById(programId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateProgramByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateProgramById>>>
    
    export type UpdateProgramByIdMutationError = ErrorType<unknown>

    export const useUpdateProgramById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateProgramById>>, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateProgramById>>,
        TError,
        {programId: string},
        TContext
      > => {

      const mutationOptions = getUpdateProgramByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteProgramById = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteProgramById200AllOf>(
      {url: `/api/v1/programs/${programId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProgramByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramById>>, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteProgramById>>, TError,{programId: string}, TContext> => {

const mutationKey = ['deleteProgramById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProgramById>>, {programId: string}> = (props) => {
          const {programId} = props ?? {};

          return  deleteProgramById(programId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteProgramByIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProgramById>>>
    
    export type DeleteProgramByIdMutationError = ErrorType<unknown>

    export const useDeleteProgramById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteProgramById>>, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteProgramById>>,
        TError,
        {programId: string},
        TContext
      > => {

      const mutationOptions = getDeleteProgramByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeProgramById = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveProgramById200AllOf>(
      {url: `/api/v1/programs/${programId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveProgramByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeProgramById>>, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeProgramById>>, TError,{programId: string}, TContext> => {

const mutationKey = ['removeProgramById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeProgramById>>, {programId: string}> = (props) => {
          const {programId} = props ?? {};

          return  removeProgramById(programId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveProgramByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeProgramById>>>
    
    export type RemoveProgramByIdMutationError = ErrorType<unknown>

    export const useRemoveProgramById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeProgramById>>, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeProgramById>>,
        TError,
        {programId: string},
        TContext
      > => {

      const mutationOptions = getRemoveProgramByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createRoutine = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateRoutine200AllOf>(
      {url: `/api/v1/routines`, method: 'POST', signal
    },
      options);
    }
  


export const getCreateRoutineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoutine>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createRoutine>>, TError,void, TContext> => {

const mutationKey = ['createRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoutine>>, void> = () => {
          

          return  createRoutine(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof createRoutine>>>
    
    export type CreateRoutineMutationError = ErrorType<unknown>

    export const useCreateRoutine = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRoutine>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createRoutine>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateRoutineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getRoutinesByQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRoutinesByQuery200AllOf>(
      {url: `/api/v1/routines`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoutinesByQueryQueryKey = () => {
    return [`/api/v1/routines`] as const;
    }

    
export const getGetRoutinesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutinesByQuery>>> = ({ signal }) => getRoutinesByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoutinesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutinesByQuery>>>
export type GetRoutinesByQueryQueryError = ErrorType<unknown>


export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRoutinesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRoutinesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoutinesByQueryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutinesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutinesByQuery>>> = ({ signal }) => getRoutinesByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoutinesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutinesByQuery>>>
export type GetRoutinesByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoutinesByQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutinesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutinesByQuery>>> = ({ signal }) => getRoutinesByQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoutinesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutinesByQuery>>>
export type GetRoutinesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoutinesByQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoutineQueryKey = (routineId?: string,) => {
    return [`/api/v1/routines/${routineId}`] as const;
    }

    
export const getGetRoutineQueryOptions = <TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({ signal }) => getRoutine(routineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(routineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoutineQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutine>>>
export type GetRoutineQueryError = ErrorType<unknown>


export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutine>>,
          TError,
          Awaited<ReturnType<typeof getRoutine>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutine>>,
          TError,
          Awaited<ReturnType<typeof getRoutine>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoutineQueryOptions(routineId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({ signal }) => getRoutine(routineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoutineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutine>>>
export type GetRoutineSuspenseQueryError = ErrorType<unknown>


export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoutineSuspenseQueryOptions(routineId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutineSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<unknown>>(routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({ signal }) => getRoutine(routineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRoutineSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutine>>>
export type GetRoutineSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<unknown>>(
 routineId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<unknown>>(
 routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetRoutineSuspenseInfiniteQueryOptions(routineId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}`, method: 'PATCH'
    },
      options);
    }
  


export const getUpdateRoutineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoutine>>, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRoutine>>, TError,{routineId: string}, TContext> => {

const mutationKey = ['updateRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoutine>>, {routineId: string}> = (props) => {
          const {routineId} = props ?? {};

          return  updateRoutine(routineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoutine>>>
    
    export type UpdateRoutineMutationError = ErrorType<unknown>

    export const useUpdateRoutine = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRoutine>>, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRoutine>>,
        TError,
        {routineId: string},
        TContext
      > => {

      const mutationOptions = getUpdateRoutineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoutineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoutine>>, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRoutine>>, TError,{routineId: string}, TContext> => {

const mutationKey = ['deleteRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoutine>>, {routineId: string}> = (props) => {
          const {routineId} = props ?? {};

          return  deleteRoutine(routineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoutine>>>
    
    export type DeleteRoutineMutationError = ErrorType<unknown>

    export const useDeleteRoutine = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRoutine>>, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteRoutine>>,
        TError,
        {routineId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoutineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveRoutineMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRoutine>>, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeRoutine>>, TError,{routineId: string}, TContext> => {

const mutationKey = ['removeRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRoutine>>, {routineId: string}> = (props) => {
          const {routineId} = props ?? {};

          return  removeRoutine(routineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof removeRoutine>>>
    
    export type RemoveRoutineMutationError = ErrorType<unknown>

    export const useRemoveRoutine = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRoutine>>, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeRoutine>>,
        TError,
        {routineId: string},
        TContext
      > => {

      const mutationOptions = getRemoveRoutineMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getExercisesByQuery = (
    params?: GetExercisesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetExercisesByQuery200AllOf>(
      {url: `/api/v1/exercises`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetExercisesByQueryQueryKey = (params?: GetExercisesByQueryParams,) => {
    return [`/api/v1/exercises`, ...(params ? [params]: [])] as const;
    }

    
export const getGetExercisesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesByQuery>>> = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExercisesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesByQuery>>>
export type GetExercisesByQueryQueryError = ErrorType<unknown>


export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetExercisesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getExercisesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getExercisesByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExercisesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExercisesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesByQuery>>> = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExercisesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesByQuery>>>
export type GetExercisesByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetExercisesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExercisesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExercisesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<unknown>>(params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesByQuery>>> = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExercisesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesByQuery>>>
export type GetExercisesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetExercisesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExercisesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createExercise = (
    createExerciseDto: BodyType<CreateExerciseDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateExercise200AllOf>(
      {url: `/api/v1/exercises`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createExerciseDto, signal
    },
      options);
    }
  


export const getCreateExerciseMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExercise>>, TError,{data: BodyType<CreateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createExercise>>, TError,{data: BodyType<CreateExerciseDto>}, TContext> => {

const mutationKey = ['createExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExercise>>, {data: BodyType<CreateExerciseDto>}> = (props) => {
          const {data} = props ?? {};

          return  createExercise(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof createExercise>>>
    export type CreateExerciseMutationBody = BodyType<CreateExerciseDto>
    export type CreateExerciseMutationError = ErrorType<unknown>

    export const useCreateExercise = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExercise>>, TError,{data: BodyType<CreateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createExercise>>,
        TError,
        {data: BodyType<CreateExerciseDto>},
        TContext
      > => {

      const mutationOptions = getCreateExerciseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getExercise = (
    exerciseId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetExerciseQueryKey = (exerciseId?: string,) => {
    return [`/api/v1/exercises/${exerciseId}`] as const;
    }

    
export const getGetExerciseQueryOptions = <TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({ signal }) => getExercise(exerciseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExerciseQueryResult = NonNullable<Awaited<ReturnType<typeof getExercise>>>
export type GetExerciseQueryError = ErrorType<unknown>


export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercise>>,
          TError,
          Awaited<ReturnType<typeof getExercise>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercise>>,
          TError,
          Awaited<ReturnType<typeof getExercise>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExerciseQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExerciseSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({ signal }) => getExercise(exerciseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExerciseSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExercise>>>
export type GetExerciseSuspenseQueryError = ErrorType<unknown>


export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExerciseSuspenseQueryOptions(exerciseId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExerciseSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<unknown>>(exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({ signal }) => getExercise(exerciseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetExerciseSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getExercise>>>
export type GetExerciseSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<unknown>>(
 exerciseId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<unknown>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetExerciseSuspenseInfiniteQueryOptions(exerciseId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateExercise = (
    exerciseId: string,
    updateExerciseDto: BodyType<UpdateExerciseDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateExerciseDto
    },
      options);
    }
  


export const getUpdateExerciseMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExercise>>, TError,{exerciseId: string;data: BodyType<UpdateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateExercise>>, TError,{exerciseId: string;data: BodyType<UpdateExerciseDto>}, TContext> => {

const mutationKey = ['updateExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExercise>>, {exerciseId: string;data: BodyType<UpdateExerciseDto>}> = (props) => {
          const {exerciseId,data} = props ?? {};

          return  updateExercise(exerciseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof updateExercise>>>
    export type UpdateExerciseMutationBody = BodyType<UpdateExerciseDto>
    export type UpdateExerciseMutationError = ErrorType<unknown>

    export const useUpdateExercise = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateExercise>>, TError,{exerciseId: string;data: BodyType<UpdateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateExercise>>,
        TError,
        {exerciseId: string;data: BodyType<UpdateExerciseDto>},
        TContext
      > => {

      const mutationOptions = getUpdateExerciseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteExercise = (
    exerciseId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteExerciseMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteExercise>>, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteExercise>>, TError,{exerciseId: string}, TContext> => {

const mutationKey = ['deleteExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExercise>>, {exerciseId: string}> = (props) => {
          const {exerciseId} = props ?? {};

          return  deleteExercise(exerciseId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExercise>>>
    
    export type DeleteExerciseMutationError = ErrorType<unknown>

    export const useDeleteExercise = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteExercise>>, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteExercise>>,
        TError,
        {exerciseId: string},
        TContext
      > => {

      const mutationOptions = getDeleteExerciseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeExercise = (
    exerciseId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveExerciseMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeExercise>>, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeExercise>>, TError,{exerciseId: string}, TContext> => {

const mutationKey = ['removeExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeExercise>>, {exerciseId: string}> = (props) => {
          const {exerciseId} = props ?? {};

          return  removeExercise(exerciseId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof removeExercise>>>
    
    export type RemoveExerciseMutationError = ErrorType<unknown>

    export const useRemoveExercise = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeExercise>>, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeExercise>>,
        TError,
        {exerciseId: string},
        TContext
      > => {

      const mutationOptions = getRemoveExerciseMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getFileById = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetFileById200AllOf>(
      {url: `/api/v1/files/${fileId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFileByIdQueryKey = (fileId?: string,) => {
    return [`/api/v1/files/${fileId}`] as const;
    }

    
export const getGetFileByIdQueryOptions = <TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdQueryError = ErrorType<unknown>


export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          Awaited<ReturnType<typeof getFileById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          Awaited<ReturnType<typeof getFileById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileByIdQueryOptions(fileId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdSuspenseQueryError = ErrorType<unknown>


export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileByIdSuspenseQueryOptions(fileId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<unknown>>(fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetFileByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<unknown>>(
 fileId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<unknown>>(
 fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetFileByIdSuspenseInfiniteQueryOptions(fileId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateFileById = (
    fileId: string,
    updateFileByIdBody?: BodyType<UpdateFileByIdBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      const formData = new FormData();
if(updateFileByIdBody?.files !== undefined) {
 formData.append(`files`, updateFileByIdBody.files)
 }

      return customInstance<UpdateFileById200AllOf>(
      {url: `/api/v1/files/${fileId}`, method: 'PATCH',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      options);
    }
  


export const getUpdateFileByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFileById>>, TError,{fileId: string;data: BodyType<UpdateFileByIdBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateFileById>>, TError,{fileId: string;data: BodyType<UpdateFileByIdBody>}, TContext> => {

const mutationKey = ['updateFileById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFileById>>, {fileId: string;data: BodyType<UpdateFileByIdBody>}> = (props) => {
          const {fileId,data} = props ?? {};

          return  updateFileById(fileId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateFileByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateFileById>>>
    export type UpdateFileByIdMutationBody = BodyType<UpdateFileByIdBody>
    export type UpdateFileByIdMutationError = ErrorType<unknown>

    export const useUpdateFileById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateFileById>>, TError,{fileId: string;data: BodyType<UpdateFileByIdBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateFileById>>,
        TError,
        {fileId: string;data: BodyType<UpdateFileByIdBody>},
        TContext
      > => {

      const mutationOptions = getUpdateFileByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createFile = (
    createFileDto: BodyType<CreateFileDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateFile201AllOf>(
      {url: `/api/v1/files`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createFileDto, signal
    },
      options);
    }
  


export const getCreateFileMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFile>>, TError,{data: BodyType<CreateFileDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createFile>>, TError,{data: BodyType<CreateFileDto>}, TContext> => {

const mutationKey = ['createFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFile>>, {data: BodyType<CreateFileDto>}> = (props) => {
          const {data} = props ?? {};

          return  createFile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateFileMutationResult = NonNullable<Awaited<ReturnType<typeof createFile>>>
    export type CreateFileMutationBody = BodyType<CreateFileDto>
    export type CreateFileMutationError = ErrorType<unknown>

    export const useCreateFile = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createFile>>, TError,{data: BodyType<CreateFileDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createFile>>,
        TError,
        {data: BodyType<CreateFileDto>},
        TContext
      > => {

      const mutationOptions = getCreateFileMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeFileById = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveFileById200AllOf>(
      {url: `/api/v1/files/${fileId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveFileByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFileById>>, TError,{fileId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeFileById>>, TError,{fileId: string}, TContext> => {

const mutationKey = ['removeFileById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFileById>>, {fileId: string}> = (props) => {
          const {fileId} = props ?? {};

          return  removeFileById(fileId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveFileByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeFileById>>>
    
    export type RemoveFileByIdMutationError = ErrorType<unknown>

    export const useRemoveFileById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeFileById>>, TError,{fileId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeFileById>>,
        TError,
        {fileId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFileByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getMyTenants = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetMyTenants200AllOf>(
      {url: `/api/v1/tenants/my`, method: 'GET', signal
    },
      options);
    }
  

export const getGetMyTenantsQueryKey = () => {
    return [`/api/v1/tenants/my`] as const;
    }

    
export const getGetMyTenantsQueryOptions = <TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyTenantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyTenants>>> = ({ signal }) => getMyTenants(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyTenantsQueryResult = NonNullable<Awaited<ReturnType<typeof getMyTenants>>>
export type GetMyTenantsQueryError = ErrorType<unknown>


export function useGetMyTenants<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTenants>>,
          TError,
          Awaited<ReturnType<typeof getMyTenants>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyTenants<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMyTenants>>,
          TError,
          Awaited<ReturnType<typeof getMyTenants>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyTenants<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMyTenants<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyTenantsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMyTenantsSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyTenantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyTenants>>> = ({ signal }) => getMyTenants(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyTenantsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getMyTenants>>>
export type GetMyTenantsSuspenseQueryError = ErrorType<unknown>


export function useGetMyTenantsSuspense<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyTenantsSuspense<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyTenantsSuspense<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMyTenantsSuspense<TData = Awaited<ReturnType<typeof getMyTenants>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyTenantsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetMyTenantsSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getMyTenants>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMyTenantsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyTenants>>> = ({ signal }) => getMyTenants(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMyTenantsSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getMyTenants>>>
export type GetMyTenantsSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetMyTenantsSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyTenants>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyTenantsSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyTenants>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMyTenantsSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyTenants>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetMyTenantsSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getMyTenants>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getMyTenants>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMyTenantsSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createTenant = (
    createTenantDto: BodyType<CreateTenantDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateTenant200AllOf>(
      {url: `/api/v1/tenants`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTenantDto, signal
    },
      options);
    }
  


export const getCreateTenantMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: BodyType<CreateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: BodyType<CreateTenantDto>}, TContext> => {

const mutationKey = ['createTenant'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenant>>, {data: BodyType<CreateTenantDto>}> = (props) => {
          const {data} = props ?? {};

          return  createTenant(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createTenant>>>
    export type CreateTenantMutationBody = BodyType<CreateTenantDto>
    export type CreateTenantMutationError = ErrorType<unknown>

    export const useCreateTenant = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTenant>>, TError,{data: BodyType<CreateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTenant>>,
        TError,
        {data: BodyType<CreateTenantDto>},
        TContext
      > => {

      const mutationOptions = getCreateTenantMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const getTenantsByQuery = (
    params?: GetTenantsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTenantsByQuery200AllOf>(
      {url: `/api/v1/tenants`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTenantsByQueryQueryKey = (params?: GetTenantsByQueryParams,) => {
    return [`/api/v1/tenants`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTenantsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsByQuery>>> = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsByQuery>>>
export type GetTenantsByQueryQueryError = ErrorType<unknown>


export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetTenantsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTenantsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTenantsByQuery>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsByQuery>>> = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsByQuery>>>
export type GetTenantsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetTenantsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<unknown>>(params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsByQuery>>> = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsByQuery>>>
export type GetTenantsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetTenantsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTenantById = (
    tenantId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTenantById200AllOf>(
      {url: `/api/v1/tenants/${tenantId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTenantByIdQueryKey = (tenantId?: string,) => {
    return [`/api/v1/tenants/${tenantId}`] as const;
    }

    
export const getGetTenantByIdQueryOptions = <TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({ signal }) => getTenantById(tenantId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantById>>>
export type GetTenantByIdQueryError = ErrorType<unknown>


export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantById>>,
          TError,
          Awaited<ReturnType<typeof getTenantById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantById>>,
          TError,
          Awaited<ReturnType<typeof getTenantById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantByIdQueryOptions(tenantId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({ signal }) => getTenantById(tenantId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantById>>>
export type GetTenantByIdSuspenseQueryError = ErrorType<unknown>


export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantByIdSuspenseQueryOptions(tenantId,options)

  const query = useSuspenseQuery(queryOptions , queryClient) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<unknown>>(tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({ signal }) => getTenantById(tenantId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTenantByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantById>>>
export type GetTenantByIdSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<unknown>>(
 tenantId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<unknown>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTenantByIdSuspenseInfiniteQueryOptions(tenantId,options)

  const query = useSuspenseInfiniteQuery(queryOptions , queryClient) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateTenantById = (
    tenantId: string,
    updateTenantDto: BodyType<UpdateTenantDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateTenantById200AllOf>(
      {url: `/api/v1/tenants/${tenantId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTenantDto
    },
      options);
    }
  


export const getUpdateTenantByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantById>>, TError,{tenantId: string;data: BodyType<UpdateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTenantById>>, TError,{tenantId: string;data: BodyType<UpdateTenantDto>}, TContext> => {

const mutationKey = ['updateTenantById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenantById>>, {tenantId: string;data: BodyType<UpdateTenantDto>}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  updateTenantById(tenantId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTenantByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenantById>>>
    export type UpdateTenantByIdMutationBody = BodyType<UpdateTenantDto>
    export type UpdateTenantByIdMutationError = ErrorType<unknown>

    export const useUpdateTenantById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTenantById>>, TError,{tenantId: string;data: BodyType<UpdateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTenantById>>,
        TError,
        {tenantId: string;data: BodyType<UpdateTenantDto>},
        TContext
      > => {

      const mutationOptions = getUpdateTenantByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const deleteTenant = (
    tenantId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteTenant200AllOf>(
      {url: `/api/v1/tenants/${tenantId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTenantMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{tenantId: string}, TContext> => {

const mutationKey = ['deleteTenant'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTenant>>, {tenantId: string}> = (props) => {
          const {tenantId} = props ?? {};

          return  deleteTenant(tenantId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTenantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTenant>>>
    
    export type DeleteTenantMutationError = ErrorType<unknown>

    export const useDeleteTenant = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTenant>>, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTenant>>,
        TError,
        {tenantId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTenantMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const removeTenantById = (
    tenantId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTenantById200AllOf>(
      {url: `/api/v1/tenants/${tenantId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveTenantByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTenantById>>, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTenantById>>, TError,{tenantId: string}, TContext> => {

const mutationKey = ['removeTenantById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTenantById>>, {tenantId: string}> = (props) => {
          const {tenantId} = props ?? {};

          return  removeTenantById(tenantId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTenantByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeTenantById>>>
    
    export type RemoveTenantByIdMutationError = ErrorType<unknown>

    export const useRemoveTenantById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTenantById>>, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeTenantById>>,
        TError,
        {tenantId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTenantByIdMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
