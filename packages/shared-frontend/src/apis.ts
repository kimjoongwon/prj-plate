/**
 * Generated by orval v7.2.0 üç∫
 * Do not edit manually.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  CreateAbility200AllOf,
  CreateAbilityDto,
  CreateAction200AllOf,
  CreateActionDto,
  CreateAssociation200AllOf,
  CreateAssociationDto,
  CreateCategory200AllOf,
  CreateCategoryDto,
  CreateClassification200AllOf,
  CreateClassificationDto,
  CreateGroupDto,
  CreateRole200AllOf,
  CreateRoleDto,
  CreateSession200AllOf,
  CreateSessionDto,
  CreateSpace200AllOf,
  CreateSpaceDto,
  CreateSubject200AllOf,
  CreateSubjectDto,
  CreateTimeline200AllOf,
  CreateTimelineDto,
  CreateUser200AllOf,
  CreateUserDto,
  DeleteAbility200AllOf,
  DeleteAction200AllOf,
  DeleteAssociation200AllOf,
  DeleteCategory200AllOf,
  DeleteClassification200AllOf,
  DeleteGroup200AllOf,
  DeleteRole200AllOf,
  DeleteSession200AllOf,
  DeleteSpace200AllOf,
  DeleteSubject200AllOf,
  DeleteTimeline200AllOf,
  DeleteUser200AllOf,
  GetAbilitiesByQuery200AllOf,
  GetAbilitiesByQueryParams,
  GetAbility200AllOf,
  GetAction200AllOf,
  GetActionsByQuery200AllOf,
  GetActionsByQueryParams,
  GetAssociation200AllOf,
  GetAssociationsByQuery200AllOf,
  GetAssociationsByQueryParams,
  GetCategoriesByQuery200AllOf,
  GetCategoriesByQueryParams,
  GetCategoryById200AllOf,
  GetClassification200AllOf,
  GetClassificationsByQuery200AllOf,
  GetClassificationsByQueryParams,
  GetGroup200AllOf,
  GetGroupsByQuery200AllOf,
  GetGroupsByQueryParams,
  GetRole200AllOf,
  GetRolesByQuery200AllOf,
  GetRolesByQueryParams,
  GetSession200AllOf,
  GetSessionsByQuery200AllOf,
  GetSessionsByQueryParams,
  GetSpace200AllOf,
  GetSpacesByQuery200AllOf,
  GetSpacesByQueryParams,
  GetSubject200AllOf,
  GetSubjectsByQuery200AllOf,
  GetSubjectsByQueryParams,
  GetTimeline200AllOf,
  GetTimelinesByQuery200AllOf,
  GetTimelinesByQueryParams,
  GetToken200AllOf,
  GetUser200AllOf,
  GetUsersByQuery200AllOf,
  GetUsersByQueryParams,
  GroupDto,
  LoginPayloadDto,
  RemoveAbilities200AllOf,
  RemoveAbility200AllOf,
  RemoveAction200AllOf,
  RemoveActions200AllOf,
  RemoveAssociation200AllOf,
  RemoveAssociations200AllOf,
  RemoveClassification200AllOf,
  RemoveClassifications200AllOf,
  RemoveGroups200AllOf,
  RemoveRole200AllOf,
  RemoveSession200AllOf,
  RemoveSessions200AllOf,
  RemoveSpace200AllOf,
  RemoveSubject200AllOf,
  RemoveSubjects200AllOf,
  RemoveTimeline200AllOf,
  RemoveTimelines200AllOf,
  RemoveUser200AllOf,
  RemoveUsers200AllOf,
  SignUpPayloadDto,
  SignUpUser201AllOf,
  TokenDto,
  UpdateAbility200AllOf,
  UpdateAbilityDto,
  UpdateAction200AllOf,
  UpdateActionDto,
  UpdateAssociation200AllOf,
  UpdateAssociationDto,
  UpdateCategory200AllOf,
  UpdateCategoryDto,
  UpdateClassification200AllOf,
  UpdateClassificationDto,
  UpdateGroup200AllOf,
  UpdateGroupDto,
  UpdateRole200AllOf,
  UpdateRoleDto,
  UpdateSession200AllOf,
  UpdateSessionDto,
  UpdateSpace200AllOf,
  UpdateSpaceDto,
  UpdateSubject200AllOf,
  UpdateSubjectDto,
  UpdateTimeline200AllOf,
  UpdateTimelineDto,
  UpdateUser200AllOf,
  UpdateUserDto
} from './model'
import { customInstance } from './libs/customAxios';
import type { ErrorType, BodyType } from './libs/customAxios';



type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


export const createClassification = (
    createClassificationDto: BodyType<CreateClassificationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateClassification200AllOf>(
      {url: `/api/v1/classifications`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createClassificationDto
    },
      options);
    }
  


export const getCreateClassificationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: BodyType<CreateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: BodyType<CreateClassificationDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClassification>>, {data: BodyType<CreateClassificationDto>}> = (props) => {
          const {data} = props ?? {};

          return  createClassification(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createClassification>>>
    export type CreateClassificationMutationBody = BodyType<CreateClassificationDto>
    export type CreateClassificationMutationError = ErrorType<void>

    export const useCreateClassification = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createClassification>>, TError,{data: BodyType<CreateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createClassification>>,
        TError,
        {data: BodyType<CreateClassificationDto>},
        TContext
      > => {

      const mutationOptions = getCreateClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getClassificationsByQuery = (
    params?: GetClassificationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetClassificationsByQuery200AllOf>(
      {url: `/api/v1/classifications`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetClassificationsByQueryQueryKey = (params?: GetClassificationsByQueryParams,) => {
    return [`/api/v1/classifications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetClassificationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationsByQuery>>> = ({ signal }) => getClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClassificationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationsByQuery>>>
export type GetClassificationsByQueryQueryError = ErrorType<void>


export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetClassificationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetClassificationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationsByQuery>>> = ({ signal }) => getClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClassificationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationsByQuery>>>
export type GetClassificationsByQuerySuspenseQueryError = ErrorType<void>


export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetClassificationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetClassificationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationsByQuery>>> = ({ signal }) => getClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClassificationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationsByQuery>>>
export type GetClassificationsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetClassificationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetClassificationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClassification = (
    classificationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetClassificationQueryKey = (classificationId: string,) => {
    return [`/api/v1/classifications/${classificationId}`] as const;
    }

    
export const getGetClassificationQueryOptions = <TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationQueryKey(classificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassification>>> = ({ signal }) => getClassification(classificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(classificationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClassificationQueryResult = NonNullable<Awaited<ReturnType<typeof getClassification>>>
export type GetClassificationQueryError = ErrorType<void>


export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassification>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassification>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetClassificationQueryOptions(classificationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationQueryKey(classificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassification>>> = ({ signal }) => getClassification(classificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(classificationId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClassificationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getClassification>>>
export type GetClassificationSuspenseQueryError = ErrorType<void>


export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetClassificationSuspenseQueryOptions(classificationId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationQueryKey(classificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassification>>> = ({ signal }) => getClassification(classificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(classificationId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData> & { queryKey: QueryKey }
}

export type GetClassificationSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClassification>>>
export type GetClassificationSuspenseInfiniteQueryError = ErrorType<void>


export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetClassificationSuspenseInfiniteQueryOptions(classificationId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateClassification = (
    classificationId: string,
    updateClassificationDto: BodyType<UpdateClassificationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateClassificationDto
    },
      options);
    }
  


export const getUpdateClassificationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{classificationId: string;data: BodyType<UpdateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{classificationId: string;data: BodyType<UpdateClassificationDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClassification>>, {classificationId: string;data: BodyType<UpdateClassificationDto>}> = (props) => {
          const {classificationId,data} = props ?? {};

          return  updateClassification(classificationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateClassification>>>
    export type UpdateClassificationMutationBody = BodyType<UpdateClassificationDto>
    export type UpdateClassificationMutationError = ErrorType<void>

    export const useUpdateClassification = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateClassification>>, TError,{classificationId: string;data: BodyType<UpdateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateClassification>>,
        TError,
        {classificationId: string;data: BodyType<UpdateClassificationDto>},
        TContext
      > => {

      const mutationOptions = getUpdateClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteClassification = (
    classificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteClassificationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{classificationId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClassification>>, {classificationId: string}> = (props) => {
          const {classificationId} = props ?? {};

          return  deleteClassification(classificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClassification>>>
    
    export type DeleteClassificationMutationError = ErrorType<void>

    export const useDeleteClassification = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteClassification>>, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteClassification>>,
        TError,
        {classificationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeClassifications = (
    removeClassificationsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveClassifications200AllOf>(
      {url: `/api/v1/classifications/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeClassificationsBody
    },
      options);
    }
  


export const getRemoveClassificationsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeClassifications>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeClassifications>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeClassifications>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeClassifications(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveClassificationsMutationResult = NonNullable<Awaited<ReturnType<typeof removeClassifications>>>
    export type RemoveClassificationsMutationBody = BodyType<string[]>
    export type RemoveClassificationsMutationError = ErrorType<void>

    export const useRemoveClassifications = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeClassifications>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeClassifications>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveClassificationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeClassification = (
    classificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveClassificationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeClassification>>, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeClassification>>, TError,{classificationId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeClassification>>, {classificationId: string}> = (props) => {
          const {classificationId} = props ?? {};

          return  removeClassification(classificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof removeClassification>>>
    
    export type RemoveClassificationMutationError = ErrorType<void>

    export const useRemoveClassification = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeClassification>>, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeClassification>>,
        TError,
        {classificationId: string},
        TContext
      > => {

      const mutationOptions = getRemoveClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAssociation = (
    createAssociationDto: BodyType<CreateAssociationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateAssociation200AllOf>(
      {url: `/api/v1/associations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAssociationDto
    },
      options);
    }
  


export const getCreateAssociationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssociation>>, TError,{data: BodyType<CreateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createAssociation>>, TError,{data: BodyType<CreateAssociationDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssociation>>, {data: BodyType<CreateAssociationDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAssociation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof createAssociation>>>
    export type CreateAssociationMutationBody = BodyType<CreateAssociationDto>
    export type CreateAssociationMutationError = ErrorType<void>

    export const useCreateAssociation = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssociation>>, TError,{data: BodyType<CreateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createAssociation>>,
        TError,
        {data: BodyType<CreateAssociationDto>},
        TContext
      > => {

      const mutationOptions = getCreateAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAssociationsByQuery = (
    params?: GetAssociationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAssociationsByQuery200AllOf>(
      {url: `/api/v1/associations`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAssociationsByQueryQueryKey = (params?: GetAssociationsByQueryParams,) => {
    return [`/api/v1/associations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAssociationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociationsByQuery>>> = ({ signal }) => getAssociationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssociationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociationsByQuery>>>
export type GetAssociationsByQueryQueryError = ErrorType<void>


export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAssociationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssociationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociationsByQuery>>> = ({ signal }) => getAssociationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssociationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociationsByQuery>>>
export type GetAssociationsByQuerySuspenseQueryError = ErrorType<void>


export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAssociationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssociationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociationsByQuery>>> = ({ signal }) => getAssociationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssociationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociationsByQuery>>>
export type GetAssociationsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetAssociationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssociationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAssociation = (
    associationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssociationQueryKey = (associationId: string,) => {
    return [`/api/v1/associations/${associationId}`] as const;
    }

    
export const getGetAssociationQueryOptions = <TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationQueryKey(associationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociation>>> = ({ signal }) => getAssociation(associationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(associationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssociationQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociation>>>
export type GetAssociationQueryError = ErrorType<void>


export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociation>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociation>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssociationQueryOptions(associationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationQueryKey(associationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociation>>> = ({ signal }) => getAssociation(associationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(associationId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssociationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociation>>>
export type GetAssociationSuspenseQueryError = ErrorType<void>


export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssociationSuspenseQueryOptions(associationId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationQueryKey(associationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociation>>> = ({ signal }) => getAssociation(associationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(associationId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssociationSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociation>>>
export type GetAssociationSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssociationSuspenseInfiniteQueryOptions(associationId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateAssociation = (
    associationId: string,
    updateAssociationDto: BodyType<UpdateAssociationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateAssociationDto
    },
      options);
    }
  


export const getUpdateAssociationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssociation>>, TError,{associationId: string;data: BodyType<UpdateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAssociation>>, TError,{associationId: string;data: BodyType<UpdateAssociationDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssociation>>, {associationId: string;data: BodyType<UpdateAssociationDto>}> = (props) => {
          const {associationId,data} = props ?? {};

          return  updateAssociation(associationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssociation>>>
    export type UpdateAssociationMutationBody = BodyType<UpdateAssociationDto>
    export type UpdateAssociationMutationError = ErrorType<void>

    export const useUpdateAssociation = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssociation>>, TError,{associationId: string;data: BodyType<UpdateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateAssociation>>,
        TError,
        {associationId: string;data: BodyType<UpdateAssociationDto>},
        TContext
      > => {

      const mutationOptions = getUpdateAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAssociation = (
    associationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAssociationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssociation>>, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssociation>>, TError,{associationId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssociation>>, {associationId: string}> = (props) => {
          const {associationId} = props ?? {};

          return  deleteAssociation(associationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssociation>>>
    
    export type DeleteAssociationMutationError = ErrorType<void>

    export const useDeleteAssociation = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssociation>>, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssociation>>,
        TError,
        {associationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAssociations = (
    removeAssociationsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAssociations200AllOf>(
      {url: `/api/v1/associations/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeAssociationsBody
    },
      options);
    }
  


export const getRemoveAssociationsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAssociations>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAssociations>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAssociations>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeAssociations(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveAssociationsMutationResult = NonNullable<Awaited<ReturnType<typeof removeAssociations>>>
    export type RemoveAssociationsMutationBody = BodyType<string[]>
    export type RemoveAssociationsMutationError = ErrorType<void>

    export const useRemoveAssociations = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAssociations>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAssociations>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveAssociationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAssociation = (
    associationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveAssociationMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAssociation>>, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAssociation>>, TError,{associationId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAssociation>>, {associationId: string}> = (props) => {
          const {associationId} = props ?? {};

          return  removeAssociation(associationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof removeAssociation>>>
    
    export type RemoveAssociationMutationError = ErrorType<void>

    export const useRemoveAssociation = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAssociation>>, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAssociation>>,
        TError,
        {associationId: string},
        TContext
      > => {

      const mutationOptions = getRemoveAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAppBuilder = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/builder`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAppBuilderQueryKey = () => {
    return [`/api/v1/builder`] as const;
    }

    
export const getGetAppBuilderQueryOptions = <TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({ signal }) => getAppBuilder(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAppBuilderQueryResult = NonNullable<Awaited<ReturnType<typeof getAppBuilder>>>
export type GetAppBuilderQueryError = ErrorType<void>


export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppBuilder>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppBuilder>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAppBuilderQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAppBuilderSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({ signal }) => getAppBuilder(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAppBuilderSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAppBuilder>>>
export type GetAppBuilderSuspenseQueryError = ErrorType<void>


export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAppBuilderSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAppBuilderSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({ signal }) => getAppBuilder(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAppBuilderSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAppBuilder>>>
export type GetAppBuilderSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAppBuilderSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCategoriesByQuery = (
    params: GetCategoriesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategoriesByQuery200AllOf>(
      {url: `/api/v1/categories`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetCategoriesByQueryQueryKey = (params: GetCategoriesByQueryParams,) => {
    return [`/api/v1/categories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCategoriesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoriesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQueryQueryError = ErrorType<void>


export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCategoriesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoriesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQuerySuspenseQueryError = ErrorType<void>


export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCategoriesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoriesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCategoriesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createCategory = (
    createCategoryDto: BodyType<CreateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateCategory200AllOf>(
      {url: `/api/v1/categories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCategoryDto
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: BodyType<CreateCategoryDto>}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = BodyType<CreateCategoryDto>
    export type CreateCategoryMutationError = ErrorType<void>

    export const useCreateCategory = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createCategory>>,
        TError,
        {data: BodyType<CreateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getCategoryById = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategoryById200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByIdQueryKey = (categoryId: string,) => {
    return [`/api/v1/categories/${categoryId}`] as const;
    }

    
export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorType<void>


export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCategoryByIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoryByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdSuspenseQueryError = ErrorType<void>


export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCategoryByIdSuspenseQueryOptions(categoryId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoryByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdSuspenseInfiniteQueryError = ErrorType<void>


export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCategoryByIdSuspenseInfiniteQueryOptions(categoryId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateCategory = (
    categoryId: string,
    updateCategoryDto: BodyType<UpdateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateCategory200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateCategoryDto
    },
      options);
    }
  


export const getUpdateCategoryMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, {categoryId: string;data: BodyType<UpdateCategoryDto>}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategory(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
    export type UpdateCategoryMutationBody = BodyType<UpdateCategoryDto>
    export type UpdateCategoryMutationError = ErrorType<void>

    export const useUpdateCategory = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateCategory>>,
        TError,
        {categoryId: string;data: BodyType<UpdateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteCategory = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteCategory200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCategoryMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{categoryId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{categoryId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategory>>, {categoryId: string}> = (props) => {
          const {categoryId} = props ?? {};

          return  deleteCategory(categoryId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategory>>>
    
    export type DeleteCategoryMutationError = ErrorType<void>

    export const useDeleteCategory = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCategory>>, TError,{categoryId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteCategory>>,
        TError,
        {categoryId: string},
        TContext
      > => {

      const mutationOptions = getDeleteCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createGroup = (
    createGroupDto: BodyType<CreateGroupDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GroupDto>(
      {url: `/api/v1/groups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createGroupDto
    },
      options);
    }
  


export const getCreateGroupMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,{data: BodyType<CreateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,{data: BodyType<CreateGroupDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGroup>>, {data: BodyType<CreateGroupDto>}> = (props) => {
          const {data} = props ?? {};

          return  createGroup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof createGroup>>>
    export type CreateGroupMutationBody = BodyType<CreateGroupDto>
    export type CreateGroupMutationError = ErrorType<void>

    export const useCreateGroup = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,{data: BodyType<CreateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createGroup>>,
        TError,
        {data: BodyType<CreateGroupDto>},
        TContext
      > => {

      const mutationOptions = getCreateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getGroupsByQuery = (
    params?: GetGroupsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroupsByQuery200AllOf>(
      {url: `/api/v1/groups`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGroupsByQueryQueryKey = (params?: GetGroupsByQueryParams,) => {
    return [`/api/v1/groups`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGroupsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQueryQueryError = ErrorType<unknown>


export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroupsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGroupsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroupsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGroupsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroupsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGroupsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetGroupQueryKey = (groupId: string,) => {
    return [`/api/v1/groups/${groupId}`] as const;
    }

    
export const getGetGroupQueryOptions = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupQueryError = ErrorType<unknown>


export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroup>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroup>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGroupQueryOptions(groupId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupSuspenseQueryError = ErrorType<unknown>


export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGroupSuspenseQueryOptions(groupId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetGroupSuspenseInfiniteQueryOptions(groupId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateGroup = (
    groupId: string,
    updateGroupDto: BodyType<UpdateGroupDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateGroupDto
    },
      options);
    }
  


export const getUpdateGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGroup>>, {groupId: string;data: BodyType<UpdateGroupDto>}> = (props) => {
          const {groupId,data} = props ?? {};

          return  updateGroup(groupId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateGroup>>>
    export type UpdateGroupMutationBody = BodyType<UpdateGroupDto>
    export type UpdateGroupMutationError = ErrorType<unknown>

    export const useUpdateGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateGroup>>,
        TError,
        {groupId: string;data: BodyType<UpdateGroupDto>},
        TContext
      > => {

      const mutationOptions = getUpdateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroup>>, {groupId: string}> = (props) => {
          const {groupId} = props ?? {};

          return  deleteGroup(groupId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroup>>>
    
    export type DeleteGroupMutationError = ErrorType<unknown>

    export const useDeleteGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroup>>,
        TError,
        {groupId: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeGroups = (
    groupIds: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveGroups200AllOf>(
      {url: `/api/v1/groups/${groupIds}`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveGroupsMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeGroups>>, {groupIds: string[]}> = (props) => {
          const {groupIds} = props ?? {};

          return  removeGroups(groupIds,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof removeGroups>>>
    
    export type RemoveGroupsMutationError = ErrorType<unknown>

    export const useRemoveGroups = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeGroups>>,
        TError,
        {groupIds: string[]},
        TContext
      > => {

      const mutationOptions = getRemoveGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSpace = (
    createSpaceDto: BodyType<CreateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateSpace200AllOf>(
      {url: `/api/v1/spaces`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSpaceDto
    },
      options);
    }
  


export const getCreateSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSpace>>, {data: BodyType<CreateSpaceDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSpace(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof createSpace>>>
    export type CreateSpaceMutationBody = BodyType<CreateSpaceDto>
    export type CreateSpaceMutationError = ErrorType<void>

    export const useCreateSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSpace>>,
        TError,
        {data: BodyType<CreateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getCreateSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSpacesByQuery = (
    params?: GetSpacesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpacesByQuery200AllOf>(
      {url: `/api/v1/spaces`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSpacesByQueryQueryKey = (params?: GetSpacesByQueryParams,) => {
    return [`/api/v1/spaces`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSpacesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpacesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQueryQueryError = ErrorType<void>


export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSpacesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpacesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseQueryError = ErrorType<void>


export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSpacesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpacesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSpacesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSpaceQueryKey = (spaceId: string,) => {
    return [`/api/v1/spaces/${spaceId}`] as const;
    }

    
export const getGetSpaceQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpaceQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceQueryError = ErrorType<void>


export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSpaceQueryOptions(spaceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpaceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseQueryError = ErrorType<void>


export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSpaceSuspenseQueryOptions(spaceId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpaceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseInfiniteQueryError = ErrorType<void>


export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSpaceSuspenseInfiniteQueryOptions(spaceId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSpace = (
    spaceId: string,
    updateSpaceDto: BodyType<UpdateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSpaceDto
    },
      options);
    }
  


export const getUpdateSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSpace>>, {spaceId: string;data: BodyType<UpdateSpaceDto>}> = (props) => {
          const {spaceId,data} = props ?? {};

          return  updateSpace(spaceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof updateSpace>>>
    export type UpdateSpaceMutationBody = BodyType<UpdateSpaceDto>
    export type UpdateSpaceMutationError = ErrorType<void>

    export const useUpdateSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSpace>>,
        TError,
        {spaceId: string;data: BodyType<UpdateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  deleteSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSpace>>>
    
    export type DeleteSpaceMutationError = ErrorType<void>

    export const useDeleteSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSpace>>,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  removeSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof removeSpace>>>
    
    export type RemoveSpaceMutationError = ErrorType<void>

    export const useRemoveSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSpace>>,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createUser = (
    createUserDto: BodyType<CreateUserDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateUser200AllOf>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto
    },
      options);
    }
  


export const getCreateUserMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: BodyType<CreateUserDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: BodyType<CreateUserDto>}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = BodyType<CreateUserDto>
    export type CreateUserMutationError = ErrorType<void>

    export const useCreateUser = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: BodyType<CreateUserDto>},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getUsersByQuery = (
    params?: GetUsersByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUsersByQuery200AllOf>(
      {url: `/api/v1/users`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUsersByQueryQueryKey = (params?: GetUsersByQueryParams,) => {
    return [`/api/v1/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQueryQueryError = ErrorType<void>


export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQuerySuspenseQueryError = ErrorType<void>


export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUsersByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = (userId: string,) => {
    return [`/api/v1/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorType<void>


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseQueryError = ErrorType<void>


export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseInfiniteQueryError = ErrorType<void>


export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUserSuspenseInfiniteQueryOptions(userId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateUser = (
    userId: string,
    updateUserDto: BodyType<UpdateUserDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserDto
    },
      options);
    }
  


export const getUpdateUserMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {userId: string;data: BodyType<UpdateUserDto>}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUser(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = BodyType<UpdateUserDto>
    export type UpdateUserMutationError = ErrorType<void>

    export const useUpdateUser = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {userId: string;data: BodyType<UpdateUserDto>},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteUserMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = ErrorType<void>

    export const useDeleteUser = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeUsers = (
    removeUsersBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveUsers200AllOf>(
      {url: `/api/v1/users/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeUsersBody
    },
      options);
    }
  


export const getRemoveUsersMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUsers>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeUsers>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUsers>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeUsers(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUsersMutationResult = NonNullable<Awaited<ReturnType<typeof removeUsers>>>
    export type RemoveUsersMutationBody = BodyType<string[]>
    export type RemoveUsersMutationError = ErrorType<void>

    export const useRemoveUsers = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUsers>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeUsers>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveUser200AllOf>(
      {url: `/api/v1/users/${userId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveUserMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError,{userId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  removeUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveUserMutationResult = NonNullable<Awaited<ReturnType<typeof removeUser>>>
    
    export type RemoveUserMutationError = ErrorType<void>

    export const useRemoveUser = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeUser>>, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeUser>>,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getRemoveUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getToken = (
    loginPayloadDto: BodyType<LoginPayloadDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GetToken200AllOf>(
      {url: `/api/v1/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginPayloadDto
    },
      options);
    }
  


export const getGetTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getToken>>, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getToken>>, TError,{data: BodyType<LoginPayloadDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getToken>>, {data: BodyType<LoginPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  getToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetTokenMutationResult = NonNullable<Awaited<ReturnType<typeof getToken>>>
    export type GetTokenMutationBody = BodyType<LoginPayloadDto>
    export type GetTokenMutationError = ErrorType<unknown>

    export const useGetToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getToken>>, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof getToken>>,
        TError,
        {data: BodyType<LoginPayloadDto>},
        TContext
      > => {

      const mutationOptions = getGetTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getNewToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenDto>(
      {url: `/api/v1/auth/new-token`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNewTokenQueryKey = () => {
    return [`/api/v1/auth/new-token`] as const;
    }

    
export const getGetNewTokenQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNewTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenQueryError = ErrorType<void>


export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNewTokenQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNewTokenSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseQueryError = ErrorType<void>


export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNewTokenSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNewTokenSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseInfiniteQueryError = ErrorType<void>


export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNewTokenSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const signUpUser = (
    signUpPayloadDto: BodyType<SignUpPayloadDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<SignUpUser201AllOf>(
      {url: `/api/v1/auth/sign-up`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signUpPayloadDto
    },
      options);
    }
  


export const getSignUpUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUpUser>>, {data: BodyType<SignUpPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  signUpUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignUpUserMutationResult = NonNullable<Awaited<ReturnType<typeof signUpUser>>>
    export type SignUpUserMutationBody = BodyType<SignUpPayloadDto>
    export type SignUpUserMutationError = ErrorType<unknown>

    export const useSignUpUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof signUpUser>>,
        TError,
        {data: BodyType<SignUpPayloadDto>},
        TContext
      > => {

      const mutationOptions = getSignUpUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createRole = (
    createRoleDto: BodyType<CreateRoleDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateRole200AllOf>(
      {url: `/api/v1/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createRoleDto
    },
      options);
    }
  


export const getCreateRoleMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: BodyType<CreateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: BodyType<CreateRoleDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRole>>, {data: BodyType<CreateRoleDto>}> = (props) => {
          const {data} = props ?? {};

          return  createRole(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createRole>>>
    export type CreateRoleMutationBody = BodyType<CreateRoleDto>
    export type CreateRoleMutationError = ErrorType<void>

    export const useCreateRole = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: BodyType<CreateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createRole>>,
        TError,
        {data: BodyType<CreateRoleDto>},
        TContext
      > => {

      const mutationOptions = getCreateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getRolesByQuery = (
    params?: GetRolesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRolesByQuery200AllOf>(
      {url: `/api/v1/roles`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRolesByQueryQueryKey = (params?: GetRolesByQueryParams,) => {
    return [`/api/v1/roles`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRolesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQueryQueryError = ErrorType<void>


export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRolesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRolesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQuerySuspenseQueryError = ErrorType<void>


export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRolesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRolesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRolesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRolesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoleQueryKey = (roleId: string,) => {
    return [`/api/v1/roles/${roleId}`] as const;
    }

    
export const getGetRoleQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleQueryError = ErrorType<void>


export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRoleQueryOptions(roleId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roleId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRoleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseQueryError = ErrorType<void>


export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRoleSuspenseQueryOptions(roleId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roleId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRoleSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseInfiniteQueryError = ErrorType<void>


export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRoleSuspenseInfiniteQueryOptions(roleId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateRole = (
    roleId: string,
    updateRoleDto: BodyType<UpdateRoleDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateRoleDto
    },
      options);
    }
  


export const getUpdateRoleMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {roleId: string;data: BodyType<UpdateRoleDto>}> = (props) => {
          const {roleId,data} = props ?? {};

          return  updateRole(roleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = BodyType<UpdateRoleDto>
    export type UpdateRoleMutationError = ErrorType<void>

    export const useUpdateRole = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateRole>>,
        TError,
        {roleId: string;data: BodyType<UpdateRoleDto>},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoleMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{roleId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  deleteRole(roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = ErrorType<void>

    export const useDeleteRole = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteRole>>,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveRole200AllOf>(
      {url: `/api/v1/roles/${roleId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveRoleMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{roleId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  removeRole(roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveRoleMutationResult = NonNullable<Awaited<ReturnType<typeof removeRole>>>
    
    export type RemoveRoleMutationError = ErrorType<void>

    export const useRemoveRole = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeRole>>, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeRole>>,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getRemoveRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAction = (
    createActionDto: BodyType<CreateActionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateAction200AllOf>(
      {url: `/api/v1/actions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createActionDto
    },
      options);
    }
  


export const getCreateActionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAction>>, TError,{data: BodyType<CreateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createAction>>, TError,{data: BodyType<CreateActionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAction>>, {data: BodyType<CreateActionDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAction(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateActionMutationResult = NonNullable<Awaited<ReturnType<typeof createAction>>>
    export type CreateActionMutationBody = BodyType<CreateActionDto>
    export type CreateActionMutationError = ErrorType<void>

    export const useCreateAction = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAction>>, TError,{data: BodyType<CreateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createAction>>,
        TError,
        {data: BodyType<CreateActionDto>},
        TContext
      > => {

      const mutationOptions = getCreateActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getActionsByQuery = (
    params?: GetActionsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetActionsByQuery200AllOf>(
      {url: `/api/v1/actions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetActionsByQueryQueryKey = (params?: GetActionsByQueryParams,) => {
    return [`/api/v1/actions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetActionsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsByQuery>>> = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActionsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsByQuery>>>
export type GetActionsByQueryQueryError = ErrorType<void>


export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetActionsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActionsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsByQuery>>> = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActionsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsByQuery>>>
export type GetActionsByQuerySuspenseQueryError = ErrorType<void>


export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetActionsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActionsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsByQuery>>> = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActionsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsByQuery>>>
export type GetActionsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetActionsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActionsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAction = (
    actionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAction200AllOf>(
      {url: `/api/v1/actions/${actionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetActionQueryKey = (actionId: string,) => {
    return [`/api/v1/actions/${actionId}`] as const;
    }

    
export const getGetActionQueryOptions = <TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(actionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActionQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionQueryError = ErrorType<void>


export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActionQueryOptions(actionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(actionId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionSuspenseQueryError = ErrorType<void>


export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActionSuspenseQueryOptions(actionId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(actionId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetActionSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionSuspenseInfiniteQueryError = ErrorType<void>


export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetActionSuspenseInfiniteQueryOptions(actionId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateAction = (
    actionId: string,
    updateActionDto: BodyType<UpdateActionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAction200AllOf>(
      {url: `/api/v1/actions/${actionId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateActionDto
    },
      options);
    }
  


export const getUpdateActionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAction>>, TError,{actionId: string;data: BodyType<UpdateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAction>>, TError,{actionId: string;data: BodyType<UpdateActionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAction>>, {actionId: string;data: BodyType<UpdateActionDto>}> = (props) => {
          const {actionId,data} = props ?? {};

          return  updateAction(actionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateActionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAction>>>
    export type UpdateActionMutationBody = BodyType<UpdateActionDto>
    export type UpdateActionMutationError = ErrorType<void>

    export const useUpdateAction = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAction>>, TError,{actionId: string;data: BodyType<UpdateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateAction>>,
        TError,
        {actionId: string;data: BodyType<UpdateActionDto>},
        TContext
      > => {

      const mutationOptions = getUpdateActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAction = (
    actionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAction200AllOf>(
      {url: `/api/v1/actions/${actionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteActionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAction>>, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAction>>, TError,{actionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAction>>, {actionId: string}> = (props) => {
          const {actionId} = props ?? {};

          return  deleteAction(actionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteActionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAction>>>
    
    export type DeleteActionMutationError = ErrorType<void>

    export const useDeleteAction = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAction>>, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAction>>,
        TError,
        {actionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeActions = (
    removeActionsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveActions200AllOf>(
      {url: `/api/v1/actions/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeActionsBody
    },
      options);
    }
  


export const getRemoveActionsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeActions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeActions>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeActions>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeActions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveActionsMutationResult = NonNullable<Awaited<ReturnType<typeof removeActions>>>
    export type RemoveActionsMutationBody = BodyType<string[]>
    export type RemoveActionsMutationError = ErrorType<void>

    export const useRemoveActions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeActions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeActions>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveActionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAction = (
    actionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAction200AllOf>(
      {url: `/api/v1/actions/${actionId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveActionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAction>>, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAction>>, TError,{actionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAction>>, {actionId: string}> = (props) => {
          const {actionId} = props ?? {};

          return  removeAction(actionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveActionMutationResult = NonNullable<Awaited<ReturnType<typeof removeAction>>>
    
    export type RemoveActionMutationError = ErrorType<void>

    export const useRemoveAction = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAction>>, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAction>>,
        TError,
        {actionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAbility = (
    createAbilityDto: BodyType<CreateAbilityDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateAbility200AllOf>(
      {url: `/api/v1/abilities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAbilityDto
    },
      options);
    }
  


export const getCreateAbilityMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAbility>>, TError,{data: BodyType<CreateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createAbility>>, TError,{data: BodyType<CreateAbilityDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAbility>>, {data: BodyType<CreateAbilityDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAbility(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof createAbility>>>
    export type CreateAbilityMutationBody = BodyType<CreateAbilityDto>
    export type CreateAbilityMutationError = ErrorType<void>

    export const useCreateAbility = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAbility>>, TError,{data: BodyType<CreateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createAbility>>,
        TError,
        {data: BodyType<CreateAbilityDto>},
        TContext
      > => {

      const mutationOptions = getCreateAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAbilitiesByQuery = (
    params?: GetAbilitiesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAbilitiesByQuery200AllOf>(
      {url: `/api/v1/abilities`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAbilitiesByQueryQueryKey = (params?: GetAbilitiesByQueryParams,) => {
    return [`/api/v1/abilities`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAbilitiesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitiesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQueryQueryError = ErrorType<void>


export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAbilitiesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbilitiesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbilitiesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAbilitiesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitiesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitiesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQuerySuspenseQueryError = ErrorType<void>


export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAbilitiesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAbilitiesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitiesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitiesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetAbilitiesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAbilitiesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAbilityQueryKey = (abilityId: string,) => {
    return [`/api/v1/abilities/${abilityId}`] as const;
    }

    
export const getGetAbilityQueryOptions = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilityQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilityQueryError = ErrorType<void>


export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbility>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbility>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAbilityQueryOptions(abilityId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilitySuspenseQueryError = ErrorType<void>


export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAbilitySuspenseQueryOptions(abilityId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilitySuspenseInfiniteQueryError = ErrorType<void>


export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAbilitySuspenseInfiniteQueryOptions(abilityId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateAbility = (
    abilityId: string,
    updateAbilityDto: BodyType<UpdateAbilityDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateAbilityDto
    },
      options);
    }
  


export const getUpdateAbilityMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAbility>>, TError,{abilityId: string;data: BodyType<UpdateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateAbility>>, TError,{abilityId: string;data: BodyType<UpdateAbilityDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAbility>>, {abilityId: string;data: BodyType<UpdateAbilityDto>}> = (props) => {
          const {abilityId,data} = props ?? {};

          return  updateAbility(abilityId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof updateAbility>>>
    export type UpdateAbilityMutationBody = BodyType<UpdateAbilityDto>
    export type UpdateAbilityMutationError = ErrorType<void>

    export const useUpdateAbility = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAbility>>, TError,{abilityId: string;data: BodyType<UpdateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateAbility>>,
        TError,
        {abilityId: string;data: BodyType<UpdateAbilityDto>},
        TContext
      > => {

      const mutationOptions = getUpdateAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAbilityMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAbility>>, TError,{abilityId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAbility>>, {abilityId: string}> = (props) => {
          const {abilityId} = props ?? {};

          return  deleteAbility(abilityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAbility>>>
    
    export type DeleteAbilityMutationError = ErrorType<void>

    export const useDeleteAbility = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAbility>>,
        TError,
        {abilityId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAbilities = (
    removeAbilitiesBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAbilities200AllOf>(
      {url: `/api/v1/abilities/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeAbilitiesBody
    },
      options);
    }
  


export const getRemoveAbilitiesMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbilities>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAbilities>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAbilities>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeAbilities(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveAbilitiesMutationResult = NonNullable<Awaited<ReturnType<typeof removeAbilities>>>
    export type RemoveAbilitiesMutationBody = BodyType<string[]>
    export type RemoveAbilitiesMutationError = ErrorType<void>

    export const useRemoveAbilities = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbilities>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAbilities>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveAbilitiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveAbilityMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAbility>>, TError,{abilityId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAbility>>, {abilityId: string}> = (props) => {
          const {abilityId} = props ?? {};

          return  removeAbility(abilityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof removeAbility>>>
    
    export type RemoveAbilityMutationError = ErrorType<void>

    export const useRemoveAbility = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAbility>>,
        TError,
        {abilityId: string},
        TContext
      > => {

      const mutationOptions = getRemoveAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSubject = (
    createSubjectDto: BodyType<CreateSubjectDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateSubject200AllOf>(
      {url: `/api/v1/subjects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSubjectDto
    },
      options);
    }
  


export const getCreateSubjectMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{data: BodyType<CreateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{data: BodyType<CreateSubjectDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubject>>, {data: BodyType<CreateSubjectDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSubject(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof createSubject>>>
    export type CreateSubjectMutationBody = BodyType<CreateSubjectDto>
    export type CreateSubjectMutationError = ErrorType<void>

    export const useCreateSubject = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{data: BodyType<CreateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSubject>>,
        TError,
        {data: BodyType<CreateSubjectDto>},
        TContext
      > => {

      const mutationOptions = getCreateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSubjectsByQuery = (
    params?: GetSubjectsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubjectsByQuery200AllOf>(
      {url: `/api/v1/subjects`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSubjectsByQueryQueryKey = (params?: GetSubjectsByQueryParams,) => {
    return [`/api/v1/subjects`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSubjectsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQueryQueryError = ErrorType<void>


export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSubjectsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubjectsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQuerySuspenseQueryError = ErrorType<void>


export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSubjectsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubjectsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetSubjectsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubjectsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubjectQueryKey = (subjectId: string,) => {
    return [`/api/v1/subjects/${subjectId}`] as const;
    }

    
export const getGetSubjectQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectQueryError = ErrorType<void>


export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubjectQueryOptions(subjectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectSuspenseQueryError = ErrorType<void>


export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubjectSuspenseQueryOptions(subjectId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectSuspenseInfiniteQueryError = ErrorType<void>


export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSubjectSuspenseInfiniteQueryOptions(subjectId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSubject = (
    subjectId: string,
    updateSubjectDto: BodyType<UpdateSubjectDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSubjectDto
    },
      options);
    }
  


export const getUpdateSubjectMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubject>>, {subjectId: string;data: BodyType<UpdateSubjectDto>}> = (props) => {
          const {subjectId,data} = props ?? {};

          return  updateSubject(subjectId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubject>>>
    export type UpdateSubjectMutationBody = BodyType<UpdateSubjectDto>
    export type UpdateSubjectMutationError = ErrorType<void>

    export const useUpdateSubject = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubject>>, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSubject>>,
        TError,
        {subjectId: string;data: BodyType<UpdateSubjectDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSubjectMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{subjectId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  deleteSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubject>>>
    
    export type DeleteSubjectMutationError = ErrorType<void>

    export const useDeleteSubject = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubject>>,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSubjects = (
    removeSubjectsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSubjects200AllOf>(
      {url: `/api/v1/subjects/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSubjectsBody
    },
      options);
    }
  


export const getRemoveSubjectsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubjects>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSubjects>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubjects>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSubjects(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSubjectsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubjects>>>
    export type RemoveSubjectsMutationBody = BodyType<string[]>
    export type RemoveSubjectsMutationError = ErrorType<void>

    export const useRemoveSubjects = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubjects>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSubjects>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSubjectMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSubject>>, TError,{subjectId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  removeSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubject>>>
    
    export type RemoveSubjectMutationError = ErrorType<void>

    export const useRemoveSubject = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubject>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSubject>>,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createTimeline = (
    createTimelineDto: BodyType<CreateTimelineDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateTimeline200AllOf>(
      {url: `/api/v1/timelines`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTimelineDto
    },
      options);
    }
  


export const getCreateTimelineMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTimeline>>, TError,{data: BodyType<CreateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTimeline>>, TError,{data: BodyType<CreateTimelineDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimeline>>, {data: BodyType<CreateTimelineDto>}> = (props) => {
          const {data} = props ?? {};

          return  createTimeline(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof createTimeline>>>
    export type CreateTimelineMutationBody = BodyType<CreateTimelineDto>
    export type CreateTimelineMutationError = ErrorType<void>

    export const useCreateTimeline = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTimeline>>, TError,{data: BodyType<CreateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createTimeline>>,
        TError,
        {data: BodyType<CreateTimelineDto>},
        TContext
      > => {

      const mutationOptions = getCreateTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getTimelinesByQuery = (
    params?: GetTimelinesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimelinesByQuery200AllOf>(
      {url: `/api/v1/timelines`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTimelinesByQueryQueryKey = (params?: GetTimelinesByQueryParams,) => {
    return [`/api/v1/timelines`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTimelinesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelinesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQueryQueryError = ErrorType<void>


export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetTimelinesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTimelinesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelinesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelinesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQuerySuspenseQueryError = ErrorType<void>


export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetTimelinesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTimelinesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelinesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelinesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetTimelinesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTimelinesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTimelineQueryKey = (timelineId: string,) => {
    return [`/api/v1/timelines/${timelineId}`] as const;
    }

    
export const getGetTimelineQueryOptions = <TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineQueryError = ErrorType<void>


export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTimelineQueryOptions(timelineId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineSuspenseQueryError = ErrorType<void>


export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTimelineSuspenseQueryOptions(timelineId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineSuspenseInfiniteQueryError = ErrorType<void>


export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTimelineSuspenseInfiniteQueryOptions(timelineId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateTimeline = (
    timelineId: string,
    updateTimelineDto: BodyType<UpdateTimelineDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTimelineDto
    },
      options);
    }
  


export const getUpdateTimelineMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTimeline>>, TError,{timelineId: string;data: BodyType<UpdateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTimeline>>, TError,{timelineId: string;data: BodyType<UpdateTimelineDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeline>>, {timelineId: string;data: BodyType<UpdateTimelineDto>}> = (props) => {
          const {timelineId,data} = props ?? {};

          return  updateTimeline(timelineId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeline>>>
    export type UpdateTimelineMutationBody = BodyType<UpdateTimelineDto>
    export type UpdateTimelineMutationError = ErrorType<void>

    export const useUpdateTimeline = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTimeline>>, TError,{timelineId: string;data: BodyType<UpdateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateTimeline>>,
        TError,
        {timelineId: string;data: BodyType<UpdateTimelineDto>},
        TContext
      > => {

      const mutationOptions = getUpdateTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTimelineMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTimeline>>, TError,{timelineId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  deleteTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeline>>>
    
    export type DeleteTimelineMutationError = ErrorType<void>

    export const useDeleteTimeline = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTimeline>>,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTimelines = (
    removeTimelinesBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimelines200AllOf>(
      {url: `/api/v1/timelines/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeTimelinesBody
    },
      options);
    }
  


export const getRemoveTimelinesMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelines>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTimelines>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimelines>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeTimelines(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTimelinesMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimelines>>>
    export type RemoveTimelinesMutationBody = BodyType<string[]>
    export type RemoveTimelinesMutationError = ErrorType<void>

    export const useRemoveTimelines = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelines>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeTimelines>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveTimelinesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveTimelineMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTimeline>>, TError,{timelineId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  removeTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimeline>>>
    
    export type RemoveTimelineMutationError = ErrorType<void>

    export const useRemoveTimeline = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimeline>>, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeTimeline>>,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSession = (
    createSessionDto: BodyType<CreateSessionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateSession200AllOf>(
      {url: `/api/v1/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSessionDto
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: BodyType<CreateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: BodyType<CreateSessionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: BodyType<CreateSessionDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = BodyType<CreateSessionDto>
    export type CreateSessionMutationError = ErrorType<void>

    export const useCreateSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: BodyType<CreateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        {data: BodyType<CreateSessionDto>},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSessionsByQuery = (
    params?: GetSessionsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSessionsByQuery200AllOf>(
      {url: `/api/v1/sessions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSessionsByQueryQueryKey = (params?: GetSessionsByQueryParams,) => {
    return [`/api/v1/sessions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSessionsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQueryQueryError = ErrorType<void>


export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSessionsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSessionsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseQueryError = ErrorType<void>


export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSessionsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSessionsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetSessionsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSessionsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionQueryKey = (sessionId: string,) => {
    return [`/api/v1/sessions/${sessionId}`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = ErrorType<void>


export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseQueryError = ErrorType<void>


export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSessionSuspenseQueryOptions(sessionId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseInfiniteQueryError = ErrorType<void>


export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }
export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey }

export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSessionSuspenseInfiniteQueryOptions(sessionId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSession = (
    sessionId: string,
    updateSessionDto: BodyType<UpdateSessionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSessionDto
    },
      options);
    }
  


export const getUpdateSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {sessionId: string;data: BodyType<UpdateSessionDto>}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateSession(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    export type UpdateSessionMutationBody = BodyType<UpdateSessionDto>
    export type UpdateSessionMutationError = ErrorType<void>

    export const useUpdateSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSession>>,
        TError,
        {sessionId: string;data: BodyType<UpdateSessionDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  deleteSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSession>>>
    
    export type DeleteSessionMutationError = ErrorType<void>

    export const useDeleteSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSessions = (
    removeSessionsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSessions200AllOf>(
      {url: `/api/v1/sessions/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSessionsBody
    },
      options);
    }
  


export const getRemoveSessionsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSessions>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSessions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSessions>>>
    export type RemoveSessionsMutationBody = BodyType<string[]>
    export type RemoveSessionsMutationError = ErrorType<void>

    export const useRemoveSessions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSessions>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSessionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  removeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof removeSession>>>
    
    export type RemoveSessionMutationError = ErrorType<void>

    export const useRemoveSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
