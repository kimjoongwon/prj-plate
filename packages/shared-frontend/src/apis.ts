/**
 * Generated by orval v6.27.1 üç∫
 * Do not edit manually.
 * PROMISE Server
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import type {
  CreateAuthzDto,
  CreateCategoryDto,
  CreateServiceDto,
  CreateSignUpPayloadDto,
  LoginPayloadDto,
  ServiceFormDto,
  UpdateAuthzDto,
  UpdateCategoryDto,
  UpdateServiceDto,
} from './model';
import { faker } from '@faker-js/faker';
import { HttpResponse, delay, http } from 'msw';
import type {
  CreateCategory200AllOf,
  GetAccessibleAllSpace200,
  GetCategories200,
  GetCategoryById200AllOf,
  Login200AllOf,
  LoginFormDto,
  MenuDto,
  ServiceEntity,
  TokenDto,
  UpdateCategory200AllOf,
  UserDto,
} from './model';
import { customInstance } from './libs/customAxios';
import type { ErrorType, BodyType } from './libs/customAxios';

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];

export const getAllService = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ServiceEntity[]>(
    {
      url: `http://localhost:3005/api/v1/admin/services`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetAllServiceQueryKey = () => {
  return [`http://localhost:3005/api/v1/admin/services`] as const;
};

export const getGetAllServiceQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllService>>,
  TError = ErrorType<ServiceEntity[]>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAllServiceQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllService>>> = ({
    signal,
  }) => getAllService(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllService>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAllServiceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllService>>
>;
export type GetAllServiceQueryError = ErrorType<ServiceEntity[]>;

export const useGetAllService = <
  TData = Awaited<ReturnType<typeof getAllService>>,
  TError = ErrorType<ServiceEntity[]>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAllServiceQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const createService = (
  createServiceDto: BodyType<CreateServiceDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ServiceEntity>(
    {
      url: `http://localhost:3005/api/v1/admin/services`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createServiceDto,
    },
    options,
  );
};

export const getCreateServiceMutationOptions = <
  TError = ErrorType<void | ServiceEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createService>>,
    TError,
    { data: BodyType<CreateServiceDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createService>>,
  TError,
  { data: BodyType<CreateServiceDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createService>>,
    { data: BodyType<CreateServiceDto> }
  > = props => {
    const { data } = props ?? {};

    return createService(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof createService>>
>;
export type CreateServiceMutationBody = BodyType<CreateServiceDto>;
export type CreateServiceMutationError = ErrorType<void | ServiceEntity>;

export const useCreateService = <
  TError = ErrorType<void | ServiceEntity>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createService>>,
    TError,
    { data: BodyType<CreateServiceDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createService>>,
  TError,
  { data: BodyType<CreateServiceDto> },
  TContext
> => {
  const mutationOptions = getCreateServiceMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getServiceForm = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ServiceFormDto>(
    {
      url: `http://localhost:3005/api/v1/admin/services/form`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetServiceFormQueryKey = () => {
  return [`http://localhost:3005/api/v1/admin/services/form`] as const;
};

export const getGetServiceFormQueryOptions = <
  TData = Awaited<ReturnType<typeof getServiceForm>>,
  TError = ErrorType<ServiceFormDto>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServiceForm>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetServiceFormQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceForm>>> = ({
    signal,
  }) => getServiceForm(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getServiceForm>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetServiceFormQueryResult = NonNullable<
  Awaited<ReturnType<typeof getServiceForm>>
>;
export type GetServiceFormQueryError = ErrorType<ServiceFormDto>;

export const useGetServiceForm = <
  TData = Awaited<ReturnType<typeof getServiceForm>>,
  TError = ErrorType<ServiceFormDto>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getServiceForm>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetServiceFormQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const updateService = (
  id: string,
  updateServiceDto: BodyType<UpdateServiceDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ServiceEntity>(
    {
      url: `http://localhost:3005/api/v1/admin/services/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateServiceDto,
    },
    options,
  );
};

export const getUpdateServiceMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateService>>,
    TError,
    { id: string; data: BodyType<UpdateServiceDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateService>>,
  TError,
  { id: string; data: BodyType<UpdateServiceDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateService>>,
    { id: string; data: BodyType<UpdateServiceDto> }
  > = props => {
    const { id, data } = props ?? {};

    return updateService(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateServiceMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateService>>
>;
export type UpdateServiceMutationBody = BodyType<UpdateServiceDto>;
export type UpdateServiceMutationError = ErrorType<unknown>;

export const useUpdateService = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateService>>,
    TError,
    { id: string; data: BodyType<UpdateServiceDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateService>>,
  TError,
  { id: string; data: BodyType<UpdateServiceDto> },
  TContext
> => {
  const mutationOptions = getUpdateServiceMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getUpdateServiceSchema = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    {
      url: `http://localhost:3005/api/v1/admin/services/schema`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetUpdateServiceSchemaQueryKey = () => {
  return [`http://localhost:3005/api/v1/admin/services/schema`] as const;
};

export const getGetUpdateServiceSchemaQueryOptions = <
  TData = Awaited<ReturnType<typeof getUpdateServiceSchema>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getUpdateServiceSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUpdateServiceSchemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUpdateServiceSchema>>
  > = ({ signal }) => getUpdateServiceSchema(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUpdateServiceSchema>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetUpdateServiceSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUpdateServiceSchema>>
>;
export type GetUpdateServiceSchemaQueryError = ErrorType<unknown>;

export const useGetUpdateServiceSchema = <
  TData = Awaited<ReturnType<typeof getUpdateServiceSchema>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getUpdateServiceSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetUpdateServiceSchemaQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getCategories = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetCategories200>(
    {
      url: `http://localhost:3005/api/v1/admin/categories`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetCategoriesQueryKey = () => {
  return [`http://localhost:3005/api/v1/admin/categories`] as const;
};

export const getGetCategoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({
    signal,
  }) => getCategories(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategories>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCategoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategories>>
>;
export type GetCategoriesQueryError = ErrorType<void>;

export const useGetCategories = <
  TData = Awaited<ReturnType<typeof getCategories>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCategoriesQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const createCategory = (
  createCategoryDto: BodyType<CreateCategoryDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<CreateCategory200AllOf>(
    {
      url: `http://localhost:3005/api/v1/admin/categories`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createCategoryDto,
    },
    options,
  );
};

export const getCreateCategoryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: BodyType<CreateCategoryDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: BodyType<CreateCategoryDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: BodyType<CreateCategoryDto> }
  > = props => {
    const { data } = props ?? {};

    return createCategory(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>;
export type CreateCategoryMutationBody = BodyType<CreateCategoryDto>;
export type CreateCategoryMutationError = ErrorType<void>;

export const useCreateCategory = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: BodyType<CreateCategoryDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: BodyType<CreateCategoryDto> },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getCategoryById = (
  categoryId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetCategoryById200AllOf>(
    {
      url: `http://localhost:3005/api/v1/admin/categories/${categoryId}`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetCategoryByIdQueryKey = (categoryId: string) => {
  return [
    `http://localhost:3005/api/v1/admin/categories/${categoryId}`,
  ] as const;
};

export const getGetCategoryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({
    signal,
  }) => getCategoryById(categoryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryById>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCategoryByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryById>>
>;
export type GetCategoryByIdQueryError = ErrorType<void>;

export const useGetCategoryById = <
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCategoryByIdQueryOptions(categoryId, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const updateCategory = (
  categoryId: string,
  updateCategoryDto: BodyType<UpdateCategoryDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateCategory200AllOf>(
    {
      url: `http://localhost:3005/api/v1/admin/categories/${categoryId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateCategoryDto,
    },
    options,
  );
};

export const getUpdateCategoryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { categoryId: string; data: BodyType<UpdateCategoryDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { categoryId: string; data: BodyType<UpdateCategoryDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { categoryId: string; data: BodyType<UpdateCategoryDto> }
  > = props => {
    const { categoryId, data } = props ?? {};

    return updateCategory(categoryId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>;
export type UpdateCategoryMutationBody = BodyType<UpdateCategoryDto>;
export type UpdateCategoryMutationError = ErrorType<void>;

export const useUpdateCategory = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { categoryId: string; data: BodyType<UpdateCategoryDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { categoryId: string; data: BodyType<UpdateCategoryDto> },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getMemus = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<MenuDto[]>(
    {
      url: `http://localhost:3005/api/v1/admin/admin/menus`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetMemusQueryKey = () => {
  return [`http://localhost:3005/api/v1/admin/admin/menus`] as const;
};

export const getGetMemusQueryOptions = <
  TData = Awaited<ReturnType<typeof getMemus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMemus>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMemusQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemus>>> = ({
    signal,
  }) => getMemus(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMemus>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetMemusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMemus>>
>;
export type GetMemusQueryError = ErrorType<unknown>;

export const useGetMemus = <
  TData = Awaited<ReturnType<typeof getMemus>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getMemus>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetMemusQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getAccessibleAllSpace = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetAccessibleAllSpace200>(
    {
      url: `http://localhost:3005/api/v1/admin/spaces/accessible`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetAccessibleAllSpaceQueryKey = () => {
  return [`http://localhost:3005/api/v1/admin/spaces/accessible`] as const;
};

export const getGetAccessibleAllSpaceQueryOptions = <
  TData = Awaited<ReturnType<typeof getAccessibleAllSpace>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAccessibleAllSpace>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAccessibleAllSpaceQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAccessibleAllSpace>>
  > = ({ signal }) => getAccessibleAllSpace(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAccessibleAllSpace>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAccessibleAllSpaceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAccessibleAllSpace>>
>;
export type GetAccessibleAllSpaceQueryError = ErrorType<unknown>;

export const useGetAccessibleAllSpace = <
  TData = Awaited<ReturnType<typeof getAccessibleAllSpace>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAccessibleAllSpace>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetAccessibleAllSpaceQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const login = (
  loginPayloadDto: BodyType<LoginPayloadDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<Login200AllOf>(
    {
      url: `http://localhost:3005/api/v1/auth/login`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginPayloadDto,
    },
    options,
  );
};

export const getLoginMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: BodyType<LoginPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: BodyType<LoginPayloadDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof login>>,
    { data: BodyType<LoginPayloadDto> }
  > = props => {
    const { data } = props ?? {};

    return login(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof login>>
>;
export type LoginMutationBody = BodyType<LoginPayloadDto>;
export type LoginMutationError = ErrorType<unknown>;

export const useLogin = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof login>>,
    TError,
    { data: BodyType<LoginPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof login>>,
  TError,
  { data: BodyType<LoginPayloadDto> },
  TContext
> => {
  const mutationOptions = getLoginMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getCurrentUser = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserDto>(
    {
      url: `http://localhost:3005/api/v1/auth/current-user`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetCurrentUserQueryKey = () => {
  return [`http://localhost:3005/api/v1/auth/current-user`] as const;
};

export const getGetCurrentUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({
    signal,
  }) => getCurrentUser(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCurrentUser>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetCurrentUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCurrentUser>>
>;
export type GetCurrentUserQueryError = ErrorType<unknown>;

export const useGetCurrentUser = <
  TData = Awaited<ReturnType<typeof getCurrentUser>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetCurrentUserQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const refreshToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TokenDto>(
    {
      url: `http://localhost:3005/api/v1/auth/refresh-token`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getRefreshTokenQueryKey = () => {
  return [`http://localhost:3005/api/v1/auth/refresh-token`] as const;
};

export const getRefreshTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof refreshToken>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof refreshToken>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRefreshTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof refreshToken>>> = ({
    signal,
  }) => refreshToken(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof refreshToken>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type RefreshTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof refreshToken>>
>;
export type RefreshTokenQueryError = ErrorType<unknown>;

export const useRefreshToken = <
  TData = Awaited<ReturnType<typeof refreshToken>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof refreshToken>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getRefreshTokenQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getLoginForm = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<LoginFormDto>(
    {
      url: `http://localhost:3005/api/v1/auth/login/form`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetLoginFormQueryKey = () => {
  return [`http://localhost:3005/api/v1/auth/login/form`] as const;
};

export const getGetLoginFormQueryOptions = <
  TData = Awaited<ReturnType<typeof getLoginForm>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLoginForm>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLoginFormQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoginForm>>> = ({
    signal,
  }) => getLoginForm(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLoginForm>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLoginFormQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLoginForm>>
>;
export type GetLoginFormQueryError = ErrorType<unknown>;

export const useGetLoginForm = <
  TData = Awaited<ReturnType<typeof getLoginForm>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getLoginForm>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetLoginFormQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const getLoginFormSchema = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `http://localhost:3005/api/v1/auth/login/schema`,
      method: 'GET',
      signal,
    },
    options,
  );
};

export const getGetLoginFormSchemaQueryKey = () => {
  return [`http://localhost:3005/api/v1/auth/login/schema`] as const;
};

export const getGetLoginFormSchemaQueryOptions = <
  TData = Awaited<ReturnType<typeof getLoginFormSchema>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLoginFormSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLoginFormSchemaQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLoginFormSchema>>
  > = ({ signal }) => getLoginFormSchema(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLoginFormSchema>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLoginFormSchemaQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLoginFormSchema>>
>;
export type GetLoginFormSchemaQueryError = ErrorType<unknown>;

export const useGetLoginFormSchema = <
  TData = Awaited<ReturnType<typeof getLoginFormSchema>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getLoginFormSchema>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetLoginFormSchemaQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const signUpUser = (
  createSignUpPayloadDto: BodyType<CreateSignUpPayloadDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    {
      url: `http://localhost:3005/api/v1/auth/sign-up`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSignUpPayloadDto,
    },
    options,
  );
};

export const getSignUpUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUpUser>>,
    TError,
    { data: BodyType<CreateSignUpPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signUpUser>>,
  TError,
  { data: BodyType<CreateSignUpPayloadDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signUpUser>>,
    { data: BodyType<CreateSignUpPayloadDto> }
  > = props => {
    const { data } = props ?? {};

    return signUpUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignUpUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof signUpUser>>
>;
export type SignUpUserMutationBody = BodyType<CreateSignUpPayloadDto>;
export type SignUpUserMutationError = ErrorType<unknown>;

export const useSignUpUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUpUser>>,
    TError,
    { data: BodyType<CreateSignUpPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof signUpUser>>,
  TError,
  { data: BodyType<CreateSignUpPayloadDto> },
  TContext
> => {
  const mutationOptions = getSignUpUserMutationOptions(options);

  return useMutation(mutationOptions);
};

export const create = (
  createAuthzDto: BodyType<CreateAuthzDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    {
      url: `http://localhost:3005/api/v1/authz`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createAuthzDto,
    },
    options,
  );
};

export const getCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof create>>,
    TError,
    { data: BodyType<CreateAuthzDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof create>>,
  TError,
  { data: BodyType<CreateAuthzDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof create>>,
    { data: BodyType<CreateAuthzDto> }
  > = props => {
    const { data } = props ?? {};

    return create(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof create>>
>;
export type CreateMutationBody = BodyType<CreateAuthzDto>;
export type CreateMutationError = ErrorType<unknown>;

export const useCreate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof create>>,
    TError,
    { data: BodyType<CreateAuthzDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof create>>,
  TError,
  { data: BodyType<CreateAuthzDto> },
  TContext
> => {
  const mutationOptions = getCreateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const findAll = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    { url: `http://localhost:3005/api/v1/authz`, method: 'GET', signal },
    options,
  );
};

export const getFindAllQueryKey = () => {
  return [`http://localhost:3005/api/v1/authz`] as const;
};

export const getFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof findAll>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof findAll>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindAllQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findAll>>> = ({
    signal,
  }) => findAll(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findAll>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type FindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof findAll>>
>;
export type FindAllQueryError = ErrorType<unknown>;

export const useFindAll = <
  TData = Awaited<ReturnType<typeof findAll>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof findAll>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindAllQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const findOne = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    { url: `http://localhost:3005/api/v1/authz/${id}`, method: 'GET', signal },
    options,
  );
};

export const getFindOneQueryKey = (id: string) => {
  return [`http://localhost:3005/api/v1/authz/${id}`] as const;
};

export const getFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof findOne>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindOneQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findOne>>> = ({
    signal,
  }) => findOne(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof findOne>>, TError, TData> & {
    queryKey: QueryKey;
  };
};

export type FindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof findOne>>
>;
export type FindOneQueryError = ErrorType<unknown>;

export const useFindOne = <
  TData = Awaited<ReturnType<typeof findOne>>,
  TError = ErrorType<unknown>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof findOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getFindOneQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
};

export const update = (
  id: string,
  updateAuthzDto: BodyType<UpdateAuthzDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    {
      url: `http://localhost:3005/api/v1/authz/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateAuthzDto,
    },
    options,
  );
};

export const getUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof update>>,
    TError,
    { id: string; data: BodyType<UpdateAuthzDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof update>>,
  TError,
  { id: string; data: BodyType<UpdateAuthzDto> },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof update>>,
    { id: string; data: BodyType<UpdateAuthzDto> }
  > = props => {
    const { id, data } = props ?? {};

    return update(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof update>>
>;
export type UpdateMutationBody = BodyType<UpdateAuthzDto>;
export type UpdateMutationError = ErrorType<unknown>;

export const useUpdate = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof update>>,
    TError,
    { id: string; data: BodyType<UpdateAuthzDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof update>>,
  TError,
  { id: string; data: BodyType<UpdateAuthzDto> },
  TContext
> => {
  const mutationOptions = getUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};

export const remove = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    { url: `http://localhost:3005/api/v1/authz/${id}`, method: 'DELETE' },
    options,
  );
};

export const getRemoveMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof remove>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof remove>>,
  TError,
  { id: string },
  TContext
> => {
  const { mutation: mutationOptions, request: requestOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof remove>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return remove(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof remove>>
>;

export type RemoveMutationError = ErrorType<unknown>;

export const useRemove = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof remove>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof remove>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRemoveMutationOptions(options);

  return useMutation(mutationOptions);
};

export const getUpdateServiceResponseMock = (
  overrideResponse: any = {},
): ServiceEntity => ({
  createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  deletedAt: {},
  id: faker.word.sample(),
  label: faker.helpers.arrayElement([faker.word.sample(), null]),
  name: faker.helpers.arrayElement(['USER', 'SPACE', 'SETTING'] as const),
  updatedAt: {},
  ...overrideResponse,
});

export const getGetCategoriesResponseMock = (
  overrideResponse: any = {},
): GetCategories200 => ({
  data: {},
  message: faker.word.sample(),
  statusCode: faker.word.sample(),
  ...overrideResponse,
  ...overrideResponse,
});

export const getCreateCategoryResponseMock = (
  overrideResponse: any = {},
): CreateCategory200AllOf => ({
  data: faker.helpers.arrayElement([
    {
      ancestorIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.word.sample()),
      createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      deletedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      id: faker.word.sample(),
      name: faker.word.sample(),
      parentId: faker.helpers.arrayElement([faker.word.sample(), null]),
      serviceId: faker.word.sample(),
      spaceId: faker.word.sample(),
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      ...overrideResponse,
    },
    undefined,
  ]),
  message: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  statusCode: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  ...overrideResponse,
});

export const getGetCategoryByIdResponseMock = (
  overrideResponse: any = {},
): GetCategoryById200AllOf => ({
  data: faker.helpers.arrayElement([
    {
      ancestorIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.word.sample()),
      createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      deletedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      id: faker.word.sample(),
      name: faker.word.sample(),
      parentId: faker.helpers.arrayElement([faker.word.sample(), null]),
      serviceId: faker.word.sample(),
      spaceId: faker.word.sample(),
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      ...overrideResponse,
    },
    undefined,
  ]),
  message: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  statusCode: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  ...overrideResponse,
});

export const getUpdateCategoryResponseMock = (
  overrideResponse: any = {},
): UpdateCategory200AllOf => ({
  data: faker.helpers.arrayElement([
    {
      ancestorIds: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.word.sample()),
      createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      deletedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      id: faker.word.sample(),
      name: faker.word.sample(),
      parentId: faker.helpers.arrayElement([faker.word.sample(), null]),
      serviceId: faker.word.sample(),
      spaceId: faker.word.sample(),
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      ...overrideResponse,
    },
    undefined,
  ]),
  message: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  statusCode: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  ...overrideResponse,
});

export const getGetMemusResponseMock = (
  overrideResponse: any = {},
): MenuDto[] =>
  Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({ ...overrideResponse }));

export const getGetAccessibleAllSpaceResponseMock = (
  overrideResponse: any = {},
): GetAccessibleAllSpace200 => ({
  data: {},
  message: faker.word.sample(),
  statusCode: faker.word.sample(),
  ...overrideResponse,
  ...overrideResponse,
});

export const getLoginResponseMock = (
  overrideResponse: any = {},
): Login200AllOf => ({
  data: faker.helpers.arrayElement([
    {
      accessToken: faker.word.sample(),
      refreshToken: faker.word.sample(),
      user: {
        createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
        deletedAt: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split('.')[0]}Z`,
          null,
        ]),
        email: faker.word.sample(),
        id: faker.word.sample(),
        name: faker.word.sample(),
        password: faker.word.sample(),
        phone: faker.word.sample(),
        profiles: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
          deletedAt: faker.helpers.arrayElement([
            `${faker.date.past().toISOString().split('.')[0]}Z`,
            null,
          ]),
          id: faker.word.sample(),
          nickname: faker.word.sample(),
          updatedAt: faker.helpers.arrayElement([
            `${faker.date.past().toISOString().split('.')[0]}Z`,
            null,
          ]),
          userId: faker.word.sample(),
          ...overrideResponse,
        })),
        tenants: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => ({
          createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
          deletedAt: faker.helpers.arrayElement([
            `${faker.date.past().toISOString().split('.')[0]}Z`,
            null,
          ]),
          id: faker.word.sample(),
          roleId: faker.word.sample(),
          spaceId: faker.word.sample(),
          updatedAt: faker.helpers.arrayElement([
            `${faker.date.past().toISOString().split('.')[0]}Z`,
            null,
          ]),
          userId: faker.word.sample(),
          ...overrideResponse,
        })),
        updatedAt: faker.helpers.arrayElement([
          `${faker.date.past().toISOString().split('.')[0]}Z`,
          null,
        ]),
        ...overrideResponse,
      },
      ...overrideResponse,
    },
    undefined,
  ]),
  message: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  statusCode: faker.helpers.arrayElement([faker.word.sample(), undefined]),
  ...overrideResponse,
});

export const getGetCurrentUserResponseMock = (
  overrideResponse: any = {},
): UserDto => ({
  createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
  deletedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split('.')[0]}Z`,
    null,
  ]),
  email: faker.word.sample(),
  id: faker.word.sample(),
  name: faker.word.sample(),
  password: faker.word.sample(),
  phone: faker.word.sample(),
  profiles: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    deletedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    id: faker.word.sample(),
    nickname: faker.word.sample(),
    updatedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    userId: faker.word.sample(),
    ...overrideResponse,
  })),
  tenants: Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    deletedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    id: faker.word.sample(),
    roleId: faker.word.sample(),
    spaceId: faker.word.sample(),
    updatedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    userId: faker.word.sample(),
    ...overrideResponse,
  })),
  updatedAt: faker.helpers.arrayElement([
    `${faker.date.past().toISOString().split('.')[0]}Z`,
    null,
  ]),
  ...overrideResponse,
});

export const getRefreshTokenResponseMock = (
  overrideResponse: any = {},
): TokenDto => ({
  accessToken: faker.word.sample(),
  refreshToken: faker.word.sample(),
  user: {
    createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
    deletedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    email: faker.word.sample(),
    id: faker.word.sample(),
    name: faker.word.sample(),
    password: faker.word.sample(),
    phone: faker.word.sample(),
    profiles: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      deletedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      id: faker.word.sample(),
      nickname: faker.word.sample(),
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      userId: faker.word.sample(),
      ...overrideResponse,
    })),
    tenants: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`,
      deletedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      id: faker.word.sample(),
      roleId: faker.word.sample(),
      spaceId: faker.word.sample(),
      updatedAt: faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      userId: faker.word.sample(),
      ...overrideResponse,
    })),
    updatedAt: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    ...overrideResponse,
  },
  ...overrideResponse,
});

export const getGetLoginFormResponseMock = (
  overrideResponse: any = {},
): LoginFormDto => ({ ...overrideResponse });

export const getGetAllServiceMockHandler = () => {
  return http.get('*/api/v1/admin/services', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getCreateServiceMockHandler = () => {
  return http.post('*/api/v1/admin/services', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getGetServiceFormMockHandler = () => {
  return http.get('*/api/v1/admin/services/form', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getUpdateServiceMockHandler = (
  overrideResponse?: ServiceEntity,
) => {
  return http.patch('*/api/v1/admin/services/:id', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getUpdateServiceResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetUpdateServiceSchemaMockHandler = () => {
  return http.get('*/api/v1/admin/services/schema', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getGetCategoriesMockHandler = (
  overrideResponse?: GetCategories200,
) => {
  return http.get('*/api/v1/admin/categories', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getGetCategoriesResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getCreateCategoryMockHandler = (
  overrideResponse?: CreateCategory200AllOf,
) => {
  return http.post('*/api/v1/admin/categories', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getCreateCategoryResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetCategoryByIdMockHandler = (
  overrideResponse?: GetCategoryById200AllOf,
) => {
  return http.get('*/api/v1/admin/categories/:categoryId', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getGetCategoryByIdResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getUpdateCategoryMockHandler = (
  overrideResponse?: UpdateCategory200AllOf,
) => {
  return http.patch('*/api/v1/admin/categories/:categoryId', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getUpdateCategoryResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetMemusMockHandler = (overrideResponse?: MenuDto[]) => {
  return http.get('*/api/v1/admin/admin/menus', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getGetMemusResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetAccessibleAllSpaceMockHandler = (
  overrideResponse?: GetAccessibleAllSpace200,
) => {
  return http.get('*/api/v1/admin/spaces/accessible', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse
          ? overrideResponse
          : getGetAccessibleAllSpaceResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getLoginMockHandler = (overrideResponse?: Login200AllOf) => {
  return http.post('*/api/v1/auth/login', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getLoginResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetCurrentUserMockHandler = (overrideResponse?: UserDto) => {
  return http.get('*/api/v1/auth/current-user', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getGetCurrentUserResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getRefreshTokenMockHandler = (overrideResponse?: TokenDto) => {
  return http.get('*/api/v1/auth/refresh-token', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getRefreshTokenResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetLoginFormMockHandler = (overrideResponse?: LoginFormDto) => {
  return http.get('*/api/v1/auth/login/form', async () => {
    await delay(1000);
    return new HttpResponse(
      JSON.stringify(
        overrideResponse ? overrideResponse : getGetLoginFormResponseMock(),
      ),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
  });
};

export const getGetLoginFormSchemaMockHandler = () => {
  return http.get('*/api/v1/auth/login/schema', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getSignUpUserMockHandler = () => {
  return http.post('*/api/v1/auth/sign-up', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getCreateMockHandler = () => {
  return http.post('*/api/v1/authz', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getFindAllMockHandler = () => {
  return http.get('*/api/v1/authz', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getFindOneMockHandler = () => {
  return http.get('*/api/v1/authz/:id', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getUpdateMockHandler = () => {
  return http.patch('*/api/v1/authz/:id', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};

export const getRemoveMockHandler = () => {
  return http.delete('*/api/v1/authz/:id', async () => {
    await delay(1000);
    return new HttpResponse(null, {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
      },
    });
  });
};
export const getPROMISEServerMock = () => [
  getGetAllServiceMockHandler(),
  getCreateServiceMockHandler(),
  getGetServiceFormMockHandler(),
  getUpdateServiceMockHandler(),
  getGetUpdateServiceSchemaMockHandler(),
  getGetCategoriesMockHandler(),
  getCreateCategoryMockHandler(),
  getGetCategoryByIdMockHandler(),
  getUpdateCategoryMockHandler(),
  getGetMemusMockHandler(),
  getGetAccessibleAllSpaceMockHandler(),
  getLoginMockHandler(),
  getGetCurrentUserMockHandler(),
  getRefreshTokenMockHandler(),
  getGetLoginFormMockHandler(),
  getGetLoginFormSchemaMockHandler(),
  getSignUpUserMockHandler(),
  getCreateMockHandler(),
  getFindAllMockHandler(),
  getFindOneMockHandler(),
  getUpdateMockHandler(),
  getRemoveMockHandler(),
];
