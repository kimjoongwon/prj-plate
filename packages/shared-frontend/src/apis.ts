/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * PROMISE Server
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  CreateAbilityDto,
  CreateCategoryDto,
  CreateGroupDto,
  CreateServiceDto,
  CreateSessionDto,
  CreateSpaceDto,
  CreateSubjectDto,
  CreateTimelineItemDto,
  GetAbilitiesByQueryParams,
  GetGroupsByQueryParams,
  GetSessionsByQueryParams,
  GetSpacesByQueryParams,
  GetTimelineItemsByQueryParams,
  LoginPayloadDto,
  RemoveManySpaceDto,
  SignUpPayloadDto,
  UpdateCategoryDto,
  UpdateGroupDto,
  UpdateServiceDto,
  UpdateSessionDto,
  UpdateSpaceDto,
  UpdateSubjectDto,
  UpdateTimelineItemDto
} from './model'
import {
  faker
} from '@faker-js/faker'
import {
  HttpResponse,
  delay,
  http
} from 'msw'
import {
  AbilityActions,
  AbilityTypes,
  RecurringDayOfTheWeek,
  RepeatCycleTypes,
  ReservationStatus,
  Roles,
  ServiceName,
  SessionTypes,
  TenantTypes
} from './model'
import type {
  CreateAbility201AllOf,
  CreateCategory200AllOf,
  CreateService201AllOf,
  CreateSession200AllOf,
  CreateSpace200AllOf,
  CreateTimelineItem200AllOf,
  DeleteAbility200AllOf,
  DeleteGroup200AllOf,
  DeleteService200AllOf,
  DeleteSession200AllOf,
  DeleteSpace200AllOf,
  DeleteTimelineItem200AllOf,
  FindCategoryById200AllOf,
  GetAbilitiesByQuery200AllOf,
  GetAbility200AllOf,
  GetAccessibleSpaces200AllOf,
  GetAllService200AllOf,
  GetCategories200AllOf,
  GetGroup200AllOf,
  GetGroupsByQuery200AllOf,
  GetService200AllOf,
  GetSession200AllOf,
  GetSessionsByQuery200AllOf,
  GetSpace200AllOf,
  GetSpacesByQuery200AllOf,
  GetSubjectById200AllOf,
  GetSubjectsByPageQuery200AllOf,
  GetTimelineItem200AllOf,
  GetTimelineItemsByQuery200AllOf,
  GetToken200AllOf,
  GroupDto,
  RemoveAbilities200AllOf,
  RemoveAbility200AllOf,
  RemoveGroups200AllOf,
  RemoveService200AllOf,
  RemoveServices200AllOf,
  RemoveSession200AllOf,
  RemoveSessions200AllOf,
  RemoveSpace200AllOf,
  RemoveSpaces200AllOf,
  RemoveTimelineItem200AllOf,
  RemoveTimelineItems200AllOf,
  TokenDto,
  UpdateCategory200AllOf,
  UpdateGroup200AllOf,
  UpdateService200AllOf,
  UpdateSession200AllOf,
  UpdateSpace200AllOf,
  UpdateSubjectById200AllOf,
  UpdateTimelineItem200AllOf,
  UserDto
} from './model'
import { customInstance } from './libs/customAxios';
import type { ErrorType, BodyType } from './libs/customAxios';



type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


export const createTimelineItem = (
    createTimelineItemDto: BodyType<CreateTimelineItemDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateTimelineItem200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTimelineItemDto
    },
      options);
    }
  


export const getCreateTimelineItemMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTimelineItem>>, TError,{data: BodyType<CreateTimelineItemDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createTimelineItem>>, TError,{data: BodyType<CreateTimelineItemDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimelineItem>>, {data: BodyType<CreateTimelineItemDto>}> = (props) => {
          const {data} = props ?? {};

          return  createTimelineItem(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTimelineItemMutationResult = NonNullable<Awaited<ReturnType<typeof createTimelineItem>>>
    export type CreateTimelineItemMutationBody = BodyType<CreateTimelineItemDto>
    export type CreateTimelineItemMutationError = ErrorType<void>

    export const useCreateTimelineItem = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTimelineItem>>, TError,{data: BodyType<CreateTimelineItemDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createTimelineItem>>,
        TError,
        {data: BodyType<CreateTimelineItemDto>},
        TContext
      > => {

      const mutationOptions = getCreateTimelineItemMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getTimelineItemsByQuery = (
    params?: GetTimelineItemsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimelineItemsByQuery200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTimelineItemsByQueryQueryKey = (params?: GetTimelineItemsByQueryParams,) => {
    return [`http://localhost:3005/api/v1/admin/timeline-items`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTimelineItemsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError = ErrorType<void>>(params?: GetTimelineItemsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineItemsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineItemsByQuery>>> = ({ signal }) => getTimelineItemsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineItemsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineItemsByQuery>>>
export type GetTimelineItemsByQueryQueryError = ErrorType<void>

export const useGetTimelineItemsByQuery = <TData = Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelineItemsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTimelineItemsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineItemsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError = ErrorType<void>>(params?: GetTimelineItemsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineItemsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineItemsByQuery>>> = ({ signal }) => getTimelineItemsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineItemsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineItemsByQuery>>>
export type GetTimelineItemsByQuerySuspenseQueryError = ErrorType<void>

export const useGetTimelineItemsByQuerySuspense = <TData = Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelineItemsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTimelineItemsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineItemsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelineItemsByQuery>>>, TError = ErrorType<void>>(params?: GetTimelineItemsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineItemsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineItemsByQuery>>> = ({ signal }) => getTimelineItemsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineItemsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineItemsByQuery>>>
export type GetTimelineItemsByQuerySuspenseInfiniteQueryError = ErrorType<void>

export const useGetTimelineItemsByQuerySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelineItemsByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelineItemsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelineItemsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTimelineItemsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTimelineItem = (
    timelineItemId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimelineItem200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items/${timelineItemId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTimelineItemQueryKey = (timelineItemId: string,) => {
    return [`http://localhost:3005/api/v1/admin/timeline-items/${timelineItemId}`] as const;
    }

    
export const getGetTimelineItemQueryOptions = <TData = Awaited<ReturnType<typeof getTimelineItem>>, TError = ErrorType<void>>(timelineItemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineItemQueryKey(timelineItemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineItem>>> = ({ signal }) => getTimelineItem(timelineItemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineItemId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineItemQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineItem>>>
export type GetTimelineItemQueryError = ErrorType<void>

export const useGetTimelineItem = <TData = Awaited<ReturnType<typeof getTimelineItem>>, TError = ErrorType<void>>(
 timelineItemId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTimelineItemQueryOptions(timelineItemId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineItemSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimelineItem>>, TError = ErrorType<void>>(timelineItemId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineItemQueryKey(timelineItemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineItem>>> = ({ signal }) => getTimelineItem(timelineItemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineItemId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineItemSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineItem>>>
export type GetTimelineItemSuspenseQueryError = ErrorType<void>

export const useGetTimelineItemSuspense = <TData = Awaited<ReturnType<typeof getTimelineItem>>, TError = ErrorType<void>>(
 timelineItemId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTimelineItemSuspenseQueryOptions(timelineItemId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineItemSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelineItem>>>, TError = ErrorType<void>>(timelineItemId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineItemQueryKey(timelineItemId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelineItem>>> = ({ signal }) => getTimelineItem(timelineItemId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineItemId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTimelineItemSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelineItem>>>
export type GetTimelineItemSuspenseInfiniteQueryError = ErrorType<void>

export const useGetTimelineItemSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelineItem>>>, TError = ErrorType<void>>(
 timelineItemId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelineItem>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetTimelineItemSuspenseInfiniteQueryOptions(timelineItemId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateTimelineItem = (
    timelineItemId: string,
    updateTimelineItemDto: BodyType<UpdateTimelineItemDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateTimelineItem200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items/${timelineItemId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTimelineItemDto
    },
      options);
    }
  


export const getUpdateTimelineItemMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTimelineItem>>, TError,{timelineItemId: string;data: BodyType<UpdateTimelineItemDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTimelineItem>>, TError,{timelineItemId: string;data: BodyType<UpdateTimelineItemDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimelineItem>>, {timelineItemId: string;data: BodyType<UpdateTimelineItemDto>}> = (props) => {
          const {timelineItemId,data} = props ?? {};

          return  updateTimelineItem(timelineItemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTimelineItemMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimelineItem>>>
    export type UpdateTimelineItemMutationBody = BodyType<UpdateTimelineItemDto>
    export type UpdateTimelineItemMutationError = ErrorType<void>

    export const useUpdateTimelineItem = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTimelineItem>>, TError,{timelineItemId: string;data: BodyType<UpdateTimelineItemDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateTimelineItem>>,
        TError,
        {timelineItemId: string;data: BodyType<UpdateTimelineItemDto>},
        TContext
      > => {

      const mutationOptions = getUpdateTimelineItemMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteTimelineItem = (
    timelineItemId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteTimelineItem200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items/${timelineItemId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTimelineItemMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTimelineItem>>, TError,{timelineItemId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTimelineItem>>, TError,{timelineItemId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimelineItem>>, {timelineItemId: string}> = (props) => {
          const {timelineItemId} = props ?? {};

          return  deleteTimelineItem(timelineItemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTimelineItemMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimelineItem>>>
    
    export type DeleteTimelineItemMutationError = ErrorType<void>

    export const useDeleteTimelineItem = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTimelineItem>>, TError,{timelineItemId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteTimelineItem>>,
        TError,
        {timelineItemId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTimelineItemMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTimelineItems = (
    removeTimelineItemsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimelineItems200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeTimelineItemsBody
    },
      options);
    }
  


export const getRemoveTimelineItemsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelineItems>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTimelineItems>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimelineItems>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeTimelineItems(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTimelineItemsMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimelineItems>>>
    export type RemoveTimelineItemsMutationBody = BodyType<string[]>
    export type RemoveTimelineItemsMutationError = ErrorType<void>

    export const useRemoveTimelineItems = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelineItems>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeTimelineItems>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveTimelineItemsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTimelineItem = (
    timelineItemId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimelineItem200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/timeline-items/${timelineItemId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveTimelineItemMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelineItem>>, TError,{timelineItemId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeTimelineItem>>, TError,{timelineItemId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimelineItem>>, {timelineItemId: string}> = (props) => {
          const {timelineItemId} = props ?? {};

          return  removeTimelineItem(timelineItemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveTimelineItemMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimelineItem>>>
    
    export type RemoveTimelineItemMutationError = ErrorType<void>

    export const useRemoveTimelineItem = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeTimelineItem>>, TError,{timelineItemId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeTimelineItem>>,
        TError,
        {timelineItemId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTimelineItemMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAbility = (
    createAbilityDto: BodyType<CreateAbilityDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateAbility201AllOf>(
      {url: `http://localhost:3005/api/v1/admin/abilities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAbilityDto
    },
      options);
    }
  


export const getCreateAbilityMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAbility>>, TError,{data: BodyType<CreateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createAbility>>, TError,{data: BodyType<CreateAbilityDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAbility>>, {data: BodyType<CreateAbilityDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAbility(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof createAbility>>>
    export type CreateAbilityMutationBody = BodyType<CreateAbilityDto>
    export type CreateAbilityMutationError = ErrorType<unknown>

    export const useCreateAbility = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAbility>>, TError,{data: BodyType<CreateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createAbility>>,
        TError,
        {data: BodyType<CreateAbilityDto>},
        TContext
      > => {

      const mutationOptions = getCreateAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAbilitiesByQuery = (
    params?: GetAbilitiesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAbilitiesByQuery200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/abilities`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAbilitiesByQueryQueryKey = (params?: GetAbilitiesByQueryParams,) => {
    return [`http://localhost:3005/api/v1/admin/abilities`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAbilitiesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<unknown>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitiesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQueryQueryError = ErrorType<unknown>

export const useGetAbilitiesByQuery = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAbilitiesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitiesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<unknown>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitiesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQuerySuspenseQueryError = ErrorType<unknown>

export const useGetAbilitiesByQuerySuspense = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<unknown>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAbilitiesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitiesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<unknown>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitiesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQuerySuspenseInfiniteQueryError = ErrorType<unknown>

export const useGetAbilitiesByQuerySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAbilitiesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAbility200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/abilities/${abilityId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAbilityQueryKey = (abilityId: string,) => {
    return [`http://localhost:3005/api/v1/admin/abilities/${abilityId}`] as const;
    }

    
export const getGetAbilityQueryOptions = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<unknown>>(abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilityQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilityQueryError = ErrorType<unknown>

export const useGetAbility = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<unknown>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAbilityQueryOptions(abilityId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<unknown>>(abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilitySuspenseQueryError = ErrorType<unknown>

export const useGetAbilitySuspense = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<unknown>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAbilitySuspenseQueryOptions(abilityId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<unknown>>(abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAbilitySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilitySuspenseInfiniteQueryError = ErrorType<unknown>

export const useGetAbilitySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<unknown>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAbilitySuspenseInfiniteQueryOptions(abilityId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const removeAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAbility200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/abilities/${abilityId}`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveAbilityMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAbility>>, TError,{abilityId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAbility>>, {abilityId: string}> = (props) => {
          const {abilityId} = props ?? {};

          return  removeAbility(abilityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof removeAbility>>>
    
    export type RemoveAbilityMutationError = ErrorType<unknown>

    export const useRemoveAbility = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAbility>>,
        TError,
        {abilityId: string},
        TContext
      > => {

      const mutationOptions = getRemoveAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAbility200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/abilities/${abilityId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAbilityMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAbility>>, TError,{abilityId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAbility>>, {abilityId: string}> = (props) => {
          const {abilityId} = props ?? {};

          return  deleteAbility(abilityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAbility>>>
    
    export type DeleteAbilityMutationError = ErrorType<unknown>

    export const useDeleteAbility = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAbility>>, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteAbility>>,
        TError,
        {abilityId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAbilities = (
    abilityIds: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAbilities200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/abilities/${abilityIds}`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveAbilitiesMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbilities>>, TError,{abilityIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeAbilities>>, TError,{abilityIds: string[]}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAbilities>>, {abilityIds: string[]}> = (props) => {
          const {abilityIds} = props ?? {};

          return  removeAbilities(abilityIds,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveAbilitiesMutationResult = NonNullable<Awaited<ReturnType<typeof removeAbilities>>>
    
    export type RemoveAbilitiesMutationError = ErrorType<unknown>

    export const useRemoveAbilities = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeAbilities>>, TError,{abilityIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeAbilities>>,
        TError,
        {abilityIds: string[]},
        TContext
      > => {

      const mutationOptions = getRemoveAbilitiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getCategories = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategories200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/categories`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoriesQueryKey = () => {
    return [`http://localhost:3005/api/v1/admin/categories`] as const;
    }

    
export const getGetCategoriesQueryOptions = <TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoriesQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>
export type GetCategoriesQueryError = ErrorType<void>

export const useGetCategories = <TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCategoriesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoriesSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>
export type GetCategoriesSuspenseQueryError = ErrorType<void>

export const useGetCategoriesSuspense = <TData = Awaited<ReturnType<typeof getCategories>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCategoriesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategories>>> = ({ signal }) => getCategories(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCategoriesSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategories>>>
export type GetCategoriesSuspenseInfiniteQueryError = ErrorType<void>

export const useGetCategoriesSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCategories>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategories>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCategoriesSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createCategory = (
    createCategoryDto: BodyType<CreateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateCategory200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/categories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCategoryDto
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: BodyType<CreateCategoryDto>}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = BodyType<CreateCategoryDto>
    export type CreateCategoryMutationError = ErrorType<void>

    export const useCreateCategory = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCategory>>, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createCategory>>,
        TError,
        {data: BodyType<CreateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const findCategoryById = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<FindCategoryById200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/categories/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getFindCategoryByIdQueryKey = (categoryId: string,) => {
    return [`http://localhost:3005/api/v1/admin/categories/${categoryId}`] as const;
    }

    
export const getFindCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof findCategoryById>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCategoryById>>> = ({ signal }) => findCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData> & { queryKey: QueryKey }
}

export type FindCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof findCategoryById>>>
export type FindCategoryByIdQueryError = ErrorType<void>

export const useFindCategoryById = <TData = Awaited<ReturnType<typeof findCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFindCategoryByIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getFindCategoryByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof findCategoryById>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCategoryById>>> = ({ signal }) => findCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData> & { queryKey: QueryKey }
}

export type FindCategoryByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof findCategoryById>>>
export type FindCategoryByIdSuspenseQueryError = ErrorType<void>

export const useFindCategoryByIdSuspense = <TData = Awaited<ReturnType<typeof findCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFindCategoryByIdSuspenseQueryOptions(categoryId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getFindCategoryByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof findCategoryById>>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findCategoryById>>> = ({ signal }) => findCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData> & { queryKey: QueryKey }
}

export type FindCategoryByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof findCategoryById>>>
export type FindCategoryByIdSuspenseInfiniteQueryError = ErrorType<void>

export const useFindCategoryByIdSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof findCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof findCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFindCategoryByIdSuspenseInfiniteQueryOptions(categoryId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateCategory = (
    categoryId: string,
    updateCategoryDto: BodyType<UpdateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateCategory200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/categories/${categoryId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateCategoryDto
    },
      options);
    }
  


export const getUpdateCategoryMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, {categoryId: string;data: BodyType<UpdateCategoryDto>}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategory(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
    export type UpdateCategoryMutationBody = BodyType<UpdateCategoryDto>
    export type UpdateCategoryMutationError = ErrorType<void>

    export const useUpdateCategory = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCategory>>, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateCategory>>,
        TError,
        {categoryId: string;data: BodyType<UpdateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAllService = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAllService200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAllServiceQueryKey = () => {
    return [`http://localhost:3005/api/v1/admin/services`] as const;
    }

    
export const getGetAllServiceQueryOptions = <TData = Awaited<ReturnType<typeof getAllService>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllServiceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllService>>> = ({ signal }) => getAllService(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllServiceQueryResult = NonNullable<Awaited<ReturnType<typeof getAllService>>>
export type GetAllServiceQueryError = ErrorType<void>

export const useGetAllService = <TData = Awaited<ReturnType<typeof getAllService>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAllServiceQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllServiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAllService>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllServiceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllService>>> = ({ signal }) => getAllService(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllServiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAllService>>>
export type GetAllServiceSuspenseQueryError = ErrorType<void>

export const useGetAllServiceSuspense = <TData = Awaited<ReturnType<typeof getAllService>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAllServiceSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAllServiceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAllService>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllServiceQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllService>>> = ({ signal }) => getAllService(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAllServiceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAllService>>>
export type GetAllServiceSuspenseInfiniteQueryError = ErrorType<void>

export const useGetAllServiceSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAllService>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAllService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAllServiceSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createService = (
    createServiceDto: BodyType<CreateServiceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateService201AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createServiceDto
    },
      options);
    }
  


export const getCreateServiceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: BodyType<CreateServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: BodyType<CreateServiceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createService>>, {data: BodyType<CreateServiceDto>}> = (props) => {
          const {data} = props ?? {};

          return  createService(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof createService>>>
    export type CreateServiceMutationBody = BodyType<CreateServiceDto>
    export type CreateServiceMutationError = ErrorType<void>

    export const useCreateService = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: BodyType<CreateServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createService>>,
        TError,
        {data: BodyType<CreateServiceDto>},
        TContext
      > => {

      const mutationOptions = getCreateServiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getService = (
    serviceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetService200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services/${serviceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetServiceQueryKey = (serviceId: string,) => {
    return [`http://localhost:3005/api/v1/admin/services/${serviceId}`] as const;
    }

    
export const getGetServiceQueryOptions = <TData = Awaited<ReturnType<typeof getService>>, TError = ErrorType<void>>(serviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceQueryKey(serviceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getService>>> = ({ signal }) => getService(serviceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData> & { queryKey: QueryKey }
}

export type GetServiceQueryResult = NonNullable<Awaited<ReturnType<typeof getService>>>
export type GetServiceQueryError = ErrorType<void>

export const useGetService = <TData = Awaited<ReturnType<typeof getService>>, TError = ErrorType<void>>(
 serviceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetServiceQueryOptions(serviceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getService>>, TError = ErrorType<void>>(serviceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceQueryKey(serviceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getService>>> = ({ signal }) => getService(serviceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData> & { queryKey: QueryKey }
}

export type GetServiceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getService>>>
export type GetServiceSuspenseQueryError = ErrorType<void>

export const useGetServiceSuspense = <TData = Awaited<ReturnType<typeof getService>>, TError = ErrorType<void>>(
 serviceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetServiceSuspenseQueryOptions(serviceId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetServiceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getService>>>, TError = ErrorType<void>>(serviceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceQueryKey(serviceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getService>>> = ({ signal }) => getService(serviceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(serviceId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData> & { queryKey: QueryKey }
}

export type GetServiceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getService>>>
export type GetServiceSuspenseInfiniteQueryError = ErrorType<void>

export const useGetServiceSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getService>>>, TError = ErrorType<void>>(
 serviceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getService>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetServiceSuspenseInfiniteQueryOptions(serviceId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateService = (
    serviceId: string,
    updateServiceDto: BodyType<UpdateServiceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateService200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services/${serviceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateServiceDto
    },
      options);
    }
  


export const getUpdateServiceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{serviceId: string;data: BodyType<UpdateServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{serviceId: string;data: BodyType<UpdateServiceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateService>>, {serviceId: string;data: BodyType<UpdateServiceDto>}> = (props) => {
          const {serviceId,data} = props ?? {};

          return  updateService(serviceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateService>>>
    export type UpdateServiceMutationBody = BodyType<UpdateServiceDto>
    export type UpdateServiceMutationError = ErrorType<void>

    export const useUpdateService = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{serviceId: string;data: BodyType<UpdateServiceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateService>>,
        TError,
        {serviceId: string;data: BodyType<UpdateServiceDto>},
        TContext
      > => {

      const mutationOptions = getUpdateServiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteService = (
    serviceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteService200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services/${serviceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteServiceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{serviceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{serviceId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteService>>, {serviceId: string}> = (props) => {
          const {serviceId} = props ?? {};

          return  deleteService(serviceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteService>>>
    
    export type DeleteServiceMutationError = ErrorType<void>

    export const useDeleteService = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{serviceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteService>>,
        TError,
        {serviceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeService = (
    serviceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveService200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services/${serviceId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveServiceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeService>>, TError,{serviceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeService>>, TError,{serviceId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeService>>, {serviceId: string}> = (props) => {
          const {serviceId} = props ?? {};

          return  removeService(serviceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveServiceMutationResult = NonNullable<Awaited<ReturnType<typeof removeService>>>
    
    export type RemoveServiceMutationError = ErrorType<void>

    export const useRemoveService = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeService>>, TError,{serviceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeService>>,
        TError,
        {serviceId: string},
        TContext
      > => {

      const mutationOptions = getRemoveServiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeServices = (
    serviceIds: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveServices200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/services/${serviceIds}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveServicesMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeServices>>, TError,{serviceIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeServices>>, TError,{serviceIds: string[]}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeServices>>, {serviceIds: string[]}> = (props) => {
          const {serviceIds} = props ?? {};

          return  removeServices(serviceIds,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveServicesMutationResult = NonNullable<Awaited<ReturnType<typeof removeServices>>>
    
    export type RemoveServicesMutationError = ErrorType<void>

    export const useRemoveServices = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeServices>>, TError,{serviceIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeServices>>,
        TError,
        {serviceIds: string[]},
        TContext
      > => {

      const mutationOptions = getRemoveServicesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSpace = (
    createSpaceDto: BodyType<CreateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateSpace200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSpaceDto
    },
      options);
    }
  


export const getCreateSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSpace>>, {data: BodyType<CreateSpaceDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSpace(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof createSpace>>>
    export type CreateSpaceMutationBody = BodyType<CreateSpaceDto>
    export type CreateSpaceMutationError = ErrorType<void>

    export const useCreateSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSpace>>, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSpace>>,
        TError,
        {data: BodyType<CreateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getCreateSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSpacesByQuery = (
    params?: GetSpacesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpacesByQuery200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSpacesByQueryQueryKey = (params?: GetSpacesByQueryParams,) => {
    return [`http://localhost:3005/api/v1/admin/spaces`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSpacesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpacesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQueryQueryError = ErrorType<void>

export const useGetSpacesByQuery = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpacesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpacesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseQueryError = ErrorType<void>

export const useGetSpacesByQuerySuspense = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpacesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpacesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseInfiniteQueryError = ErrorType<void>

export const useGetSpacesByQuerySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpacesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpace200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces/${spaceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSpaceQueryKey = (spaceId: string,) => {
    return [`http://localhost:3005/api/v1/admin/spaces/${spaceId}`] as const;
    }

    
export const getGetSpaceQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpaceQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceQueryError = ErrorType<void>

export const useGetSpace = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpaceQueryOptions(spaceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpaceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseQueryError = ErrorType<void>

export const useGetSpaceSuspense = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpaceSuspenseQueryOptions(spaceId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSpaceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseInfiniteQueryError = ErrorType<void>

export const useGetSpaceSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSpaceSuspenseInfiniteQueryOptions(spaceId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSpace = (
    spaceId: string,
    updateSpaceDto: BodyType<UpdateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSpace200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces/${spaceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSpaceDto
    },
      options);
    }
  


export const getUpdateSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSpace>>, {spaceId: string;data: BodyType<UpdateSpaceDto>}> = (props) => {
          const {spaceId,data} = props ?? {};

          return  updateSpace(spaceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof updateSpace>>>
    export type UpdateSpaceMutationBody = BodyType<UpdateSpaceDto>
    export type UpdateSpaceMutationError = ErrorType<void>

    export const useUpdateSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSpace>>, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSpace>>,
        TError,
        {spaceId: string;data: BodyType<UpdateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSpace200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces/${spaceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  deleteSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSpace>>>
    
    export type DeleteSpaceMutationError = ErrorType<void>

    export const useDeleteSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSpace>>,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSpaces = (
    removeManySpaceDto: BodyType<RemoveManySpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSpaces200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeManySpaceDto
    },
      options);
    }
  


export const getRemoveSpacesMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpaces>>, TError,{data: BodyType<RemoveManySpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSpaces>>, TError,{data: BodyType<RemoveManySpaceDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSpaces>>, {data: BodyType<RemoveManySpaceDto>}> = (props) => {
          const {data} = props ?? {};

          return  removeSpaces(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSpacesMutationResult = NonNullable<Awaited<ReturnType<typeof removeSpaces>>>
    export type RemoveSpacesMutationBody = BodyType<RemoveManySpaceDto>
    export type RemoveSpacesMutationError = ErrorType<void>

    export const useRemoveSpaces = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpaces>>, TError,{data: BodyType<RemoveManySpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSpaces>>,
        TError,
        {data: BodyType<RemoveManySpaceDto>},
        TContext
      > => {

      const mutationOptions = getRemoveSpacesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSpace200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces/${spaceId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSpaceMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  removeSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof removeSpace>>>
    
    export type RemoveSpaceMutationError = ErrorType<void>

    export const useRemoveSpace = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSpace>>, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSpace>>,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAccessibleSpaces = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAccessibleSpaces200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/spaces/accessible-spaces`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAccessibleSpacesQueryKey = () => {
    return [`http://localhost:3005/api/v1/admin/spaces/accessible-spaces`] as const;
    }

    
export const getGetAccessibleSpacesQueryOptions = <TData = Awaited<ReturnType<typeof getAccessibleSpaces>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccessibleSpacesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessibleSpaces>>> = ({ signal }) => getAccessibleSpaces(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccessibleSpacesQueryResult = NonNullable<Awaited<ReturnType<typeof getAccessibleSpaces>>>
export type GetAccessibleSpacesQueryError = ErrorType<void>

export const useGetAccessibleSpaces = <TData = Awaited<ReturnType<typeof getAccessibleSpaces>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAccessibleSpacesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAccessibleSpacesSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAccessibleSpaces>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccessibleSpacesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessibleSpaces>>> = ({ signal }) => getAccessibleSpaces(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccessibleSpacesSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAccessibleSpaces>>>
export type GetAccessibleSpacesSuspenseQueryError = ErrorType<void>

export const useGetAccessibleSpacesSuspense = <TData = Awaited<ReturnType<typeof getAccessibleSpaces>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAccessibleSpacesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAccessibleSpacesSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAccessibleSpaces>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccessibleSpacesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccessibleSpaces>>> = ({ signal }) => getAccessibleSpaces(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccessibleSpacesSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAccessibleSpaces>>>
export type GetAccessibleSpacesSuspenseInfiniteQueryError = ErrorType<void>

export const useGetAccessibleSpacesSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getAccessibleSpaces>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAccessibleSpaces>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetAccessibleSpacesSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createGroup = (
    createGroupDto: BodyType<CreateGroupDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GroupDto>(
      {url: `http://localhost:3005/api/v1/admin/groups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createGroupDto
    },
      options);
    }
  


export const getCreateGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,{data: BodyType<CreateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,{data: BodyType<CreateGroupDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGroup>>, {data: BodyType<CreateGroupDto>}> = (props) => {
          const {data} = props ?? {};

          return  createGroup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof createGroup>>>
    export type CreateGroupMutationBody = BodyType<CreateGroupDto>
    export type CreateGroupMutationError = ErrorType<unknown>

    export const useCreateGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createGroup>>, TError,{data: BodyType<CreateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createGroup>>,
        TError,
        {data: BodyType<CreateGroupDto>},
        TContext
      > => {

      const mutationOptions = getCreateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getGroupsByQuery = (
    params?: GetGroupsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroupsByQuery200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/groups`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGroupsByQueryQueryKey = (params?: GetGroupsByQueryParams,) => {
    return [`http://localhost:3005/api/v1/admin/groups`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGroupsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQueryQueryError = ErrorType<unknown>

export const useGetGroupsByQuery = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseQueryError = ErrorType<unknown>

export const useGetGroupsByQuerySuspense = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>

export const useGetGroupsByQuerySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroup200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/groups/${groupId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetGroupQueryKey = (groupId: string,) => {
    return [`http://localhost:3005/api/v1/admin/groups/${groupId}`] as const;
    }

    
export const getGetGroupQueryOptions = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupQueryError = ErrorType<unknown>

export const useGetGroup = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupQueryOptions(groupId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupSuspenseQueryError = ErrorType<unknown>

export const useGetGroupSuspense = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupSuspenseQueryOptions(groupId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: QueryKey }
}

export type GetGroupSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupSuspenseInfiniteQueryError = ErrorType<unknown>

export const useGetGroupSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetGroupSuspenseInfiniteQueryOptions(groupId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateGroup = (
    groupId: string,
    updateGroupDto: BodyType<UpdateGroupDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateGroup200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/groups/${groupId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateGroupDto
    },
      options);
    }
  


export const getUpdateGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGroup>>, {groupId: string;data: BodyType<UpdateGroupDto>}> = (props) => {
          const {groupId,data} = props ?? {};

          return  updateGroup(groupId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateGroup>>>
    export type UpdateGroupMutationBody = BodyType<UpdateGroupDto>
    export type UpdateGroupMutationError = ErrorType<unknown>

    export const useUpdateGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateGroup>>, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateGroup>>,
        TError,
        {groupId: string;data: BodyType<UpdateGroupDto>},
        TContext
      > => {

      const mutationOptions = getUpdateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteGroup200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/groups/${groupId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteGroupMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroup>>, {groupId: string}> = (props) => {
          const {groupId} = props ?? {};

          return  deleteGroup(groupId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroup>>>
    
    export type DeleteGroupMutationError = ErrorType<unknown>

    export const useDeleteGroup = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteGroup>>, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteGroup>>,
        TError,
        {groupId: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeGroups = (
    groupIds: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveGroups200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/groups/${groupIds}`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveGroupsMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeGroups>>, {groupIds: string[]}> = (props) => {
          const {groupIds} = props ?? {};

          return  removeGroups(groupIds,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof removeGroups>>>
    
    export type RemoveGroupsMutationError = ErrorType<unknown>

    export const useRemoveGroups = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeGroups>>, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeGroups>>,
        TError,
        {groupIds: string[]},
        TContext
      > => {

      const mutationOptions = getRemoveGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSubject = (
    createSubjectDto: BodyType<CreateSubjectDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3005/api/v1/admin/subjects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSubjectDto
    },
      options);
    }
  


export const getCreateSubjectMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{data: BodyType<CreateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{data: BodyType<CreateSubjectDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubject>>, {data: BodyType<CreateSubjectDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSubject(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof createSubject>>>
    export type CreateSubjectMutationBody = BodyType<CreateSubjectDto>
    export type CreateSubjectMutationError = ErrorType<unknown>

    export const useCreateSubject = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubject>>, TError,{data: BodyType<CreateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSubject>>,
        TError,
        {data: BodyType<CreateSubjectDto>},
        TContext
      > => {

      const mutationOptions = getCreateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSubjectsByPageQuery = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubjectsByPageQuery200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/subjects`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubjectsByPageQueryQueryKey = () => {
    return [`http://localhost:3005/api/v1/admin/subjects`] as const;
    }

    
export const getGetSubjectsByPageQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByPageQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByPageQuery>>> = ({ signal }) => getSubjectsByPageQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectsByPageQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByPageQuery>>>
export type GetSubjectsByPageQueryQueryError = ErrorType<unknown>

export const useGetSubjectsByPageQuery = <TData = Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSubjectsByPageQueryQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByPageQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByPageQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByPageQuery>>> = ({ signal }) => getSubjectsByPageQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectsByPageQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByPageQuery>>>
export type GetSubjectsByPageQuerySuspenseQueryError = ErrorType<unknown>

export const useGetSubjectsByPageQuerySuspense = <TData = Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSubjectsByPageQuerySuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByPageQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByPageQuery>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByPageQueryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByPageQuery>>> = ({ signal }) => getSubjectsByPageQuery(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectsByPageQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByPageQuery>>>
export type GetSubjectsByPageQuerySuspenseInfiniteQueryError = ErrorType<unknown>

export const useGetSubjectsByPageQuerySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByPageQuery>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByPageQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSubjectsByPageQuerySuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSubjectById = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubjectById200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/subjects/${subjectId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubjectByIdQueryKey = (subjectId: string,) => {
    return [`http://localhost:3005/api/v1/admin/subjects/${subjectId}`] as const;
    }

    
export const getGetSubjectByIdQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectById>>, TError = ErrorType<unknown>>(subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectByIdQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectById>>> = ({ signal }) => getSubjectById(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectById>>>
export type GetSubjectByIdQueryError = ErrorType<unknown>

export const useGetSubjectById = <TData = Awaited<ReturnType<typeof getSubjectById>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSubjectByIdQueryOptions(subjectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectById>>, TError = ErrorType<unknown>>(subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectByIdQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectById>>> = ({ signal }) => getSubjectById(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectById>>>
export type GetSubjectByIdSuspenseQueryError = ErrorType<unknown>

export const useGetSubjectByIdSuspense = <TData = Awaited<ReturnType<typeof getSubjectById>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSubjectByIdSuspenseQueryOptions(subjectId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectById>>>, TError = ErrorType<unknown>>(subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectByIdQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectById>>> = ({ signal }) => getSubjectById(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSubjectByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectById>>>
export type GetSubjectByIdSuspenseInfiniteQueryError = ErrorType<unknown>

export const useGetSubjectByIdSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectById>>>, TError = ErrorType<unknown>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSubjectByIdSuspenseInfiniteQueryOptions(subjectId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSubjectById = (
    subjectId: string,
    updateSubjectDto: BodyType<UpdateSubjectDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSubjectById200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/subjects/${subjectId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSubjectDto
    },
      options);
    }
  


export const getUpdateSubjectByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubjectById>>, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSubjectById>>, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubjectById>>, {subjectId: string;data: BodyType<UpdateSubjectDto>}> = (props) => {
          const {subjectId,data} = props ?? {};

          return  updateSubjectById(subjectId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubjectByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubjectById>>>
    export type UpdateSubjectByIdMutationBody = BodyType<UpdateSubjectDto>
    export type UpdateSubjectByIdMutationError = ErrorType<unknown>

    export const useUpdateSubjectById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubjectById>>, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSubjectById>>,
        TError,
        {subjectId: string;data: BodyType<UpdateSubjectDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSubjectByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSubjectById = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3005/api/v1/admin/subjects/${subjectId}`, method: 'DELETE'
    },
      options);
    }
  


export const getRemoveSubjectByIdMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubjectById>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSubjectById>>, TError,{subjectId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubjectById>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  removeSubjectById(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSubjectByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubjectById>>>
    
    export type RemoveSubjectByIdMutationError = ErrorType<unknown>

    export const useRemoveSubjectById = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSubjectById>>, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSubjectById>>,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getToken = (
    loginPayloadDto: BodyType<LoginPayloadDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<GetToken200AllOf>(
      {url: `http://localhost:3005/api/v1/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginPayloadDto
    },
      options);
    }
  


export const getGetTokenMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getToken>>, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof getToken>>, TError,{data: BodyType<LoginPayloadDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getToken>>, {data: BodyType<LoginPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  getToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetTokenMutationResult = NonNullable<Awaited<ReturnType<typeof getToken>>>
    export type GetTokenMutationBody = BodyType<LoginPayloadDto>
    export type GetTokenMutationError = ErrorType<unknown>

    export const useGetToken = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getToken>>, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof getToken>>,
        TError,
        {data: BodyType<LoginPayloadDto>},
        TContext
      > => {

      const mutationOptions = getGetTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getCurrentUser = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<UserDto>(
      {url: `http://localhost:3005/api/v1/auth/current-user`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCurrentUserQueryKey = () => {
    return [`http://localhost:3005/api/v1/auth/current-user`] as const;
    }

    
export const getGetCurrentUserQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentUserQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserQueryError = ErrorType<void>

export const useGetCurrentUser = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCurrentUserQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserSuspenseQueryError = ErrorType<void>

export const useGetCurrentUserSuspense = <TData = Awaited<ReturnType<typeof getCurrentUser>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCurrentUserSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCurrentUserSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentUser>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCurrentUserQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCurrentUser>>> = ({ signal }) => getCurrentUser(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCurrentUserSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCurrentUser>>>
export type GetCurrentUserSuspenseInfiniteQueryError = ErrorType<void>

export const useGetCurrentUserSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getCurrentUser>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCurrentUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCurrentUserSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getNewToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenDto>(
      {url: `http://localhost:3005/api/v1/auth/new-token`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNewTokenQueryKey = () => {
    return [`http://localhost:3005/api/v1/auth/new-token`] as const;
    }

    
export const getGetNewTokenQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNewTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenQueryError = ErrorType<void>

export const useGetNewToken = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNewTokenQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNewTokenSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseQueryError = ErrorType<void>

export const useGetNewTokenSuspense = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNewTokenSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNewTokenSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseInfiniteQueryError = ErrorType<void>

export const useGetNewTokenSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetNewTokenSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const signUpUser = (
    signUpPayloadDto: BodyType<SignUpPayloadDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `http://localhost:3005/api/v1/auth/sign-up`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signUpPayloadDto
    },
      options);
    }
  


export const getSignUpUserMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUpUser>>, {data: BodyType<SignUpPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  signUpUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type SignUpUserMutationResult = NonNullable<Awaited<ReturnType<typeof signUpUser>>>
    export type SignUpUserMutationBody = BodyType<SignUpPayloadDto>
    export type SignUpUserMutationError = ErrorType<unknown>

    export const useSignUpUser = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof signUpUser>>,
        TError,
        {data: BodyType<SignUpPayloadDto>},
        TContext
      > => {

      const mutationOptions = getSignUpUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSession = (
    createSessionDto: BodyType<CreateSessionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<CreateSession200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSessionDto
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: BodyType<CreateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: BodyType<CreateSessionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: BodyType<CreateSessionDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = BodyType<CreateSessionDto>
    export type CreateSessionMutationError = ErrorType<void>

    export const useCreateSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSession>>, TError,{data: BodyType<CreateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof createSession>>,
        TError,
        {data: BodyType<CreateSessionDto>},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSessionsByQuery = (
    params?: GetSessionsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSessionsByQuery200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSessionsByQueryQueryKey = (params?: GetSessionsByQueryParams,) => {
    return [`http://localhost:3005/api/v1/admin/sessions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSessionsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQueryQueryError = ErrorType<void>

export const useGetSessionsByQuery = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseQueryError = ErrorType<void>

export const useGetSessionsByQuerySuspense = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseInfiniteQueryError = ErrorType<void>

export const useGetSessionsByQuerySuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSession200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionQueryKey = (sessionId: string,) => {
    return [`http://localhost:3005/api/v1/admin/sessions/${sessionId}`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = ErrorType<void>

export const useGetSession = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseQueryError = ErrorType<void>

export const useGetSessionSuspense = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionSuspenseQueryOptions(sessionId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSessionSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseInfiniteQueryError = ErrorType<void>

export const useGetSessionSuspenseInfinite = <TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetSessionSuspenseInfiniteQueryOptions(sessionId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSession = (
    sessionId: string,
    updateSessionDto: BodyType<UpdateSessionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSession200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions/${sessionId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSessionDto
    },
      options);
    }
  


export const getUpdateSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {sessionId: string;data: BodyType<UpdateSessionDto>}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateSession(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    export type UpdateSessionMutationBody = BodyType<UpdateSessionDto>
    export type UpdateSessionMutationError = ErrorType<void>

    export const useUpdateSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSession>>, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof updateSession>>,
        TError,
        {sessionId: string;data: BodyType<UpdateSessionDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSession200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  deleteSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSession>>>
    
    export type DeleteSessionMutationError = ErrorType<void>

    export const useDeleteSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof deleteSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSessions = (
    removeSessionsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSessions200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSessionsBody
    },
      options);
    }
  


export const getRemoveSessionsMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSessions>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSessions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSessions>>>
    export type RemoveSessionsMutationBody = BodyType<string[]>
    export type RemoveSessionsMutationError = ErrorType<void>

    export const useRemoveSessions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSessions>>, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSessions>>,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSessionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSession200AllOf>(
      {url: `http://localhost:3005/api/v1/admin/sessions/${sessionId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSessionMutationOptions = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  removeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof removeSession>>>
    
    export type RemoveSessionMutationError = ErrorType<void>

    export const useRemoveSession = <TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeSession>>, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        Awaited<ReturnType<typeof removeSession>>,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    


export const getCreateTimelineItemResponseMock = (): CreateTimelineItem200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), space: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetTimelineItemsByQueryResponseMock = (): GetTimelineItemsByQuery200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetTimelineItemResponseMock = (): GetTimelineItem200AllOf => ({data: faker.helpers.arrayElement([{address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateTimelineItemResponseMock = (): UpdateTimelineItem200AllOf => ({data: faker.helpers.arrayElement([{address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getDeleteTimelineItemResponseMock = (): DeleteTimelineItem200AllOf => ({data: faker.helpers.arrayElement([{address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveTimelineItemsResponseMock = (): RemoveTimelineItems200AllOf => ({data: faker.helpers.arrayElement([{address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveTimelineItemResponseMock = (): RemoveTimelineItem200AllOf => ({data: faker.helpers.arrayElement([{address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getCreateAbilityResponseMock = (): CreateAbility201AllOf => ({data: faker.helpers.arrayElement([{action: faker.helpers.arrayElement(Object.values(AbilityActions)), conditions: faker.helpers.arrayElement([{}, undefined]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.helpers.arrayElement([faker.word.sample(), undefined]), id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), roleId: faker.string.uuid(), subjectId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(AbilityTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetAbilitiesByQueryResponseMock = (): GetAbilitiesByQuery200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({action: faker.helpers.arrayElement(Object.values(AbilityActions)), conditions: faker.helpers.arrayElement([{}, undefined]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.helpers.arrayElement([faker.word.sample(), undefined]), id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), roleId: faker.string.uuid(), subjectId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(AbilityTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetAbilityResponseMock = (): GetAbility200AllOf => ({data: faker.helpers.arrayElement([{action: faker.helpers.arrayElement(Object.values(AbilityActions)), conditions: faker.helpers.arrayElement([{}, undefined]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.helpers.arrayElement([faker.word.sample(), undefined]), id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), roleId: faker.string.uuid(), subjectId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(AbilityTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveAbilityResponseMock = (): RemoveAbility200AllOf => ({data: faker.helpers.arrayElement([{action: faker.helpers.arrayElement(Object.values(AbilityActions)), conditions: faker.helpers.arrayElement([{}, undefined]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.helpers.arrayElement([faker.word.sample(), undefined]), id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), roleId: faker.string.uuid(), subjectId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(AbilityTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getDeleteAbilityResponseMock = (): DeleteAbility200AllOf => ({data: faker.helpers.arrayElement([{action: faker.helpers.arrayElement(Object.values(AbilityActions)), conditions: faker.helpers.arrayElement([{}, undefined]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.helpers.arrayElement([faker.word.sample(), undefined]), id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), roleId: faker.string.uuid(), subjectId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(AbilityTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveAbilitiesResponseMock = (): RemoveAbilities200AllOf => ({data: faker.helpers.arrayElement([{action: faker.helpers.arrayElement(Object.values(AbilityActions)), conditions: faker.helpers.arrayElement([{}, undefined]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.helpers.arrayElement([faker.word.sample(), undefined]), id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), roleId: faker.string.uuid(), subjectId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(AbilityTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetCategoriesResponseMock = (): GetCategories200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({ancestorIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.word.sample())), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), parentId: faker.helpers.arrayElement([faker.word.sample(), null]), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getCreateCategoryResponseMock = (): CreateCategory200AllOf => ({data: faker.helpers.arrayElement([{ancestorIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.word.sample())), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), parentId: faker.helpers.arrayElement([faker.word.sample(), null]), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getFindCategoryByIdResponseMock = (): FindCategoryById200AllOf => ({data: faker.helpers.arrayElement([{ancestorIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.word.sample())), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), parentId: faker.helpers.arrayElement([faker.word.sample(), null]), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateCategoryResponseMock = (): UpdateCategory200AllOf => ({data: faker.helpers.arrayElement([{ancestorIds: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => (faker.word.sample())), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), parentId: faker.helpers.arrayElement([faker.word.sample(), null]), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetAllServiceResponseMock = (): GetAllService200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getCreateServiceResponseMock = (): CreateService201AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetServiceResponseMock = (): GetService200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateServiceResponseMock = (): UpdateService200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getDeleteServiceResponseMock = (): DeleteService200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveServiceResponseMock = (): RemoveService200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveServicesResponseMock = (): RemoveServices200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), label: faker.helpers.arrayElement([faker.word.sample(), null]), name: faker.helpers.arrayElement(Object.values(ServiceName)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getCreateSpaceResponseMock = (): CreateSpace200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), space: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetSpacesByQueryResponseMock = (): GetSpacesByQuery200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetSpaceResponseMock = (): GetSpace200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateSpaceResponseMock = (): UpdateSpace200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getDeleteSpaceResponseMock = (): DeleteSpace200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveSpacesResponseMock = (): RemoveSpaces200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveSpaceResponseMock = (): RemoveSpace200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetAccessibleSpacesResponseMock = (): GetAccessibleSpaces200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getCreateGroupResponseMock = (overrideResponse: Partial< GroupDto > = {}): GroupDto => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetGroupsByQueryResponseMock = (): GetGroupsByQuery200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetGroupResponseMock = (): GetGroup200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateGroupResponseMock = (): UpdateGroup200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getDeleteGroupResponseMock = (): DeleteGroup200AllOf => ({data: faker.helpers.arrayElement([{}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveGroupsResponseMock = (): RemoveGroups200AllOf => ({data: faker.helpers.arrayElement([{}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetSubjectsByPageQueryResponseMock = (): GetSubjectsByPageQuery200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetSubjectByIdResponseMock = (): GetSubjectById200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateSubjectByIdResponseMock = (): UpdateSubjectById200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetTokenResponseMock = (): GetToken200AllOf => ({data: faker.helpers.arrayElement([{accessToken: faker.word.sample(), refreshToken: faker.word.sample(), tenant: {active: faker.datatype.boolean(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), role: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.helpers.arrayElement(Object.values(Roles)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, roleId: faker.word.sample(), tenancy: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), space: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, tenancyId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(TenantTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, user: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, email: faker.word.sample(), id: faker.string.uuid(), name: faker.word.sample(), password: faker.word.sample(), phone: faker.word.sample(), profiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), nickname: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), userId: faker.word.sample()})), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, userId: faker.word.sample()}, user: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, email: faker.word.sample(), id: faker.string.uuid(), name: faker.word.sample(), password: faker.word.sample(), phone: faker.word.sample(), profiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), nickname: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), userId: faker.word.sample()})), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetCurrentUserResponseMock = (overrideResponse: Partial< UserDto > = {}): UserDto => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, email: faker.word.sample(), id: faker.string.uuid(), name: faker.word.sample(), password: faker.word.sample(), phone: faker.word.sample(), profiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), nickname: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), userId: faker.word.sample()})), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, ...overrideResponse})

export const getGetNewTokenResponseMock = (overrideResponse: Partial< TokenDto > = {}): TokenDto => ({accessToken: faker.word.sample(), refreshToken: faker.word.sample(), tenant: {active: faker.datatype.boolean(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), role: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.helpers.arrayElement(Object.values(Roles)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, roleId: faker.word.sample(), tenancy: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), space: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, tenancyId: faker.string.uuid(), type: faker.helpers.arrayElement(Object.values(TenantTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, user: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, email: faker.word.sample(), id: faker.string.uuid(), name: faker.word.sample(), password: faker.word.sample(), phone: faker.word.sample(), profiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), nickname: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), userId: faker.word.sample()})), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, userId: faker.word.sample()}, user: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, email: faker.word.sample(), id: faker.string.uuid(), name: faker.word.sample(), password: faker.word.sample(), phone: faker.word.sample(), profiles: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), nickname: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), userId: faker.word.sample()})), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, ...overrideResponse})

export const getCreateSessionResponseMock = (): CreateSession200AllOf => ({data: faker.helpers.arrayElement([{createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), space: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, groups: {createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), serviceId: faker.word.sample(), spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, id: faker.string.uuid(), name: faker.word.sample(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), tenancies: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), updatedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null])})), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, spaceId: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetSessionsByQueryResponseMock = (): GetSessionsByQuery200AllOf => ({data: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({baseDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, endDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), id: faker.string.uuid(), name: faker.word.sample(), recurringDayOfTheWeek: faker.helpers.arrayElements(Object.values(RecurringDayOfTheWeek)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), repeatCycle: faker.number.int({min: undefined, max: undefined}), repeatCycleType: faker.helpers.arrayElement(Object.values(RepeatCycleTypes)), tenancyId: faker.string.uuid(), tenantId: faker.string.uuid(), timelines: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), sessionId: faker.string.uuid(), tenantId: faker.string.uuid(), timelineItem: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), timelineItemId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), type: faker.helpers.arrayElement(Object.values(SessionTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getGetSessionResponseMock = (): GetSession200AllOf => ({data: faker.helpers.arrayElement([{baseDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, endDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), id: faker.string.uuid(), name: faker.word.sample(), recurringDayOfTheWeek: faker.helpers.arrayElements(Object.values(RecurringDayOfTheWeek)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), repeatCycle: faker.number.int({min: undefined, max: undefined}), repeatCycleType: faker.helpers.arrayElement(Object.values(RepeatCycleTypes)), tenancyId: faker.string.uuid(), tenantId: faker.string.uuid(), timelines: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), sessionId: faker.string.uuid(), tenantId: faker.string.uuid(), timelineItem: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), timelineItemId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), type: faker.helpers.arrayElement(Object.values(SessionTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getUpdateSessionResponseMock = (): UpdateSession200AllOf => ({data: faker.helpers.arrayElement([{baseDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, endDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), id: faker.string.uuid(), name: faker.word.sample(), recurringDayOfTheWeek: faker.helpers.arrayElements(Object.values(RecurringDayOfTheWeek)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), repeatCycle: faker.number.int({min: undefined, max: undefined}), repeatCycleType: faker.helpers.arrayElement(Object.values(RepeatCycleTypes)), tenancyId: faker.string.uuid(), tenantId: faker.string.uuid(), timelines: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), sessionId: faker.string.uuid(), tenantId: faker.string.uuid(), timelineItem: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), timelineItemId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), type: faker.helpers.arrayElement(Object.values(SessionTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getDeleteSessionResponseMock = (): DeleteSession200AllOf => ({data: faker.helpers.arrayElement([{baseDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, endDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), id: faker.string.uuid(), name: faker.word.sample(), recurringDayOfTheWeek: faker.helpers.arrayElements(Object.values(RecurringDayOfTheWeek)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), repeatCycle: faker.number.int({min: undefined, max: undefined}), repeatCycleType: faker.helpers.arrayElement(Object.values(RepeatCycleTypes)), tenancyId: faker.string.uuid(), tenantId: faker.string.uuid(), timelines: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), sessionId: faker.string.uuid(), tenantId: faker.string.uuid(), timelineItem: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), timelineItemId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), type: faker.helpers.arrayElement(Object.values(SessionTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveSessionsResponseMock = (): RemoveSessions200AllOf => ({data: faker.helpers.arrayElement([{baseDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, endDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), id: faker.string.uuid(), name: faker.word.sample(), recurringDayOfTheWeek: faker.helpers.arrayElements(Object.values(RecurringDayOfTheWeek)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), repeatCycle: faker.number.int({min: undefined, max: undefined}), repeatCycleType: faker.helpers.arrayElement(Object.values(RepeatCycleTypes)), tenancyId: faker.string.uuid(), tenantId: faker.string.uuid(), timelines: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), sessionId: faker.string.uuid(), tenantId: faker.string.uuid(), timelineItem: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), timelineItemId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), type: faker.helpers.arrayElement(Object.values(SessionTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})

export const getRemoveSessionResponseMock = (): RemoveSession200AllOf => ({data: faker.helpers.arrayElement([{baseDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, endDate: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), id: faker.string.uuid(), name: faker.word.sample(), recurringDayOfTheWeek: faker.helpers.arrayElements(Object.values(RecurringDayOfTheWeek)), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), repeatCycle: faker.number.int({min: undefined, max: undefined}), repeatCycleType: faker.helpers.arrayElement(Object.values(RepeatCycleTypes)), tenancyId: faker.string.uuid(), tenantId: faker.string.uuid(), timelines: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, date: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), sessionId: faker.string.uuid(), tenantId: faker.string.uuid(), timelineItem: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({address: faker.word.sample(), createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, description: faker.word.sample(), endDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), maxCapacity: faker.number.int({min: undefined, max: undefined}), minCapacity: faker.number.int({min: undefined, max: undefined}), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), reservations: Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({createdAt: `${faker.date.past().toISOString().split('.')[0]}Z`, id: faker.string.uuid(), removedAt: faker.helpers.arrayElement([`${faker.date.past().toISOString().split('.')[0]}Z`, null]), status: faker.helpers.arrayElement(Object.values(ReservationStatus)), tenantId: faker.string.uuid(), timelineItemId: faker.string.uuid(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`, userId: faker.string.uuid()})), startDateTime: `${faker.date.past().toISOString().split('.')[0]}Z`, tenantId: faker.string.uuid(), timelineId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), title: faker.word.sample(), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), timelineItemId: faker.helpers.arrayElement([faker.string.uuid(), undefined]), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`})), type: faker.helpers.arrayElement(Object.values(SessionTypes)), updatedAt: `${faker.date.past().toISOString().split('.')[0]}Z`}, undefined]), httpStatus: faker.helpers.arrayElement([faker.number.int({min: undefined, max: undefined}), undefined]), message: faker.helpers.arrayElement([faker.word.sample(), undefined])})


export const getCreateTimelineItemMockHandler = (overrideResponse?: CreateTimelineItem200AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateTimelineItem200AllOf> | CreateTimelineItem200AllOf)) => {
  return http.post('*/api/v1/admin/timeline-items', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateTimelineItemResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetTimelineItemsByQueryMockHandler = (overrideResponse?: GetTimelineItemsByQuery200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetTimelineItemsByQuery200AllOf> | GetTimelineItemsByQuery200AllOf)) => {
  return http.get('*/api/v1/admin/timeline-items', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetTimelineItemsByQueryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetTimelineItemMockHandler = (overrideResponse?: GetTimelineItem200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetTimelineItem200AllOf> | GetTimelineItem200AllOf)) => {
  return http.get('*/api/v1/admin/timeline-items/:timelineItemId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetTimelineItemResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateTimelineItemMockHandler = (overrideResponse?: UpdateTimelineItem200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateTimelineItem200AllOf> | UpdateTimelineItem200AllOf)) => {
  return http.patch('*/api/v1/admin/timeline-items/:timelineItemId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateTimelineItemResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteTimelineItemMockHandler = (overrideResponse?: DeleteTimelineItem200AllOf | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteTimelineItem200AllOf> | DeleteTimelineItem200AllOf)) => {
  return http.delete('*/api/v1/admin/timeline-items/:timelineItemId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteTimelineItemResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveTimelineItemsMockHandler = (overrideResponse?: RemoveTimelineItems200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveTimelineItems200AllOf> | RemoveTimelineItems200AllOf)) => {
  return http.patch('*/api/v1/admin/timeline-items/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveTimelineItemsResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveTimelineItemMockHandler = (overrideResponse?: RemoveTimelineItem200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveTimelineItem200AllOf> | RemoveTimelineItem200AllOf)) => {
  return http.patch('*/api/v1/admin/timeline-items/:timelineItemId/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveTimelineItemResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateAbilityMockHandler = (overrideResponse?: CreateAbility201AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateAbility201AllOf> | CreateAbility201AllOf)) => {
  return http.post('*/api/v1/admin/abilities', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateAbilityResponseMock()),
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetAbilitiesByQueryMockHandler = (overrideResponse?: GetAbilitiesByQuery200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetAbilitiesByQuery200AllOf> | GetAbilitiesByQuery200AllOf)) => {
  return http.get('*/api/v1/admin/abilities', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetAbilitiesByQueryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetAbilityMockHandler = (overrideResponse?: GetAbility200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetAbility200AllOf> | GetAbility200AllOf)) => {
  return http.get('*/api/v1/admin/abilities/:abilityId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetAbilityResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveAbilityMockHandler = (overrideResponse?: RemoveAbility200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveAbility200AllOf> | RemoveAbility200AllOf)) => {
  return http.patch('*/api/v1/admin/abilities/:abilityId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveAbilityResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteAbilityMockHandler = (overrideResponse?: DeleteAbility200AllOf | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteAbility200AllOf> | DeleteAbility200AllOf)) => {
  return http.delete('*/api/v1/admin/abilities/:abilityId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteAbilityResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveAbilitiesMockHandler = (overrideResponse?: RemoveAbilities200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveAbilities200AllOf> | RemoveAbilities200AllOf)) => {
  return http.patch('*/api/v1/admin/abilities/:abilityIds', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveAbilitiesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetCategoriesMockHandler = (overrideResponse?: GetCategories200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetCategories200AllOf> | GetCategories200AllOf)) => {
  return http.get('*/api/v1/admin/categories', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetCategoriesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateCategoryMockHandler = (overrideResponse?: CreateCategory200AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateCategory200AllOf> | CreateCategory200AllOf)) => {
  return http.post('*/api/v1/admin/categories', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateCategoryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getFindCategoryByIdMockHandler = (overrideResponse?: FindCategoryById200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<FindCategoryById200AllOf> | FindCategoryById200AllOf)) => {
  return http.get('*/api/v1/admin/categories/:categoryId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getFindCategoryByIdResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateCategoryMockHandler = (overrideResponse?: UpdateCategory200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateCategory200AllOf> | UpdateCategory200AllOf)) => {
  return http.patch('*/api/v1/admin/categories/:categoryId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateCategoryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetAllServiceMockHandler = (overrideResponse?: GetAllService200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetAllService200AllOf> | GetAllService200AllOf)) => {
  return http.get('*/api/v1/admin/services', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetAllServiceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateServiceMockHandler = (overrideResponse?: CreateService201AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateService201AllOf> | CreateService201AllOf)) => {
  return http.post('*/api/v1/admin/services', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateServiceResponseMock()),
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetServiceMockHandler = (overrideResponse?: GetService200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetService200AllOf> | GetService200AllOf)) => {
  return http.get('*/api/v1/admin/services/:serviceId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetServiceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateServiceMockHandler = (overrideResponse?: UpdateService200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateService200AllOf> | UpdateService200AllOf)) => {
  return http.patch('*/api/v1/admin/services/:serviceId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateServiceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteServiceMockHandler = (overrideResponse?: DeleteService200AllOf | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteService200AllOf> | DeleteService200AllOf)) => {
  return http.delete('*/api/v1/admin/services/:serviceId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteServiceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveServiceMockHandler = (overrideResponse?: RemoveService200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveService200AllOf> | RemoveService200AllOf)) => {
  return http.patch('*/api/v1/admin/services/:serviceId/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveServiceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveServicesMockHandler = (overrideResponse?: RemoveServices200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveServices200AllOf> | RemoveServices200AllOf)) => {
  return http.patch('*/api/v1/admin/services/:serviceIds/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveServicesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateSpaceMockHandler = (overrideResponse?: CreateSpace200AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateSpace200AllOf> | CreateSpace200AllOf)) => {
  return http.post('*/api/v1/admin/spaces', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateSpaceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetSpacesByQueryMockHandler = (overrideResponse?: GetSpacesByQuery200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetSpacesByQuery200AllOf> | GetSpacesByQuery200AllOf)) => {
  return http.get('*/api/v1/admin/spaces', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetSpacesByQueryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetSpaceMockHandler = (overrideResponse?: GetSpace200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetSpace200AllOf> | GetSpace200AllOf)) => {
  return http.get('*/api/v1/admin/spaces/:spaceId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetSpaceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateSpaceMockHandler = (overrideResponse?: UpdateSpace200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateSpace200AllOf> | UpdateSpace200AllOf)) => {
  return http.patch('*/api/v1/admin/spaces/:spaceId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateSpaceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteSpaceMockHandler = (overrideResponse?: DeleteSpace200AllOf | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteSpace200AllOf> | DeleteSpace200AllOf)) => {
  return http.delete('*/api/v1/admin/spaces/:spaceId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteSpaceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveSpacesMockHandler = (overrideResponse?: RemoveSpaces200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveSpaces200AllOf> | RemoveSpaces200AllOf)) => {
  return http.patch('*/api/v1/admin/spaces/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveSpacesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveSpaceMockHandler = (overrideResponse?: RemoveSpace200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveSpace200AllOf> | RemoveSpace200AllOf)) => {
  return http.patch('*/api/v1/admin/spaces/:spaceId/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveSpaceResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetAccessibleSpacesMockHandler = (overrideResponse?: GetAccessibleSpaces200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetAccessibleSpaces200AllOf> | GetAccessibleSpaces200AllOf)) => {
  return http.get('*/api/v1/admin/spaces/accessible-spaces', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetAccessibleSpacesResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateGroupMockHandler = (overrideResponse?: GroupDto | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<GroupDto> | GroupDto)) => {
  return http.post('*/api/v1/admin/groups', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateGroupResponseMock()),
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetGroupsByQueryMockHandler = (overrideResponse?: GetGroupsByQuery200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetGroupsByQuery200AllOf> | GetGroupsByQuery200AllOf)) => {
  return http.get('*/api/v1/admin/groups', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetGroupsByQueryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetGroupMockHandler = (overrideResponse?: GetGroup200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetGroup200AllOf> | GetGroup200AllOf)) => {
  return http.get('*/api/v1/admin/groups/:groupId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetGroupResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateGroupMockHandler = (overrideResponse?: UpdateGroup200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateGroup200AllOf> | UpdateGroup200AllOf)) => {
  return http.patch('*/api/v1/admin/groups/:groupId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateGroupResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteGroupMockHandler = (overrideResponse?: DeleteGroup200AllOf | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteGroup200AllOf> | DeleteGroup200AllOf)) => {
  return http.delete('*/api/v1/admin/groups/:groupId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteGroupResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveGroupsMockHandler = (overrideResponse?: RemoveGroups200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveGroups200AllOf> | RemoveGroups200AllOf)) => {
  return http.patch('*/api/v1/admin/groups/:groupIds', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveGroupsResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateSubjectMockHandler = () => {
  return http.post('*/api/v1/admin/subjects', async () => {await delay(1000);
    return new HttpResponse(null,
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetSubjectsByPageQueryMockHandler = (overrideResponse?: GetSubjectsByPageQuery200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetSubjectsByPageQuery200AllOf> | GetSubjectsByPageQuery200AllOf)) => {
  return http.get('*/api/v1/admin/subjects', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetSubjectsByPageQueryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetSubjectByIdMockHandler = (overrideResponse?: GetSubjectById200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetSubjectById200AllOf> | GetSubjectById200AllOf)) => {
  return http.get('*/api/v1/admin/subjects/:subjectId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetSubjectByIdResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateSubjectByIdMockHandler = (overrideResponse?: UpdateSubjectById200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateSubjectById200AllOf> | UpdateSubjectById200AllOf)) => {
  return http.patch('*/api/v1/admin/subjects/:subjectId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateSubjectByIdResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveSubjectByIdMockHandler = () => {
  return http.delete('*/api/v1/admin/subjects/:subjectId', async () => {await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetTokenMockHandler = (overrideResponse?: GetToken200AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<GetToken200AllOf> | GetToken200AllOf)) => {
  return http.post('*/api/v1/auth/token', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetTokenResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetCurrentUserMockHandler = (overrideResponse?: UserDto | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<UserDto> | UserDto)) => {
  return http.get('*/api/v1/auth/current-user', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetCurrentUserResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetNewTokenMockHandler = (overrideResponse?: TokenDto | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<TokenDto> | TokenDto)) => {
  return http.get('*/api/v1/auth/new-token', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetNewTokenResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getSignUpUserMockHandler = () => {
  return http.post('*/api/v1/auth/sign-up', async () => {await delay(1000);
    return new HttpResponse(null,
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateSessionMockHandler = (overrideResponse?: CreateSession200AllOf | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<CreateSession200AllOf> | CreateSession200AllOf)) => {
  return http.post('*/api/v1/admin/sessions', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getCreateSessionResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetSessionsByQueryMockHandler = (overrideResponse?: GetSessionsByQuery200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetSessionsByQuery200AllOf> | GetSessionsByQuery200AllOf)) => {
  return http.get('*/api/v1/admin/sessions', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetSessionsByQueryResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetSessionMockHandler = (overrideResponse?: GetSession200AllOf | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<GetSession200AllOf> | GetSession200AllOf)) => {
  return http.get('*/api/v1/admin/sessions/:sessionId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getGetSessionResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateSessionMockHandler = (overrideResponse?: UpdateSession200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<UpdateSession200AllOf> | UpdateSession200AllOf)) => {
  return http.patch('*/api/v1/admin/sessions/:sessionId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getUpdateSessionResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getDeleteSessionMockHandler = (overrideResponse?: DeleteSession200AllOf | ((info: Parameters<Parameters<typeof http.delete>[1]>[0]) => Promise<DeleteSession200AllOf> | DeleteSession200AllOf)) => {
  return http.delete('*/api/v1/admin/sessions/:sessionId', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getDeleteSessionResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveSessionsMockHandler = (overrideResponse?: RemoveSessions200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveSessions200AllOf> | RemoveSessions200AllOf)) => {
  return http.patch('*/api/v1/admin/sessions/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveSessionsResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveSessionMockHandler = (overrideResponse?: RemoveSession200AllOf | ((info: Parameters<Parameters<typeof http.patch>[1]>[0]) => Promise<RemoveSession200AllOf> | RemoveSession200AllOf)) => {
  return http.patch('*/api/v1/admin/sessions/:sessionId/removedAt', async (info) => {await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined 
            ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse) 
            : getRemoveSessionResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}
export const getPROMISEServerMock = () => [
  getCreateTimelineItemMockHandler(),
  getGetTimelineItemsByQueryMockHandler(),
  getGetTimelineItemMockHandler(),
  getUpdateTimelineItemMockHandler(),
  getDeleteTimelineItemMockHandler(),
  getRemoveTimelineItemsMockHandler(),
  getRemoveTimelineItemMockHandler(),
  getCreateAbilityMockHandler(),
  getGetAbilitiesByQueryMockHandler(),
  getGetAbilityMockHandler(),
  getRemoveAbilityMockHandler(),
  getDeleteAbilityMockHandler(),
  getRemoveAbilitiesMockHandler(),
  getGetCategoriesMockHandler(),
  getCreateCategoryMockHandler(),
  getFindCategoryByIdMockHandler(),
  getUpdateCategoryMockHandler(),
  getGetAllServiceMockHandler(),
  getCreateServiceMockHandler(),
  getGetServiceMockHandler(),
  getUpdateServiceMockHandler(),
  getDeleteServiceMockHandler(),
  getRemoveServiceMockHandler(),
  getRemoveServicesMockHandler(),
  getCreateSpaceMockHandler(),
  getGetSpacesByQueryMockHandler(),
  getGetSpaceMockHandler(),
  getUpdateSpaceMockHandler(),
  getDeleteSpaceMockHandler(),
  getRemoveSpacesMockHandler(),
  getRemoveSpaceMockHandler(),
  getGetAccessibleSpacesMockHandler(),
  getCreateGroupMockHandler(),
  getGetGroupsByQueryMockHandler(),
  getGetGroupMockHandler(),
  getUpdateGroupMockHandler(),
  getDeleteGroupMockHandler(),
  getRemoveGroupsMockHandler(),
  getCreateSubjectMockHandler(),
  getGetSubjectsByPageQueryMockHandler(),
  getGetSubjectByIdMockHandler(),
  getUpdateSubjectByIdMockHandler(),
  getRemoveSubjectByIdMockHandler(),
  getGetTokenMockHandler(),
  getGetCurrentUserMockHandler(),
  getGetNewTokenMockHandler(),
  getSignUpUserMockHandler(),
  getCreateSessionMockHandler(),
  getGetSessionsByQueryMockHandler(),
  getGetSessionMockHandler(),
  getUpdateSessionMockHandler(),
  getDeleteSessionMockHandler(),
  getRemoveSessionsMockHandler(),
  getRemoveSessionMockHandler()
]
