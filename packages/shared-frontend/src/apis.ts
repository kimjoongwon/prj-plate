/**
 * Generated by orval v7.4.1 üç∫
 * Do not edit manually.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult
} from '@tanstack/react-query'
import type {
  CreateAbility200AllOf,
  CreateAbilityDto,
  CreateAction200AllOf,
  CreateActionDto,
  CreateAssociation200AllOf,
  CreateAssociationDto,
  CreateCategory200AllOf,
  CreateCategoryDto,
  CreateClassification200AllOf,
  CreateClassificationDto,
  CreateDepot201AllOf,
  CreateDepotBody,
  CreateExercise200AllOf,
  CreateExerciseDto,
  CreateFile201AllOf,
  CreateFileDto,
  CreateGroupDto,
  CreateProgram200AllOf,
  CreateProgramDto,
  CreateRole200AllOf,
  CreateRoleDto,
  CreateRoutine200AllOf,
  CreateRoutineBody,
  CreateSession200AllOf,
  CreateSessionDto,
  CreateSpace200AllOf,
  CreateSpaceDto,
  CreateSubject200AllOf,
  CreateSubjectDto,
  CreateTenant200AllOf,
  CreateTenantDto,
  CreateTimeline200AllOf,
  CreateTimelineDto,
  CreateUser200AllOf,
  CreateUserDto,
  DeleteAbility200AllOf,
  DeleteAction200AllOf,
  DeleteAssociation200AllOf,
  DeleteCategory200AllOf,
  DeleteClassification200AllOf,
  DeleteDepot200AllOf,
  DeleteExercise200AllOf,
  DeleteGroup200AllOf,
  DeleteProgram200AllOf,
  DeleteRole200AllOf,
  DeleteRoutine200AllOf,
  DeleteSession200AllOf,
  DeleteSpace200AllOf,
  DeleteSubject200AllOf,
  DeleteTenant200AllOf,
  DeleteTimeline200AllOf,
  DeleteUser200AllOf,
  GetAbilitiesByQuery200AllOf,
  GetAbilitiesByQueryParams,
  GetAbility200AllOf,
  GetAction200AllOf,
  GetActionsByQuery200AllOf,
  GetActionsByQueryParams,
  GetAdminAuthLoginRoute200AllOf,
  GetAdminMainCategoriesEditPage200AllOf,
  GetAdminMainCategoriesPage200AllOf,
  GetAdminMainCategoryPage200AllOf,
  GetAdminMainExerciseEditPage200AllOf,
  GetAdminMainExercisesPage200AllOf,
  GetAdminMainGroupEditPage200AllOf,
  GetAdminMainGroupsPage200AllOf,
  GetAdminMainRoutineEditPage200AllOf,
  GetAdminMainRoutinesPage200AllOf,
  GetAdminMainServicesPage200AllOf,
  GetAdminMainSessionEditPage200AllOf,
  GetAdminMainSessionsPage200AllOf,
  GetAdminMainTaskEditPage200AllOf,
  GetAdminMainTasksPage200AllOf,
  GetAdminMainTenantsPage200AllOf,
  GetAdminMainTimelineEditPage200AllOf,
  GetAdminMainTimelinesPage200AllOf,
  GetAssociation200AllOf,
  GetAssociationsByQuery200AllOf,
  GetAssociationsByQueryParams,
  GetCategoriesByQuery200AllOf,
  GetCategoriesByQueryParams,
  GetCategoryById200AllOf,
  GetClassification200AllOf,
  GetClassificationsByQuery200AllOf,
  GetClassificationsByQueryParams,
  GetDepotById200AllOf,
  GetDepotsByQuery200AllOf,
  GetDepotsByQueryParams,
  GetExercise200AllOf,
  GetExercisesByQuery200AllOf,
  GetExercisesByQueryParams,
  GetFileById200AllOf,
  GetGroup200AllOf,
  GetGroupsByQuery200AllOf,
  GetGroupsByQueryParams,
  GetProgram200AllOf,
  GetProgramsByQuery200AllOf,
  GetProgramsByQueryParams,
  GetRole200AllOf,
  GetRolesByQuery200AllOf,
  GetRolesByQueryParams,
  GetRoutine200AllOf,
  GetRoutinesByQuery200AllOf,
  GetRoutinesByQueryParams,
  GetSession200AllOf,
  GetSessionsByQuery200AllOf,
  GetSessionsByQueryParams,
  GetSpace200AllOf,
  GetSpacesByQuery200AllOf,
  GetSpacesByQueryParams,
  GetSubject200AllOf,
  GetSubjectsByQuery200AllOf,
  GetSubjectsByQueryParams,
  GetTenantById200AllOf,
  GetTenantsByQuery200AllOf,
  GetTenantsByQueryParams,
  GetTimeline200AllOf,
  GetTimelinesByQuery200AllOf,
  GetTimelinesByQueryParams,
  GetToken200AllOf,
  GetUser200AllOf,
  GetUsersByQuery200AllOf,
  GetUsersByQueryParams,
  GroupDto,
  LoginPayloadDto,
  RemoveAbilities200AllOf,
  RemoveAbility200AllOf,
  RemoveAction200AllOf,
  RemoveActions200AllOf,
  RemoveAssociation200AllOf,
  RemoveAssociations200AllOf,
  RemoveClassification200AllOf,
  RemoveClassifications200AllOf,
  RemoveExercise200AllOf,
  RemoveFileById200AllOf,
  RemoveGroups200AllOf,
  RemoveProgram200AllOf,
  RemovePrograms200AllOf,
  RemoveRole200AllOf,
  RemoveRoutine200AllOf,
  RemoveRoutines200AllOf,
  RemoveSession200AllOf,
  RemoveSessions200AllOf,
  RemoveSpace200AllOf,
  RemoveSubject200AllOf,
  RemoveSubjects200AllOf,
  RemoveTenantById200AllOf,
  RemoveTimeline200AllOf,
  RemoveTimelines200AllOf,
  RemoveUser200AllOf,
  RemoveUsers200AllOf,
  SignUpPayloadDto,
  SignUpUser201AllOf,
  TokenDto,
  UpdateAbility200AllOf,
  UpdateAbilityDto,
  UpdateAction200AllOf,
  UpdateActionDto,
  UpdateAssociation200AllOf,
  UpdateAssociationDto,
  UpdateCategory200AllOf,
  UpdateCategoryDto,
  UpdateClassification200AllOf,
  UpdateClassificationDto,
  UpdateDepotById200AllOf,
  UpdateDepotByIdBody,
  UpdateExercise200AllOf,
  UpdateExerciseDto,
  UpdateFileById200AllOf,
  UpdateFileByIdBody,
  UpdateGroup200AllOf,
  UpdateGroupDto,
  UpdateProgram200AllOf,
  UpdateProgramDto,
  UpdateRole200AllOf,
  UpdateRoleDto,
  UpdateRoutine200AllOf,
  UpdateRoutineDto,
  UpdateSession200AllOf,
  UpdateSessionDto,
  UpdateSpace200AllOf,
  UpdateSpaceDto,
  UpdateSubject200AllOf,
  UpdateSubjectDto,
  UpdateTenantById200AllOf,
  UpdateTenantDto,
  UpdateTimeline200AllOf,
  UpdateTimelineDto,
  UpdateUser200AllOf,
  UpdateUserDto
} from './model'
import { customInstance } from './libs/customAxios';
import type { ErrorType, BodyType } from './libs/customAxios';



type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


export const createClassification = (
    createClassificationDto: BodyType<CreateClassificationDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateClassification200AllOf>(
      {url: `/api/v1/classifications`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createClassificationDto, signal
    },
      options);
    }
  


export const getCreateClassificationMutationOptions = <TData = Awaited<ReturnType<typeof createClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createClassification>>, {data: BodyType<CreateClassificationDto>}> = (props) => {
          const {data} = props ?? {};

          return  createClassification(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateClassificationDto>}, TContext>}

    export type CreateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof createClassification>>>
    export type CreateClassificationMutationBody = BodyType<CreateClassificationDto>
    export type CreateClassificationMutationError = ErrorType<void>

    export const useCreateClassification = <TData = Awaited<ReturnType<typeof createClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateClassificationDto>},
        TContext
      > => {

      const mutationOptions = getCreateClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getClassificationsByQuery = (
    params?: GetClassificationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetClassificationsByQuery200AllOf>(
      {url: `/api/v1/classifications`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetClassificationsByQueryQueryKey = (params?: GetClassificationsByQueryParams,) => {
    return [`/api/v1/classifications`, ...(params ? [params]: [])] as const;
    }

    
export const getGetClassificationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationsByQuery>>> = ({ signal }) => getClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetClassificationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationsByQuery>>>
export type GetClassificationsByQueryQueryError = ErrorType<void>


export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetClassificationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassificationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetClassificationsByQuery<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetClassificationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationsByQuery>>> = ({ signal }) => getClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetClassificationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationsByQuery>>>
export type GetClassificationsByQuerySuspenseQueryError = ErrorType<void>


export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetClassificationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetClassificationsByQuerySuspense<TData = Awaited<ReturnType<typeof getClassificationsByQuery>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetClassificationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassificationsByQuery>>> = ({ signal }) => getClassificationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetClassificationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClassificationsByQuery>>>
export type GetClassificationsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetClassificationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetClassificationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassificationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetClassificationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassificationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetClassificationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getClassification = (
    classificationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetClassificationQueryKey = (classificationId: string,) => {
    return [`/api/v1/classifications/${classificationId}`] as const;
    }

    
export const getGetClassificationQueryOptions = <TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationQueryKey(classificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassification>>> = ({ signal }) => getClassification(classificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(classificationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetClassificationQueryResult = NonNullable<Awaited<ReturnType<typeof getClassification>>>
export type GetClassificationQueryError = ErrorType<void>


export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassification>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getClassification>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetClassification<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetClassificationQueryOptions(classificationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationQueryKey(classificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassification>>> = ({ signal }) => getClassification(classificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetClassificationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getClassification>>>
export type GetClassificationSuspenseQueryError = ErrorType<void>


export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetClassificationSuspense<TData = Awaited<ReturnType<typeof getClassification>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetClassificationSuspenseQueryOptions(classificationId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetClassificationSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetClassificationQueryKey(classificationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getClassification>>> = ({ signal }) => getClassification(classificationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetClassificationSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getClassification>>>
export type GetClassificationSuspenseInfiniteQueryError = ErrorType<void>


export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetClassificationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getClassification>>>, TError = ErrorType<void>>(
 classificationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getClassification>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetClassificationSuspenseInfiniteQueryOptions(classificationId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateClassification = (
    classificationId: string,
    updateClassificationDto: BodyType<UpdateClassificationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateClassificationDto
    },
      options);
    }
  


export const getUpdateClassificationMutationOptions = <TData = Awaited<ReturnType<typeof updateClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{classificationId: string;data: BodyType<UpdateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateClassification>>, {classificationId: string;data: BodyType<UpdateClassificationDto>}> = (props) => {
          const {classificationId,data} = props ?? {};

          return  updateClassification(classificationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{classificationId: string;data: BodyType<UpdateClassificationDto>}, TContext>}

    export type UpdateClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateClassification>>>
    export type UpdateClassificationMutationBody = BodyType<UpdateClassificationDto>
    export type UpdateClassificationMutationError = ErrorType<void>

    export const useUpdateClassification = <TData = Awaited<ReturnType<typeof updateClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{classificationId: string;data: BodyType<UpdateClassificationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {classificationId: string;data: BodyType<UpdateClassificationDto>},
        TContext
      > => {

      const mutationOptions = getUpdateClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteClassification = (
    classificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteClassificationMutationOptions = <TData = Awaited<ReturnType<typeof deleteClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteClassification>>, {classificationId: string}> = (props) => {
          const {classificationId} = props ?? {};

          return  deleteClassification(classificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{classificationId: string}, TContext>}

    export type DeleteClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteClassification>>>
    
    export type DeleteClassificationMutationError = ErrorType<void>

    export const useDeleteClassification = <TData = Awaited<ReturnType<typeof deleteClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {classificationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeClassifications = (
    removeClassificationsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveClassifications200AllOf>(
      {url: `/api/v1/classifications/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeClassificationsBody
    },
      options);
    }
  


export const getRemoveClassificationsMutationOptions = <TData = Awaited<ReturnType<typeof removeClassifications>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeClassifications'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeClassifications>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeClassifications(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveClassificationsMutationResult = NonNullable<Awaited<ReturnType<typeof removeClassifications>>>
    export type RemoveClassificationsMutationBody = BodyType<string[]>
    export type RemoveClassificationsMutationError = ErrorType<void>

    export const useRemoveClassifications = <TData = Awaited<ReturnType<typeof removeClassifications>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveClassificationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeClassification = (
    classificationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveClassification200AllOf>(
      {url: `/api/v1/classifications/${classificationId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveClassificationMutationOptions = <TData = Awaited<ReturnType<typeof removeClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeClassification'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeClassification>>, {classificationId: string}> = (props) => {
          const {classificationId} = props ?? {};

          return  removeClassification(classificationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{classificationId: string}, TContext>}

    export type RemoveClassificationMutationResult = NonNullable<Awaited<ReturnType<typeof removeClassification>>>
    
    export type RemoveClassificationMutationError = ErrorType<void>

    export const useRemoveClassification = <TData = Awaited<ReturnType<typeof removeClassification>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{classificationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {classificationId: string},
        TContext
      > => {

      const mutationOptions = getRemoveClassificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAssociation = (
    createAssociationDto: BodyType<CreateAssociationDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateAssociation200AllOf>(
      {url: `/api/v1/associations`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAssociationDto, signal
    },
      options);
    }
  


export const getCreateAssociationMutationOptions = <TData = Awaited<ReturnType<typeof createAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createAssociation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssociation>>, {data: BodyType<CreateAssociationDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAssociation(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateAssociationDto>}, TContext>}

    export type CreateAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof createAssociation>>>
    export type CreateAssociationMutationBody = BodyType<CreateAssociationDto>
    export type CreateAssociationMutationError = ErrorType<void>

    export const useCreateAssociation = <TData = Awaited<ReturnType<typeof createAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateAssociationDto>},
        TContext
      > => {

      const mutationOptions = getCreateAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAssociationsByQuery = (
    params?: GetAssociationsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAssociationsByQuery200AllOf>(
      {url: `/api/v1/associations`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAssociationsByQueryQueryKey = (params?: GetAssociationsByQueryParams,) => {
    return [`/api/v1/associations`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAssociationsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociationsByQuery>>> = ({ signal }) => getAssociationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssociationsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociationsByQuery>>>
export type GetAssociationsByQueryQueryError = ErrorType<void>


export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAssociationsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociationsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssociationsByQuery<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssociationsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociationsByQuery>>> = ({ signal }) => getAssociationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssociationsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociationsByQuery>>>
export type GetAssociationsByQuerySuspenseQueryError = ErrorType<void>


export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAssociationsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssociationsByQuerySuspense<TData = Awaited<ReturnType<typeof getAssociationsByQuery>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssociationsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociationsByQuery>>> = ({ signal }) => getAssociationsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssociationsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociationsByQuery>>>
export type GetAssociationsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetAssociationsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssociationsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociationsByQuery>>>, TError = ErrorType<void>>(
 params?: GetAssociationsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociationsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssociationsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAssociation = (
    associationId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAssociationQueryKey = (associationId: string,) => {
    return [`/api/v1/associations/${associationId}`] as const;
    }

    
export const getGetAssociationQueryOptions = <TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationQueryKey(associationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociation>>> = ({ signal }) => getAssociation(associationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(associationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssociationQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociation>>>
export type GetAssociationQueryError = ErrorType<void>


export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociation>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAssociation>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssociation<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssociationQueryOptions(associationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationQueryKey(associationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociation>>> = ({ signal }) => getAssociation(associationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssociationSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociation>>>
export type GetAssociationSuspenseQueryError = ErrorType<void>


export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssociationSuspense<TData = Awaited<ReturnType<typeof getAssociation>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssociationSuspenseQueryOptions(associationId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAssociationSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssociationQueryKey(associationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssociation>>> = ({ signal }) => getAssociation(associationId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAssociationSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAssociation>>>
export type GetAssociationSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAssociationSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAssociation>>>, TError = ErrorType<void>>(
 associationId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAssociation>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAssociationSuspenseInfiniteQueryOptions(associationId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateAssociation = (
    associationId: string,
    updateAssociationDto: BodyType<UpdateAssociationDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateAssociationDto
    },
      options);
    }
  


export const getUpdateAssociationMutationOptions = <TData = Awaited<ReturnType<typeof updateAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{associationId: string;data: BodyType<UpdateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateAssociation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssociation>>, {associationId: string;data: BodyType<UpdateAssociationDto>}> = (props) => {
          const {associationId,data} = props ?? {};

          return  updateAssociation(associationId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{associationId: string;data: BodyType<UpdateAssociationDto>}, TContext>}

    export type UpdateAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssociation>>>
    export type UpdateAssociationMutationBody = BodyType<UpdateAssociationDto>
    export type UpdateAssociationMutationError = ErrorType<void>

    export const useUpdateAssociation = <TData = Awaited<ReturnType<typeof updateAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{associationId: string;data: BodyType<UpdateAssociationDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {associationId: string;data: BodyType<UpdateAssociationDto>},
        TContext
      > => {

      const mutationOptions = getUpdateAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAssociation = (
    associationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAssociationMutationOptions = <TData = Awaited<ReturnType<typeof deleteAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteAssociation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssociation>>, {associationId: string}> = (props) => {
          const {associationId} = props ?? {};

          return  deleteAssociation(associationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{associationId: string}, TContext>}

    export type DeleteAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssociation>>>
    
    export type DeleteAssociationMutationError = ErrorType<void>

    export const useDeleteAssociation = <TData = Awaited<ReturnType<typeof deleteAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {associationId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAssociations = (
    removeAssociationsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAssociations200AllOf>(
      {url: `/api/v1/associations/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeAssociationsBody
    },
      options);
    }
  


export const getRemoveAssociationsMutationOptions = <TData = Awaited<ReturnType<typeof removeAssociations>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeAssociations'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAssociations>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeAssociations(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveAssociationsMutationResult = NonNullable<Awaited<ReturnType<typeof removeAssociations>>>
    export type RemoveAssociationsMutationBody = BodyType<string[]>
    export type RemoveAssociationsMutationError = ErrorType<void>

    export const useRemoveAssociations = <TData = Awaited<ReturnType<typeof removeAssociations>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveAssociationsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAssociation = (
    associationId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAssociation200AllOf>(
      {url: `/api/v1/associations/${associationId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveAssociationMutationOptions = <TData = Awaited<ReturnType<typeof removeAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeAssociation'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAssociation>>, {associationId: string}> = (props) => {
          const {associationId} = props ?? {};

          return  removeAssociation(associationId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{associationId: string}, TContext>}

    export type RemoveAssociationMutationResult = NonNullable<Awaited<ReturnType<typeof removeAssociation>>>
    
    export type RemoveAssociationMutationError = ErrorType<void>

    export const useRemoveAssociation = <TData = Awaited<ReturnType<typeof removeAssociation>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{associationId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {associationId: string},
        TContext
      > => {

      const mutationOptions = getRemoveAssociationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAppBuilder = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/builder`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAppBuilderQueryKey = () => {
    return [`/api/v1/builder`] as const;
    }

    
export const getGetAppBuilderQueryOptions = <TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({ signal }) => getAppBuilder(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAppBuilderQueryResult = NonNullable<Awaited<ReturnType<typeof getAppBuilder>>>
export type GetAppBuilderQueryError = ErrorType<void>


export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppBuilder>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppBuilder>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAppBuilder<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAppBuilderQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAppBuilderSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({ signal }) => getAppBuilder(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAppBuilderSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAppBuilder>>>
export type GetAppBuilderSuspenseQueryError = ErrorType<void>


export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAppBuilderSuspense<TData = Awaited<ReturnType<typeof getAppBuilder>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAppBuilderSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAppBuilderSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({ signal }) => getAppBuilder(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAppBuilderSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAppBuilder>>>
export type GetAppBuilderSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAppBuilderSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAppBuilderSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getCategoriesByQuery = (
    params: GetCategoriesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategoriesByQuery200AllOf>(
      {url: `/api/v1/categories`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetCategoriesByQueryQueryKey = (params: GetCategoriesByQueryParams,) => {
    return [`/api/v1/categories`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCategoriesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCategoriesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQueryQueryError = ErrorType<void>


export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCategoriesByQuery<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCategoriesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCategoriesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQuerySuspenseQueryError = ErrorType<void>


export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCategoriesByQuerySuspense<TData = Awaited<ReturnType<typeof getCategoriesByQuery>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCategoriesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoriesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoriesByQuery>>> = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCategoriesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoriesByQuery>>>
export type GetCategoriesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCategoriesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>, TError = ErrorType<void>>(
 params: GetCategoriesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoriesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCategoriesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createCategory = (
    createCategoryDto: BodyType<CreateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateCategory200AllOf>(
      {url: `/api/v1/categories`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCategoryDto, signal
    },
      options);
    }
  


export const getCreateCategoryMutationOptions = <TData = Awaited<ReturnType<typeof createCategory>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCategory>>, {data: BodyType<CreateCategoryDto>}> = (props) => {
          const {data} = props ?? {};

          return  createCategory(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateCategoryDto>}, TContext>}

    export type CreateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof createCategory>>>
    export type CreateCategoryMutationBody = BodyType<CreateCategoryDto>
    export type CreateCategoryMutationError = ErrorType<void>

    export const useCreateCategory = <TData = Awaited<ReturnType<typeof createCategory>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getCreateCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getCategoryById = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetCategoryById200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetCategoryByIdQueryKey = (categoryId: string,) => {
    return [`/api/v1/categories/${categoryId}`] as const;
    }

    
export const getGetCategoryByIdQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCategoryByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdQueryError = ErrorType<void>


export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCategoryById<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCategoryByIdQueryOptions(categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCategoryByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdSuspenseQueryError = ErrorType<void>


export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCategoryByIdSuspense<TData = Awaited<ReturnType<typeof getCategoryById>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCategoryByIdSuspenseQueryOptions(categoryId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetCategoryByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({ signal }) => getCategoryById(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetCategoryByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getCategoryById>>>
export type GetCategoryByIdSuspenseInfiniteQueryError = ErrorType<void>


export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetCategoryByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getCategoryById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetCategoryByIdSuspenseInfiniteQueryOptions(categoryId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateCategory = (
    categoryId: string,
    updateCategoryDto: BodyType<UpdateCategoryDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateCategory200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateCategoryDto
    },
      options);
    }
  


export const getUpdateCategoryMutationOptions = <TData = Awaited<ReturnType<typeof updateCategory>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCategory>>, {categoryId: string;data: BodyType<UpdateCategoryDto>}> = (props) => {
          const {categoryId,data} = props ?? {};

          return  updateCategory(categoryId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>}

    export type UpdateCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof updateCategory>>>
    export type UpdateCategoryMutationBody = BodyType<UpdateCategoryDto>
    export type UpdateCategoryMutationError = ErrorType<void>

    export const useUpdateCategory = <TData = Awaited<ReturnType<typeof updateCategory>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{categoryId: string;data: BodyType<UpdateCategoryDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {categoryId: string;data: BodyType<UpdateCategoryDto>},
        TContext
      > => {

      const mutationOptions = getUpdateCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteCategory = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteCategory200AllOf>(
      {url: `/api/v1/categories/${categoryId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteCategoryMutationOptions = <TData = Awaited<ReturnType<typeof deleteCategory>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{categoryId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteCategory'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCategory>>, {categoryId: string}> = (props) => {
          const {categoryId} = props ?? {};

          return  deleteCategory(categoryId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{categoryId: string}, TContext>}

    export type DeleteCategoryMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCategory>>>
    
    export type DeleteCategoryMutationError = ErrorType<void>

    export const useDeleteCategory = <TData = Awaited<ReturnType<typeof deleteCategory>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{categoryId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {categoryId: string},
        TContext
      > => {

      const mutationOptions = getDeleteCategoryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createGroup = (
    createGroupDto: BodyType<CreateGroupDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GroupDto>(
      {url: `/api/v1/groups`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createGroupDto, signal
    },
      options);
    }
  


export const getCreateGroupMutationOptions = <TData = Awaited<ReturnType<typeof createGroup>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createGroup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createGroup>>, {data: BodyType<CreateGroupDto>}> = (props) => {
          const {data} = props ?? {};

          return  createGroup(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateGroupDto>}, TContext>}

    export type CreateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof createGroup>>>
    export type CreateGroupMutationBody = BodyType<CreateGroupDto>
    export type CreateGroupMutationError = ErrorType<void>

    export const useCreateGroup = <TData = Awaited<ReturnType<typeof createGroup>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateGroupDto>},
        TContext
      > => {

      const mutationOptions = getCreateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getGroupsByQuery = (
    params?: GetGroupsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroupsByQuery200AllOf>(
      {url: `/api/v1/groups`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetGroupsByQueryQueryKey = (params?: GetGroupsByQueryParams,) => {
    return [`/api/v1/groups`, ...(params ? [params]: [])] as const;
    }

    
export const getGetGroupsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGroupsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQueryQueryError = ErrorType<unknown>


export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroupsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetGroupsByQuery<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGroupsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGroupsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseQueryError = ErrorType<unknown>


export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroupsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetGroupsByQuerySuspense<TData = Awaited<ReturnType<typeof getGroupsByQuery>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGroupsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroupsByQuery>>> = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGroupsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroupsByQuery>>>
export type GetGroupsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params: undefined |  GetGroupsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetGroupsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>, TError = ErrorType<unknown>>(
 params?: GetGroupsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroupsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGroupsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetGroupQueryKey = (groupId: string,) => {
    return [`/api/v1/groups/${groupId}`] as const;
    }

    
export const getGetGroupQueryOptions = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGroupQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupQueryError = ErrorType<unknown>


export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroup>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroup>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetGroup<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGroupQueryOptions(groupId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGroupSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupSuspenseQueryError = ErrorType<unknown>


export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetGroupSuspense<TData = Awaited<ReturnType<typeof getGroup>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGroupSuspenseQueryOptions(groupId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetGroupSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({ signal }) => getGroup(groupId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetGroupSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getGroup>>>
export type GetGroupSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetGroupSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>, TError = ErrorType<unknown>>(
 groupId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetGroupSuspenseInfiniteQueryOptions(groupId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateGroup = (
    groupId: string,
    updateGroupDto: BodyType<UpdateGroupDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateGroupDto
    },
      options);
    }
  


export const getUpdateGroupMutationOptions = <TData = Awaited<ReturnType<typeof updateGroup>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateGroup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateGroup>>, {groupId: string;data: BodyType<UpdateGroupDto>}> = (props) => {
          const {groupId,data} = props ?? {};

          return  updateGroup(groupId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>}

    export type UpdateGroupMutationResult = NonNullable<Awaited<ReturnType<typeof updateGroup>>>
    export type UpdateGroupMutationBody = BodyType<UpdateGroupDto>
    export type UpdateGroupMutationError = ErrorType<unknown>

    export const useUpdateGroup = <TData = Awaited<ReturnType<typeof updateGroup>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{groupId: string;data: BodyType<UpdateGroupDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {groupId: string;data: BodyType<UpdateGroupDto>},
        TContext
      > => {

      const mutationOptions = getUpdateGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteGroup = (
    groupId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteGroup200AllOf>(
      {url: `/api/v1/groups/${groupId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteGroupMutationOptions = <TData = Awaited<ReturnType<typeof deleteGroup>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteGroup'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteGroup>>, {groupId: string}> = (props) => {
          const {groupId} = props ?? {};

          return  deleteGroup(groupId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{groupId: string}, TContext>}

    export type DeleteGroupMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGroup>>>
    
    export type DeleteGroupMutationError = ErrorType<unknown>

    export const useDeleteGroup = <TData = Awaited<ReturnType<typeof deleteGroup>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{groupId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {groupId: string},
        TContext
      > => {

      const mutationOptions = getDeleteGroupMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeGroups = (
    groupIds: string[],
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveGroups200AllOf>(
      {url: `/api/v1/groups/${groupIds}`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveGroupsMutationOptions = <TData = Awaited<ReturnType<typeof removeGroups>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeGroups'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeGroups>>, {groupIds: string[]}> = (props) => {
          const {groupIds} = props ?? {};

          return  removeGroups(groupIds,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{groupIds: string[]}, TContext>}

    export type RemoveGroupsMutationResult = NonNullable<Awaited<ReturnType<typeof removeGroups>>>
    
    export type RemoveGroupsMutationError = ErrorType<unknown>

    export const useRemoveGroups = <TData = Awaited<ReturnType<typeof removeGroups>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{groupIds: string[]}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {groupIds: string[]},
        TContext
      > => {

      const mutationOptions = getRemoveGroupsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSpace = (
    createSpaceDto: BodyType<CreateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSpace200AllOf>(
      {url: `/api/v1/spaces`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSpaceDto, signal
    },
      options);
    }
  


export const getCreateSpaceMutationOptions = <TData = Awaited<ReturnType<typeof createSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSpace>>, {data: BodyType<CreateSpaceDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSpace(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateSpaceDto>}, TContext>}

    export type CreateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof createSpace>>>
    export type CreateSpaceMutationBody = BodyType<CreateSpaceDto>
    export type CreateSpaceMutationError = ErrorType<void>

    export const useCreateSpace = <TData = Awaited<ReturnType<typeof createSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getCreateSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSpacesByQuery = (
    params?: GetSpacesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpacesByQuery200AllOf>(
      {url: `/api/v1/spaces`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSpacesByQueryQueryKey = (params?: GetSpacesByQueryParams,) => {
    return [`/api/v1/spaces`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSpacesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSpacesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQueryQueryError = ErrorType<void>


export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSpacesByQuery<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSpacesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSpacesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseQueryError = ErrorType<void>


export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSpacesByQuerySuspense<TData = Awaited<ReturnType<typeof getSpacesByQuery>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSpacesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpacesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpacesByQuery>>> = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSpacesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpacesByQuery>>>
export type GetSpacesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetSpacesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSpacesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>, TError = ErrorType<void>>(
 params?: GetSpacesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpacesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSpacesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSpaceQueryKey = (spaceId: string,) => {
    return [`/api/v1/spaces/${spaceId}`] as const;
    }

    
export const getGetSpaceQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(spaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSpaceQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceQueryError = ErrorType<void>


export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSpace<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSpaceQueryOptions(spaceId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSpaceSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseQueryError = ErrorType<void>


export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSpaceSuspense<TData = Awaited<ReturnType<typeof getSpace>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSpaceSuspenseQueryOptions(spaceId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSpaceSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({ signal }) => getSpace(spaceId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSpaceSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSpace>>>
export type GetSpaceSuspenseInfiniteQueryError = ErrorType<void>


export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSpaceSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>, TError = ErrorType<void>>(
 spaceId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSpaceSuspenseInfiniteQueryOptions(spaceId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSpace = (
    spaceId: string,
    updateSpaceDto: BodyType<UpdateSpaceDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSpaceDto
    },
      options);
    }
  


export const getUpdateSpaceMutationOptions = <TData = Awaited<ReturnType<typeof updateSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSpace>>, {spaceId: string;data: BodyType<UpdateSpaceDto>}> = (props) => {
          const {spaceId,data} = props ?? {};

          return  updateSpace(spaceId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>}

    export type UpdateSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof updateSpace>>>
    export type UpdateSpaceMutationBody = BodyType<UpdateSpaceDto>
    export type UpdateSpaceMutationError = ErrorType<void>

    export const useUpdateSpace = <TData = Awaited<ReturnType<typeof updateSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{spaceId: string;data: BodyType<UpdateSpaceDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {spaceId: string;data: BodyType<UpdateSpaceDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSpaceMutationOptions = <TData = Awaited<ReturnType<typeof deleteSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  deleteSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{spaceId: string}, TContext>}

    export type DeleteSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSpace>>>
    
    export type DeleteSpaceMutationError = ErrorType<void>

    export const useDeleteSpace = <TData = Awaited<ReturnType<typeof deleteSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSpace = (
    spaceId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSpace200AllOf>(
      {url: `/api/v1/spaces/${spaceId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSpaceMutationOptions = <TData = Awaited<ReturnType<typeof removeSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeSpace'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSpace>>, {spaceId: string}> = (props) => {
          const {spaceId} = props ?? {};

          return  removeSpace(spaceId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{spaceId: string}, TContext>}

    export type RemoveSpaceMutationResult = NonNullable<Awaited<ReturnType<typeof removeSpace>>>
    
    export type RemoveSpaceMutationError = ErrorType<void>

    export const useRemoveSpace = <TData = Awaited<ReturnType<typeof removeSpace>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{spaceId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {spaceId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSpaceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createUser = (
    createUserDto: BodyType<CreateUserDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateUser200AllOf>(
      {url: `/api/v1/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      options);
    }
  


export const getCreateUserMutationOptions = <TData = Awaited<ReturnType<typeof createUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: BodyType<CreateUserDto>}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateUserDto>}, TContext>}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = BodyType<CreateUserDto>
    export type CreateUserMutationError = ErrorType<void>

    export const useCreateUser = <TData = Awaited<ReturnType<typeof createUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateUserDto>},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getUsersByQuery = (
    params?: GetUsersByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUsersByQuery200AllOf>(
      {url: `/api/v1/users`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetUsersByQueryQueryKey = (params?: GetUsersByQueryParams,) => {
    return [`/api/v1/users`, ...(params ? [params]: [])] as const;
    }

    
export const getGetUsersByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUsersByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQueryQueryError = ErrorType<void>


export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUsersByQuery<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUsersByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUsersByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQuerySuspenseQueryError = ErrorType<void>


export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUsersByQuerySuspense<TData = Awaited<ReturnType<typeof getUsersByQuery>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUsersByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUsersByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({ signal }) => getUsersByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUsersByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersByQuery>>>
export type GetUsersByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetUsersByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUsersByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>, TError = ErrorType<void>>(
 params?: GetUsersByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUsersByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUsersByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserQueryKey = (userId: string,) => {
    return [`/api/v1/users/${userId}`] as const;
    }

    
export const getGetUserQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserQueryError = ErrorType<void>


export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseQueryError = ErrorType<void>


export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserSuspenseQueryOptions(userId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetUserSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) => getUser(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetUserSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>
export type GetUserSuspenseInfiniteQueryError = ErrorType<void>


export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetUserSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>, TError = ErrorType<void>>(
 userId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetUserSuspenseInfiniteQueryOptions(userId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateUser = (
    userId: string,
    updateUserDto: BodyType<UpdateUserDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateUserDto
    },
      options);
    }
  


export const getUpdateUserMutationOptions = <TData = Awaited<ReturnType<typeof updateUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {userId: string;data: BodyType<UpdateUserDto>}> = (props) => {
          const {userId,data} = props ?? {};

          return  updateUser(userId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = BodyType<UpdateUserDto>
    export type UpdateUserMutationError = ErrorType<void>

    export const useUpdateUser = <TData = Awaited<ReturnType<typeof updateUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {userId: string;data: BodyType<UpdateUserDto>},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteUser200AllOf>(
      {url: `/api/v1/users/${userId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteUserMutationOptions = <TData = Awaited<ReturnType<typeof deleteUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  deleteUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{userId: string}, TContext>}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = ErrorType<void>

    export const useDeleteUser = <TData = Awaited<ReturnType<typeof deleteUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeUsers = (
    removeUsersBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveUsers200AllOf>(
      {url: `/api/v1/users/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeUsersBody
    },
      options);
    }
  


export const getRemoveUsersMutationOptions = <TData = Awaited<ReturnType<typeof removeUsers>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeUsers'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUsers>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeUsers(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveUsersMutationResult = NonNullable<Awaited<ReturnType<typeof removeUsers>>>
    export type RemoveUsersMutationBody = BodyType<string[]>
    export type RemoveUsersMutationError = ErrorType<void>

    export const useRemoveUsers = <TData = Awaited<ReturnType<typeof removeUsers>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveUsersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeUser = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveUser200AllOf>(
      {url: `/api/v1/users/${userId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveUserMutationOptions = <TData = Awaited<ReturnType<typeof removeUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  removeUser(userId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{userId: string}, TContext>}

    export type RemoveUserMutationResult = NonNullable<Awaited<ReturnType<typeof removeUser>>>
    
    export type RemoveUserMutationError = ErrorType<void>

    export const useRemoveUser = <TData = Awaited<ReturnType<typeof removeUser>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{userId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {userId: string},
        TContext
      > => {

      const mutationOptions = getRemoveUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getToken = (
    loginPayloadDto: BodyType<LoginPayloadDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetToken200AllOf>(
      {url: `/api/v1/auth/token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginPayloadDto, signal
    },
      options);
    }
  


export const getGetTokenMutationOptions = <TData = Awaited<ReturnType<typeof getToken>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['getToken'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getToken>>, {data: BodyType<LoginPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  getToken(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<LoginPayloadDto>}, TContext>}

    export type GetTokenMutationResult = NonNullable<Awaited<ReturnType<typeof getToken>>>
    export type GetTokenMutationBody = BodyType<LoginPayloadDto>
    export type GetTokenMutationError = ErrorType<unknown>

    export const useGetToken = <TData = Awaited<ReturnType<typeof getToken>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<LoginPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<LoginPayloadDto>},
        TContext
      > => {

      const mutationOptions = getGetTokenMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getNewToken = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<TokenDto>(
      {url: `/api/v1/auth/new-token`, method: 'GET', signal
    },
      options);
    }
  

export const getGetNewTokenQueryKey = () => {
    return [`/api/v1/auth/new-token`] as const;
    }

    
export const getGetNewTokenQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNewTokenQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenQueryError = ErrorType<void>


export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetNewToken<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNewTokenQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNewTokenSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseQueryError = ErrorType<void>


export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetNewTokenSuspense<TData = Awaited<ReturnType<typeof getNewToken>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNewTokenSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetNewTokenSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({ signal }) => getNewToken(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetNewTokenSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getNewToken>>>
export type GetNewTokenSuspenseInfiniteQueryError = ErrorType<void>


export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetNewTokenSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetNewTokenSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const signUpUser = (
    signUpPayloadDto: BodyType<SignUpPayloadDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<SignUpUser201AllOf>(
      {url: `/api/v1/auth/sign-up`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signUpPayloadDto, signal
    },
      options);
    }
  


export const getSignUpUserMutationOptions = <TData = Awaited<ReturnType<typeof signUpUser>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['signUpUser'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUpUser>>, {data: BodyType<SignUpPayloadDto>}> = (props) => {
          const {data} = props ?? {};

          return  signUpUser(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<SignUpPayloadDto>}, TContext>}

    export type SignUpUserMutationResult = NonNullable<Awaited<ReturnType<typeof signUpUser>>>
    export type SignUpUserMutationBody = BodyType<SignUpPayloadDto>
    export type SignUpUserMutationError = ErrorType<unknown>

    export const useSignUpUser = <TData = Awaited<ReturnType<typeof signUpUser>>, TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<SignUpPayloadDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<SignUpPayloadDto>},
        TContext
      > => {

      const mutationOptions = getSignUpUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createRole = (
    createRoleDto: BodyType<CreateRoleDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateRole200AllOf>(
      {url: `/api/v1/roles`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createRoleDto, signal
    },
      options);
    }
  


export const getCreateRoleMutationOptions = <TData = Awaited<ReturnType<typeof createRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRole>>, {data: BodyType<CreateRoleDto>}> = (props) => {
          const {data} = props ?? {};

          return  createRole(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateRoleDto>}, TContext>}

    export type CreateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createRole>>>
    export type CreateRoleMutationBody = BodyType<CreateRoleDto>
    export type CreateRoleMutationError = ErrorType<void>

    export const useCreateRole = <TData = Awaited<ReturnType<typeof createRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateRoleDto>},
        TContext
      > => {

      const mutationOptions = getCreateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getRolesByQuery = (
    params?: GetRolesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRolesByQuery200AllOf>(
      {url: `/api/v1/roles`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRolesByQueryQueryKey = (params?: GetRolesByQueryParams,) => {
    return [`/api/v1/roles`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRolesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRolesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQueryQueryError = ErrorType<void>


export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRolesByQuery<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRolesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRolesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRolesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQuerySuspenseQueryError = ErrorType<void>


export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRolesByQuerySuspense<TData = Awaited<ReturnType<typeof getRolesByQuery>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRolesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRolesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({ signal }) => getRolesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRolesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRolesByQuery>>>
export type GetRolesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetRolesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRolesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRolesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRolesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRolesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoleQueryKey = (roleId: string,) => {
    return [`/api/v1/roles/${roleId}`] as const;
    }

    
export const getGetRoleQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(roleId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleQueryError = ErrorType<void>


export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRole<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleQueryOptions(roleId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseQueryError = ErrorType<void>


export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoleSuspense<TData = Awaited<ReturnType<typeof getRole>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleSuspenseQueryOptions(roleId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoleSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({ signal }) => getRole(roleId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoleSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRole>>>
export type GetRoleSuspenseInfiniteQueryError = ErrorType<void>


export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoleSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>, TError = ErrorType<void>>(
 roleId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoleSuspenseInfiniteQueryOptions(roleId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateRole = (
    roleId: string,
    updateRoleDto: BodyType<UpdateRoleDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateRoleDto
    },
      options);
    }
  


export const getUpdateRoleMutationOptions = <TData = Awaited<ReturnType<typeof updateRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {roleId: string;data: BodyType<UpdateRoleDto>}> = (props) => {
          const {roleId,data} = props ?? {};

          return  updateRole(roleId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = BodyType<UpdateRoleDto>
    export type UpdateRoleMutationError = ErrorType<void>

    export const useUpdateRole = <TData = Awaited<ReturnType<typeof updateRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{roleId: string;data: BodyType<UpdateRoleDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {roleId: string;data: BodyType<UpdateRoleDto>},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteRole200AllOf>(
      {url: `/api/v1/roles/${roleId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoleMutationOptions = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  deleteRole(roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{roleId: string}, TContext>}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = ErrorType<void>

    export const useDeleteRole = <TData = Awaited<ReturnType<typeof deleteRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeRole = (
    roleId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveRole200AllOf>(
      {url: `/api/v1/roles/${roleId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveRoleMutationOptions = <TData = Awaited<ReturnType<typeof removeRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeRole'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRole>>, {roleId: string}> = (props) => {
          const {roleId} = props ?? {};

          return  removeRole(roleId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{roleId: string}, TContext>}

    export type RemoveRoleMutationResult = NonNullable<Awaited<ReturnType<typeof removeRole>>>
    
    export type RemoveRoleMutationError = ErrorType<void>

    export const useRemoveRole = <TData = Awaited<ReturnType<typeof removeRole>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{roleId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {roleId: string},
        TContext
      > => {

      const mutationOptions = getRemoveRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAction = (
    createActionDto: BodyType<CreateActionDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateAction200AllOf>(
      {url: `/api/v1/actions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createActionDto, signal
    },
      options);
    }
  


export const getCreateActionMutationOptions = <TData = Awaited<ReturnType<typeof createAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAction>>, {data: BodyType<CreateActionDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAction(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateActionDto>}, TContext>}

    export type CreateActionMutationResult = NonNullable<Awaited<ReturnType<typeof createAction>>>
    export type CreateActionMutationBody = BodyType<CreateActionDto>
    export type CreateActionMutationError = ErrorType<void>

    export const useCreateAction = <TData = Awaited<ReturnType<typeof createAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateActionDto>},
        TContext
      > => {

      const mutationOptions = getCreateActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getActionsByQuery = (
    params?: GetActionsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetActionsByQuery200AllOf>(
      {url: `/api/v1/actions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetActionsByQueryQueryKey = (params?: GetActionsByQueryParams,) => {
    return [`/api/v1/actions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetActionsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsByQuery>>> = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActionsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsByQuery>>>
export type GetActionsByQueryQueryError = ErrorType<void>


export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetActionsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActionsByQuery<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActionsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsByQuery>>> = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActionsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsByQuery>>>
export type GetActionsByQuerySuspenseQueryError = ErrorType<void>


export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetActionsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActionsByQuerySuspense<TData = Awaited<ReturnType<typeof getActionsByQuery>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActionsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsByQuery>>> = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActionsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsByQuery>>>
export type GetActionsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetActionsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetActionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getActionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActionsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAction = (
    actionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAction200AllOf>(
      {url: `/api/v1/actions/${actionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetActionQueryKey = (actionId: string,) => {
    return [`/api/v1/actions/${actionId}`] as const;
    }

    
export const getGetActionQueryOptions = <TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(actionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActionQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionQueryError = ErrorType<void>


export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAction<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActionQueryOptions(actionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionSuspenseQueryError = ErrorType<void>


export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActionSuspense<TData = Awaited<ReturnType<typeof getAction>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActionSuspenseQueryOptions(actionId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetActionSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({ signal }) => getAction(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetActionSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAction>>>
export type GetActionSuspenseInfiniteQueryError = ErrorType<void>


export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetActionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>, TError = ErrorType<void>>(
 actionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetActionSuspenseInfiniteQueryOptions(actionId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateAction = (
    actionId: string,
    updateActionDto: BodyType<UpdateActionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAction200AllOf>(
      {url: `/api/v1/actions/${actionId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateActionDto
    },
      options);
    }
  


export const getUpdateActionMutationOptions = <TData = Awaited<ReturnType<typeof updateAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{actionId: string;data: BodyType<UpdateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAction>>, {actionId: string;data: BodyType<UpdateActionDto>}> = (props) => {
          const {actionId,data} = props ?? {};

          return  updateAction(actionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{actionId: string;data: BodyType<UpdateActionDto>}, TContext>}

    export type UpdateActionMutationResult = NonNullable<Awaited<ReturnType<typeof updateAction>>>
    export type UpdateActionMutationBody = BodyType<UpdateActionDto>
    export type UpdateActionMutationError = ErrorType<void>

    export const useUpdateAction = <TData = Awaited<ReturnType<typeof updateAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{actionId: string;data: BodyType<UpdateActionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {actionId: string;data: BodyType<UpdateActionDto>},
        TContext
      > => {

      const mutationOptions = getUpdateActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAction = (
    actionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAction200AllOf>(
      {url: `/api/v1/actions/${actionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteActionMutationOptions = <TData = Awaited<ReturnType<typeof deleteAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAction>>, {actionId: string}> = (props) => {
          const {actionId} = props ?? {};

          return  deleteAction(actionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{actionId: string}, TContext>}

    export type DeleteActionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAction>>>
    
    export type DeleteActionMutationError = ErrorType<void>

    export const useDeleteAction = <TData = Awaited<ReturnType<typeof deleteAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {actionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeActions = (
    removeActionsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveActions200AllOf>(
      {url: `/api/v1/actions/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeActionsBody
    },
      options);
    }
  


export const getRemoveActionsMutationOptions = <TData = Awaited<ReturnType<typeof removeActions>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeActions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeActions>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeActions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveActionsMutationResult = NonNullable<Awaited<ReturnType<typeof removeActions>>>
    export type RemoveActionsMutationBody = BodyType<string[]>
    export type RemoveActionsMutationError = ErrorType<void>

    export const useRemoveActions = <TData = Awaited<ReturnType<typeof removeActions>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveActionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAction = (
    actionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAction200AllOf>(
      {url: `/api/v1/actions/${actionId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveActionMutationOptions = <TData = Awaited<ReturnType<typeof removeAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeAction'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAction>>, {actionId: string}> = (props) => {
          const {actionId} = props ?? {};

          return  removeAction(actionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{actionId: string}, TContext>}

    export type RemoveActionMutationResult = NonNullable<Awaited<ReturnType<typeof removeAction>>>
    
    export type RemoveActionMutationError = ErrorType<void>

    export const useRemoveAction = <TData = Awaited<ReturnType<typeof removeAction>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{actionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {actionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveActionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createAbility = (
    createAbilityDto: BodyType<CreateAbilityDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateAbility200AllOf>(
      {url: `/api/v1/abilities`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAbilityDto, signal
    },
      options);
    }
  


export const getCreateAbilityMutationOptions = <TData = Awaited<ReturnType<typeof createAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createAbility'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAbility>>, {data: BodyType<CreateAbilityDto>}> = (props) => {
          const {data} = props ?? {};

          return  createAbility(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateAbilityDto>}, TContext>}

    export type CreateAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof createAbility>>>
    export type CreateAbilityMutationBody = BodyType<CreateAbilityDto>
    export type CreateAbilityMutationError = ErrorType<void>

    export const useCreateAbility = <TData = Awaited<ReturnType<typeof createAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateAbilityDto>},
        TContext
      > => {

      const mutationOptions = getCreateAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAbilitiesByQuery = (
    params?: GetAbilitiesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAbilitiesByQuery200AllOf>(
      {url: `/api/v1/abilities`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetAbilitiesByQueryQueryKey = (params?: GetAbilitiesByQueryParams,) => {
    return [`/api/v1/abilities`, ...(params ? [params]: [])] as const;
    }

    
export const getGetAbilitiesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAbilitiesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQueryQueryError = ErrorType<void>


export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAbilitiesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbilitiesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbilitiesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAbilitiesByQuery<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAbilitiesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitiesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAbilitiesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQuerySuspenseQueryError = ErrorType<void>


export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetAbilitiesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAbilitiesByQuerySuspense<TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAbilitiesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitiesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbilitiesByQuery>>> = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAbilitiesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAbilitiesByQuery>>>
export type GetAbilitiesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetAbilitiesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAbilitiesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>, TError = ErrorType<void>>(
 params?: GetAbilitiesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbilitiesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAbilitiesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAbilityQueryKey = (abilityId: string,) => {
    return [`/api/v1/abilities/${abilityId}`] as const;
    }

    
export const getGetAbilityQueryOptions = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(abilityId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAbilityQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilityQueryError = ErrorType<void>


export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbility>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbility>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAbility<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAbilityQueryOptions(abilityId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAbilitySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilitySuspenseQueryError = ErrorType<void>


export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAbilitySuspense<TData = Awaited<ReturnType<typeof getAbility>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAbilitySuspenseQueryOptions(abilityId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAbilitySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({ signal }) => getAbility(abilityId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAbilitySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAbility>>>
export type GetAbilitySuspenseInfiniteQueryError = ErrorType<void>


export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAbilitySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>, TError = ErrorType<void>>(
 abilityId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAbilitySuspenseInfiniteQueryOptions(abilityId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateAbility = (
    abilityId: string,
    updateAbilityDto: BodyType<UpdateAbilityDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateAbilityDto
    },
      options);
    }
  


export const getUpdateAbilityMutationOptions = <TData = Awaited<ReturnType<typeof updateAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{abilityId: string;data: BodyType<UpdateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateAbility'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAbility>>, {abilityId: string;data: BodyType<UpdateAbilityDto>}> = (props) => {
          const {abilityId,data} = props ?? {};

          return  updateAbility(abilityId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{abilityId: string;data: BodyType<UpdateAbilityDto>}, TContext>}

    export type UpdateAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof updateAbility>>>
    export type UpdateAbilityMutationBody = BodyType<UpdateAbilityDto>
    export type UpdateAbilityMutationError = ErrorType<void>

    export const useUpdateAbility = <TData = Awaited<ReturnType<typeof updateAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{abilityId: string;data: BodyType<UpdateAbilityDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {abilityId: string;data: BodyType<UpdateAbilityDto>},
        TContext
      > => {

      const mutationOptions = getUpdateAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteAbilityMutationOptions = <TData = Awaited<ReturnType<typeof deleteAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteAbility'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAbility>>, {abilityId: string}> = (props) => {
          const {abilityId} = props ?? {};

          return  deleteAbility(abilityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{abilityId: string}, TContext>}

    export type DeleteAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAbility>>>
    
    export type DeleteAbilityMutationError = ErrorType<void>

    export const useDeleteAbility = <TData = Awaited<ReturnType<typeof deleteAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {abilityId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAbilities = (
    removeAbilitiesBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAbilities200AllOf>(
      {url: `/api/v1/abilities/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeAbilitiesBody
    },
      options);
    }
  


export const getRemoveAbilitiesMutationOptions = <TData = Awaited<ReturnType<typeof removeAbilities>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeAbilities'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAbilities>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeAbilities(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveAbilitiesMutationResult = NonNullable<Awaited<ReturnType<typeof removeAbilities>>>
    export type RemoveAbilitiesMutationBody = BodyType<string[]>
    export type RemoveAbilitiesMutationError = ErrorType<void>

    export const useRemoveAbilities = <TData = Awaited<ReturnType<typeof removeAbilities>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveAbilitiesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeAbility = (
    abilityId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveAbility200AllOf>(
      {url: `/api/v1/abilities/${abilityId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveAbilityMutationOptions = <TData = Awaited<ReturnType<typeof removeAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeAbility'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeAbility>>, {abilityId: string}> = (props) => {
          const {abilityId} = props ?? {};

          return  removeAbility(abilityId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{abilityId: string}, TContext>}

    export type RemoveAbilityMutationResult = NonNullable<Awaited<ReturnType<typeof removeAbility>>>
    
    export type RemoveAbilityMutationError = ErrorType<void>

    export const useRemoveAbility = <TData = Awaited<ReturnType<typeof removeAbility>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{abilityId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {abilityId: string},
        TContext
      > => {

      const mutationOptions = getRemoveAbilityMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSubject = (
    createSubjectDto: BodyType<CreateSubjectDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSubject200AllOf>(
      {url: `/api/v1/subjects`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSubjectDto, signal
    },
      options);
    }
  


export const getCreateSubjectMutationOptions = <TData = Awaited<ReturnType<typeof createSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubject>>, {data: BodyType<CreateSubjectDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSubject(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateSubjectDto>}, TContext>}

    export type CreateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof createSubject>>>
    export type CreateSubjectMutationBody = BodyType<CreateSubjectDto>
    export type CreateSubjectMutationError = ErrorType<void>

    export const useCreateSubject = <TData = Awaited<ReturnType<typeof createSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateSubjectDto>},
        TContext
      > => {

      const mutationOptions = getCreateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSubjectsByQuery = (
    params?: GetSubjectsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubjectsByQuery200AllOf>(
      {url: `/api/v1/subjects`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSubjectsByQueryQueryKey = (params?: GetSubjectsByQueryParams,) => {
    return [`/api/v1/subjects`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSubjectsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubjectsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQueryQueryError = ErrorType<void>


export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSubjectsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSubjectsByQuery<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubjectsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubjectsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQuerySuspenseQueryError = ErrorType<void>


export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSubjectsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSubjectsByQuerySuspense<TData = Awaited<ReturnType<typeof getSubjectsByQuery>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubjectsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubjectsByQuery>>> = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubjectsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubjectsByQuery>>>
export type GetSubjectsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetSubjectsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSubjectsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSubjectsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubjectsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubjectsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSubjectQueryKey = (subjectId: string,) => {
    return [`/api/v1/subjects/${subjectId}`] as const;
    }

    
export const getGetSubjectQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(subjectId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubjectQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectQueryError = ErrorType<void>


export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSubject<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubjectQueryOptions(subjectId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubjectSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectSuspenseQueryError = ErrorType<void>


export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSubjectSuspense<TData = Awaited<ReturnType<typeof getSubject>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubjectSuspenseQueryOptions(subjectId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSubjectSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({ signal }) => getSubject(subjectId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSubjectSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSubject>>>
export type GetSubjectSuspenseInfiniteQueryError = ErrorType<void>


export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSubjectSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>, TError = ErrorType<void>>(
 subjectId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSubjectSuspenseInfiniteQueryOptions(subjectId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSubject = (
    subjectId: string,
    updateSubjectDto: BodyType<UpdateSubjectDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSubjectDto
    },
      options);
    }
  


export const getUpdateSubjectMutationOptions = <TData = Awaited<ReturnType<typeof updateSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubject>>, {subjectId: string;data: BodyType<UpdateSubjectDto>}> = (props) => {
          const {subjectId,data} = props ?? {};

          return  updateSubject(subjectId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>}

    export type UpdateSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubject>>>
    export type UpdateSubjectMutationBody = BodyType<UpdateSubjectDto>
    export type UpdateSubjectMutationError = ErrorType<void>

    export const useUpdateSubject = <TData = Awaited<ReturnType<typeof updateSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{subjectId: string;data: BodyType<UpdateSubjectDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {subjectId: string;data: BodyType<UpdateSubjectDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSubjectMutationOptions = <TData = Awaited<ReturnType<typeof deleteSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  deleteSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{subjectId: string}, TContext>}

    export type DeleteSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubject>>>
    
    export type DeleteSubjectMutationError = ErrorType<void>

    export const useDeleteSubject = <TData = Awaited<ReturnType<typeof deleteSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSubjects = (
    removeSubjectsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSubjects200AllOf>(
      {url: `/api/v1/subjects/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSubjectsBody
    },
      options);
    }
  


export const getRemoveSubjectsMutationOptions = <TData = Awaited<ReturnType<typeof removeSubjects>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeSubjects'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubjects>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSubjects(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveSubjectsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubjects>>>
    export type RemoveSubjectsMutationBody = BodyType<string[]>
    export type RemoveSubjectsMutationError = ErrorType<void>

    export const useRemoveSubjects = <TData = Awaited<ReturnType<typeof removeSubjects>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSubject = (
    subjectId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSubject200AllOf>(
      {url: `/api/v1/subjects/${subjectId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSubjectMutationOptions = <TData = Awaited<ReturnType<typeof removeSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeSubject'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSubject>>, {subjectId: string}> = (props) => {
          const {subjectId} = props ?? {};

          return  removeSubject(subjectId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{subjectId: string}, TContext>}

    export type RemoveSubjectMutationResult = NonNullable<Awaited<ReturnType<typeof removeSubject>>>
    
    export type RemoveSubjectMutationError = ErrorType<void>

    export const useRemoveSubject = <TData = Awaited<ReturnType<typeof removeSubject>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{subjectId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {subjectId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSubjectMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createTimeline = (
    createTimelineDto: BodyType<CreateTimelineDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateTimeline200AllOf>(
      {url: `/api/v1/timelines`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTimelineDto, signal
    },
      options);
    }
  


export const getCreateTimelineMutationOptions = <TData = Awaited<ReturnType<typeof createTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTimeline>>, {data: BodyType<CreateTimelineDto>}> = (props) => {
          const {data} = props ?? {};

          return  createTimeline(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateTimelineDto>}, TContext>}

    export type CreateTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof createTimeline>>>
    export type CreateTimelineMutationBody = BodyType<CreateTimelineDto>
    export type CreateTimelineMutationError = ErrorType<void>

    export const useCreateTimeline = <TData = Awaited<ReturnType<typeof createTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateTimelineDto>},
        TContext
      > => {

      const mutationOptions = getCreateTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getTimelinesByQuery = (
    params?: GetTimelinesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimelinesByQuery200AllOf>(
      {url: `/api/v1/timelines`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTimelinesByQueryQueryKey = (params?: GetTimelinesByQueryParams,) => {
    return [`/api/v1/timelines`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTimelinesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimelinesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQueryQueryError = ErrorType<void>


export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetTimelinesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimelinesByQuery<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimelinesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelinesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimelinesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQuerySuspenseQueryError = ErrorType<void>


export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetTimelinesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimelinesByQuerySuspense<TData = Awaited<ReturnType<typeof getTimelinesByQuery>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimelinesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelinesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimelinesByQuery>>> = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimelinesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimelinesByQuery>>>
export type GetTimelinesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetTimelinesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimelinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetTimelinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimelinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimelinesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTimelineQueryKey = (timelineId: string,) => {
    return [`/api/v1/timelines/${timelineId}`] as const;
    }

    
export const getGetTimelineQueryOptions = <TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimelineQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineQueryError = ErrorType<void>


export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimeline<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimelineQueryOptions(timelineId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimelineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineSuspenseQueryError = ErrorType<void>


export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimelineSuspense<TData = Awaited<ReturnType<typeof getTimeline>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimelineSuspenseQueryOptions(timelineId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTimelineSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({ signal }) => getTimeline(timelineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTimelineSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTimeline>>>
export type GetTimelineSuspenseInfiniteQueryError = ErrorType<void>


export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTimelineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>, TError = ErrorType<void>>(
 timelineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTimelineSuspenseInfiniteQueryOptions(timelineId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateTimeline = (
    timelineId: string,
    updateTimelineDto: BodyType<UpdateTimelineDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTimelineDto
    },
      options);
    }
  


export const getUpdateTimelineMutationOptions = <TData = Awaited<ReturnType<typeof updateTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{timelineId: string;data: BodyType<UpdateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTimeline>>, {timelineId: string;data: BodyType<UpdateTimelineDto>}> = (props) => {
          const {timelineId,data} = props ?? {};

          return  updateTimeline(timelineId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{timelineId: string;data: BodyType<UpdateTimelineDto>}, TContext>}

    export type UpdateTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof updateTimeline>>>
    export type UpdateTimelineMutationBody = BodyType<UpdateTimelineDto>
    export type UpdateTimelineMutationError = ErrorType<void>

    export const useUpdateTimeline = <TData = Awaited<ReturnType<typeof updateTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{timelineId: string;data: BodyType<UpdateTimelineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {timelineId: string;data: BodyType<UpdateTimelineDto>},
        TContext
      > => {

      const mutationOptions = getUpdateTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTimelineMutationOptions = <TData = Awaited<ReturnType<typeof deleteTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  deleteTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{timelineId: string}, TContext>}

    export type DeleteTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTimeline>>>
    
    export type DeleteTimelineMutationError = ErrorType<void>

    export const useDeleteTimeline = <TData = Awaited<ReturnType<typeof deleteTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTimelines = (
    removeTimelinesBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimelines200AllOf>(
      {url: `/api/v1/timelines/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeTimelinesBody
    },
      options);
    }
  


export const getRemoveTimelinesMutationOptions = <TData = Awaited<ReturnType<typeof removeTimelines>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeTimelines'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimelines>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeTimelines(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveTimelinesMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimelines>>>
    export type RemoveTimelinesMutationBody = BodyType<string[]>
    export type RemoveTimelinesMutationError = ErrorType<void>

    export const useRemoveTimelines = <TData = Awaited<ReturnType<typeof removeTimelines>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveTimelinesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTimeline = (
    timelineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTimeline200AllOf>(
      {url: `/api/v1/timelines/${timelineId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveTimelineMutationOptions = <TData = Awaited<ReturnType<typeof removeTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeTimeline'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTimeline>>, {timelineId: string}> = (props) => {
          const {timelineId} = props ?? {};

          return  removeTimeline(timelineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{timelineId: string}, TContext>}

    export type RemoveTimelineMutationResult = NonNullable<Awaited<ReturnType<typeof removeTimeline>>>
    
    export type RemoveTimelineMutationError = ErrorType<void>

    export const useRemoveTimeline = <TData = Awaited<ReturnType<typeof removeTimeline>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{timelineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {timelineId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTimelineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createSession = (
    createSessionDto: BodyType<CreateSessionDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateSession200AllOf>(
      {url: `/api/v1/sessions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createSessionDto, signal
    },
      options);
    }
  


export const getCreateSessionMutationOptions = <TData = Awaited<ReturnType<typeof createSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSession>>, {data: BodyType<CreateSessionDto>}> = (props) => {
          const {data} = props ?? {};

          return  createSession(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateSessionDto>}, TContext>}

    export type CreateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof createSession>>>
    export type CreateSessionMutationBody = BodyType<CreateSessionDto>
    export type CreateSessionMutationError = ErrorType<void>

    export const useCreateSession = <TData = Awaited<ReturnType<typeof createSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateSessionDto>},
        TContext
      > => {

      const mutationOptions = getCreateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getSessionsByQuery = (
    params?: GetSessionsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSessionsByQuery200AllOf>(
      {url: `/api/v1/sessions`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetSessionsByQueryQueryKey = (params?: GetSessionsByQueryParams,) => {
    return [`/api/v1/sessions`, ...(params ? [params]: [])] as const;
    }

    
export const getGetSessionsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSessionsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQueryQueryError = ErrorType<void>


export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSessionsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSessionsByQuery<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSessionsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSessionsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseQueryError = ErrorType<void>


export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetSessionsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSessionsByQuerySuspense<TData = Awaited<ReturnType<typeof getSessionsByQuery>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSessionsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSessionsByQuery>>> = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSessionsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsByQuery>>>
export type GetSessionsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetSessionsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSessionsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>, TError = ErrorType<void>>(
 params?: GetSessionsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSessionsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSessionsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetSessionQueryKey = (sessionId: string,) => {
    return [`/api/v1/sessions/${sessionId}`] as const;
    }

    
export const getGetSessionQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSessionQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionQueryError = ErrorType<void>


export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSession<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSessionQueryOptions(sessionId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSessionSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseQueryError = ErrorType<void>


export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSessionSuspense<TData = Awaited<ReturnType<typeof getSession>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSessionSuspenseQueryOptions(sessionId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetSessionSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({ signal }) => getSession(sessionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetSessionSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getSession>>>
export type GetSessionSuspenseInfiniteQueryError = ErrorType<void>


export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetSessionSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>, TError = ErrorType<void>>(
 sessionId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetSessionSuspenseInfiniteQueryOptions(sessionId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateSession = (
    sessionId: string,
    updateSessionDto: BodyType<UpdateSessionDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateSessionDto
    },
      options);
    }
  


export const getUpdateSessionMutationOptions = <TData = Awaited<ReturnType<typeof updateSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSession>>, {sessionId: string;data: BodyType<UpdateSessionDto>}> = (props) => {
          const {sessionId,data} = props ?? {};

          return  updateSession(sessionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>}

    export type UpdateSessionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSession>>>
    export type UpdateSessionMutationBody = BodyType<UpdateSessionDto>
    export type UpdateSessionMutationError = ErrorType<void>

    export const useUpdateSession = <TData = Awaited<ReturnType<typeof updateSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{sessionId: string;data: BodyType<UpdateSessionDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {sessionId: string;data: BodyType<UpdateSessionDto>},
        TContext
      > => {

      const mutationOptions = getUpdateSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteSessionMutationOptions = <TData = Awaited<ReturnType<typeof deleteSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  deleteSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{sessionId: string}, TContext>}

    export type DeleteSessionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSession>>>
    
    export type DeleteSessionMutationError = ErrorType<void>

    export const useDeleteSession = <TData = Awaited<ReturnType<typeof deleteSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getDeleteSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSessions = (
    removeSessionsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSessions200AllOf>(
      {url: `/api/v1/sessions/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeSessionsBody
    },
      options);
    }
  


export const getRemoveSessionsMutationOptions = <TData = Awaited<ReturnType<typeof removeSessions>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeSessions'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSessions>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeSessions(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof removeSessions>>>
    export type RemoveSessionsMutationBody = BodyType<string[]>
    export type RemoveSessionsMutationError = ErrorType<void>

    export const useRemoveSessions = <TData = Awaited<ReturnType<typeof removeSessions>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveSessionsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeSession = (
    sessionId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveSession200AllOf>(
      {url: `/api/v1/sessions/${sessionId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveSessionMutationOptions = <TData = Awaited<ReturnType<typeof removeSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeSession'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeSession>>, {sessionId: string}> = (props) => {
          const {sessionId} = props ?? {};

          return  removeSession(sessionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{sessionId: string}, TContext>}

    export type RemoveSessionMutationResult = NonNullable<Awaited<ReturnType<typeof removeSession>>>
    
    export type RemoveSessionMutationError = ErrorType<void>

    export const useRemoveSession = <TData = Awaited<ReturnType<typeof removeSession>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{sessionId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {sessionId: string},
        TContext
      > => {

      const mutationOptions = getRemoveSessionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createProgram = (
    createProgramDto: BodyType<CreateProgramDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateProgram200AllOf>(
      {url: `/api/v1/programs`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createProgramDto, signal
    },
      options);
    }
  


export const getCreateProgramMutationOptions = <TData = Awaited<ReturnType<typeof createProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateProgramDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createProgram'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createProgram>>, {data: BodyType<CreateProgramDto>}> = (props) => {
          const {data} = props ?? {};

          return  createProgram(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateProgramDto>}, TContext>}

    export type CreateProgramMutationResult = NonNullable<Awaited<ReturnType<typeof createProgram>>>
    export type CreateProgramMutationBody = BodyType<CreateProgramDto>
    export type CreateProgramMutationError = ErrorType<void>

    export const useCreateProgram = <TData = Awaited<ReturnType<typeof createProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateProgramDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateProgramDto>},
        TContext
      > => {

      const mutationOptions = getCreateProgramMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getProgramsByQuery = (
    params?: GetProgramsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetProgramsByQuery200AllOf>(
      {url: `/api/v1/programs`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetProgramsByQueryQueryKey = (params?: GetProgramsByQueryParams,) => {
    return [`/api/v1/programs`, ...(params ? [params]: [])] as const;
    }

    
export const getGetProgramsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(params?: GetProgramsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramsByQuery>>> = ({ signal }) => getProgramsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProgramsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramsByQuery>>>
export type GetProgramsByQueryQueryError = ErrorType<void>


export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetProgramsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProgramsByQuery<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProgramsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramsByQuery>>> = ({ signal }) => getProgramsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProgramsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramsByQuery>>>
export type GetProgramsByQuerySuspenseQueryError = ErrorType<void>


export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetProgramsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProgramsByQuerySuspense<TData = Awaited<ReturnType<typeof getProgramsByQuery>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProgramsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<void>>(params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramsByQuery>>> = ({ signal }) => getProgramsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProgramsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProgramsByQuery>>>
export type GetProgramsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetProgramsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProgramsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>, TError = ErrorType<void>>(
 params?: GetProgramsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgramsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProgramsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getProgram = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetProgram200AllOf>(
      {url: `/api/v1/programs/${programId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetProgramQueryKey = (programId: string,) => {
    return [`/api/v1/programs/${programId}`] as const;
    }

    
export const getGetProgramQueryOptions = <TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramQueryKey(programId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgram>>> = ({ signal }) => getProgram(programId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(programId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProgramQueryResult = NonNullable<Awaited<ReturnType<typeof getProgram>>>
export type GetProgramQueryError = ErrorType<void>


export function useGetProgram<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgram>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgram<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgram>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgram<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProgram<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProgramQueryOptions(programId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramQueryKey(programId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgram>>> = ({ signal }) => getProgram(programId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProgramSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getProgram>>>
export type GetProgramSuspenseQueryError = ErrorType<void>


export function useGetProgramSuspense<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramSuspense<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramSuspense<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProgramSuspense<TData = Awaited<ReturnType<typeof getProgram>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProgramSuspenseQueryOptions(programId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetProgramSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getProgram>>>, TError = ErrorType<void>>(programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetProgramQueryKey(programId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgram>>> = ({ signal }) => getProgram(programId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetProgramSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getProgram>>>
export type GetProgramSuspenseInfiniteQueryError = ErrorType<void>


export function useGetProgramSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgram>>>, TError = ErrorType<void>>(
 programId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgram>>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetProgramSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgram>>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetProgramSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getProgram>>>, TError = ErrorType<void>>(
 programId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getProgram>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetProgramSuspenseInfiniteQueryOptions(programId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateProgram = (
    programId: string,
    updateProgramDto: BodyType<UpdateProgramDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateProgram200AllOf>(
      {url: `/api/v1/programs/${programId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateProgramDto
    },
      options);
    }
  


export const getUpdateProgramMutationOptions = <TData = Awaited<ReturnType<typeof updateProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{programId: string;data: BodyType<UpdateProgramDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateProgram'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateProgram>>, {programId: string;data: BodyType<UpdateProgramDto>}> = (props) => {
          const {programId,data} = props ?? {};

          return  updateProgram(programId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{programId: string;data: BodyType<UpdateProgramDto>}, TContext>}

    export type UpdateProgramMutationResult = NonNullable<Awaited<ReturnType<typeof updateProgram>>>
    export type UpdateProgramMutationBody = BodyType<UpdateProgramDto>
    export type UpdateProgramMutationError = ErrorType<void>

    export const useUpdateProgram = <TData = Awaited<ReturnType<typeof updateProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{programId: string;data: BodyType<UpdateProgramDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {programId: string;data: BodyType<UpdateProgramDto>},
        TContext
      > => {

      const mutationOptions = getUpdateProgramMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteProgram = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteProgram200AllOf>(
      {url: `/api/v1/programs/${programId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteProgramMutationOptions = <TData = Awaited<ReturnType<typeof deleteProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteProgram'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteProgram>>, {programId: string}> = (props) => {
          const {programId} = props ?? {};

          return  deleteProgram(programId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{programId: string}, TContext>}

    export type DeleteProgramMutationResult = NonNullable<Awaited<ReturnType<typeof deleteProgram>>>
    
    export type DeleteProgramMutationError = ErrorType<void>

    export const useDeleteProgram = <TData = Awaited<ReturnType<typeof deleteProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {programId: string},
        TContext
      > => {

      const mutationOptions = getDeleteProgramMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removePrograms = (
    removeProgramsBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemovePrograms200AllOf>(
      {url: `/api/v1/programs/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeProgramsBody
    },
      options);
    }
  


export const getRemoveProgramsMutationOptions = <TData = Awaited<ReturnType<typeof removePrograms>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removePrograms'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removePrograms>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removePrograms(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveProgramsMutationResult = NonNullable<Awaited<ReturnType<typeof removePrograms>>>
    export type RemoveProgramsMutationBody = BodyType<string[]>
    export type RemoveProgramsMutationError = ErrorType<void>

    export const useRemovePrograms = <TData = Awaited<ReturnType<typeof removePrograms>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveProgramsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeProgram = (
    programId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveProgram200AllOf>(
      {url: `/api/v1/programs/${programId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveProgramMutationOptions = <TData = Awaited<ReturnType<typeof removeProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeProgram'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeProgram>>, {programId: string}> = (props) => {
          const {programId} = props ?? {};

          return  removeProgram(programId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{programId: string}, TContext>}

    export type RemoveProgramMutationResult = NonNullable<Awaited<ReturnType<typeof removeProgram>>>
    
    export type RemoveProgramMutationError = ErrorType<void>

    export const useRemoveProgram = <TData = Awaited<ReturnType<typeof removeProgram>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{programId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {programId: string},
        TContext
      > => {

      const mutationOptions = getRemoveProgramMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createRoutine = (
    createRoutineBody?: BodyType<CreateRoutineBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(createRoutineBody?.label !== undefined) {
 formData.append('label', createRoutineBody.label)
 }
if(createRoutineBody?.name !== undefined) {
 formData.append('name', createRoutineBody.name)
 }
if(createRoutineBody?.contentId !== undefined) {
 formData.append('contentId', createRoutineBody.contentId)
 }

if(createRoutineBody?.files !== undefined) {
 createRoutineBody?.files.forEach(value => formData.append('files', value));
 }

      return customInstance<CreateRoutine200AllOf>(
      {url: `/api/v1/routines`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getCreateRoutineMutationOptions = <TData = Awaited<ReturnType<typeof createRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateRoutineBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRoutine>>, {data: BodyType<CreateRoutineBody>}> = (props) => {
          const {data} = props ?? {};

          return  createRoutine(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateRoutineBody>}, TContext>}

    export type CreateRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof createRoutine>>>
    export type CreateRoutineMutationBody = BodyType<CreateRoutineBody>
    export type CreateRoutineMutationError = ErrorType<void>

    export const useCreateRoutine = <TData = Awaited<ReturnType<typeof createRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateRoutineBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateRoutineBody>},
        TContext
      > => {

      const mutationOptions = getCreateRoutineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getRoutinesByQuery = (
    params?: GetRoutinesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRoutinesByQuery200AllOf>(
      {url: `/api/v1/routines`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetRoutinesByQueryQueryKey = (params?: GetRoutinesByQueryParams,) => {
    return [`/api/v1/routines`, ...(params ? [params]: [])] as const;
    }

    
export const getGetRoutinesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutinesByQuery>>> = ({ signal }) => getRoutinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutinesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutinesByQuery>>>
export type GetRoutinesByQueryQueryError = ErrorType<void>


export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetRoutinesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutinesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutinesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoutinesByQuery<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutinesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutinesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutinesByQuery>>> = ({ signal }) => getRoutinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutinesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutinesByQuery>>>
export type GetRoutinesByQuerySuspenseQueryError = ErrorType<void>


export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetRoutinesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoutinesByQuerySuspense<TData = Awaited<ReturnType<typeof getRoutinesByQuery>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutinesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutinesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<void>>(params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutinesByQuery>>> = ({ signal }) => getRoutinesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutinesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutinesByQuery>>>
export type GetRoutinesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetRoutinesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoutinesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>, TError = ErrorType<void>>(
 params?: GetRoutinesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutinesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutinesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetRoutineQueryKey = (routineId: string,) => {
    return [`/api/v1/routines/${routineId}`] as const;
    }

    
export const getGetRoutineQueryOptions = <TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({ signal }) => getRoutine(routineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(routineId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutineQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutine>>>
export type GetRoutineQueryError = ErrorType<void>


export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutine>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutine>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoutine<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutineQueryOptions(routineId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutineSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({ signal }) => getRoutine(routineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutineSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutine>>>
export type GetRoutineSuspenseQueryError = ErrorType<void>


export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoutineSuspense<TData = Awaited<ReturnType<typeof getRoutine>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutineSuspenseQueryOptions(routineId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetRoutineSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<void>>(routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({ signal }) => getRoutine(routineId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetRoutineSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getRoutine>>>
export type GetRoutineSuspenseInfiniteQueryError = ErrorType<void>


export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<void>>(
 routineId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetRoutineSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>, TError = ErrorType<void>>(
 routineId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetRoutineSuspenseInfiniteQueryOptions(routineId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateRoutine = (
    routineId: string,
    updateRoutineDto: BodyType<UpdateRoutineDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateRoutineDto
    },
      options);
    }
  


export const getUpdateRoutineMutationOptions = <TData = Awaited<ReturnType<typeof updateRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{routineId: string;data: BodyType<UpdateRoutineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRoutine>>, {routineId: string;data: BodyType<UpdateRoutineDto>}> = (props) => {
          const {routineId,data} = props ?? {};

          return  updateRoutine(routineId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{routineId: string;data: BodyType<UpdateRoutineDto>}, TContext>}

    export type UpdateRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof updateRoutine>>>
    export type UpdateRoutineMutationBody = BodyType<UpdateRoutineDto>
    export type UpdateRoutineMutationError = ErrorType<void>

    export const useUpdateRoutine = <TData = Awaited<ReturnType<typeof updateRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{routineId: string;data: BodyType<UpdateRoutineDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {routineId: string;data: BodyType<UpdateRoutineDto>},
        TContext
      > => {

      const mutationOptions = getUpdateRoutineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteRoutineMutationOptions = <TData = Awaited<ReturnType<typeof deleteRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRoutine>>, {routineId: string}> = (props) => {
          const {routineId} = props ?? {};

          return  deleteRoutine(routineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{routineId: string}, TContext>}

    export type DeleteRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRoutine>>>
    
    export type DeleteRoutineMutationError = ErrorType<void>

    export const useDeleteRoutine = <TData = Awaited<ReturnType<typeof deleteRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {routineId: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoutineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeRoutines = (
    removeRoutinesBody: BodyType<string[]>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveRoutines200AllOf>(
      {url: `/api/v1/routines/removedAt`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: removeRoutinesBody
    },
      options);
    }
  


export const getRemoveRoutinesMutationOptions = <TData = Awaited<ReturnType<typeof removeRoutines>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeRoutines'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRoutines>>, {data: BodyType<string[]>}> = (props) => {
          const {data} = props ?? {};

          return  removeRoutines(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>}

    export type RemoveRoutinesMutationResult = NonNullable<Awaited<ReturnType<typeof removeRoutines>>>
    export type RemoveRoutinesMutationBody = BodyType<string[]>
    export type RemoveRoutinesMutationError = ErrorType<void>

    export const useRemoveRoutines = <TData = Awaited<ReturnType<typeof removeRoutines>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<string[]>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<string[]>},
        TContext
      > => {

      const mutationOptions = getRemoveRoutinesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeRoutine = (
    routineId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveRoutine200AllOf>(
      {url: `/api/v1/routines/${routineId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveRoutineMutationOptions = <TData = Awaited<ReturnType<typeof removeRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeRoutine'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeRoutine>>, {routineId: string}> = (props) => {
          const {routineId} = props ?? {};

          return  removeRoutine(routineId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{routineId: string}, TContext>}

    export type RemoveRoutineMutationResult = NonNullable<Awaited<ReturnType<typeof removeRoutine>>>
    
    export type RemoveRoutineMutationError = ErrorType<void>

    export const useRemoveRoutine = <TData = Awaited<ReturnType<typeof removeRoutine>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{routineId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {routineId: string},
        TContext
      > => {

      const mutationOptions = getRemoveRoutineMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createDepot = (
    createDepotBody?: BodyType<CreateDepotBody>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
if(createDepotBody?.thumbnails !== undefined) {
 createDepotBody?.thumbnails.forEach(value => formData.append('thumbnails', value));
 }
if(createDepotBody?.videos !== undefined) {
 createDepotBody?.videos.forEach(value => formData.append('videos', value));
 }
if(createDepotBody?.images !== undefined) {
 createDepotBody?.images.forEach(value => formData.append('images', value));
 }

      return customInstance<CreateDepot201AllOf>(
      {url: `/api/v1/depots`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getCreateDepotMutationOptions = <TData = Awaited<ReturnType<typeof createDepot>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateDepotBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createDepot'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDepot>>, {data: BodyType<CreateDepotBody>}> = (props) => {
          const {data} = props ?? {};

          return  createDepot(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateDepotBody>}, TContext>}

    export type CreateDepotMutationResult = NonNullable<Awaited<ReturnType<typeof createDepot>>>
    export type CreateDepotMutationBody = BodyType<CreateDepotBody>
    export type CreateDepotMutationError = ErrorType<void>

    export const useCreateDepot = <TData = Awaited<ReturnType<typeof createDepot>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateDepotBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateDepotBody>},
        TContext
      > => {

      const mutationOptions = getCreateDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getDepotsByQuery = (
    params?: GetDepotsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDepotsByQuery200AllOf>(
      {url: `/api/v1/depots`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetDepotsByQueryQueryKey = (params?: GetDepotsByQueryParams,) => {
    return [`/api/v1/depots`, ...(params ? [params]: [])] as const;
    }

    
export const getGetDepotsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(params?: GetDepotsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotsByQuery>>> = ({ signal }) => getDepotsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotsByQuery>>>
export type GetDepotsByQueryQueryError = ErrorType<void>


export function useGetDepotsByQuery<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetDepotsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotsByQuery<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotsByQuery<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotsByQuery<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotsByQuery>>> = ({ signal }) => getDepotsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotsByQuery>>>
export type GetDepotsByQuerySuspenseQueryError = ErrorType<void>


export function useGetDepotsByQuerySuspense<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetDepotsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotsByQuerySuspense<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotsByQuerySuspense<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotsByQuerySuspense<TData = Awaited<ReturnType<typeof getDepotsByQuery>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>, TError = ErrorType<void>>(params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotsByQuery>>> = ({ signal }) => getDepotsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotsByQuery>>>
export type GetDepotsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetDepotsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetDepotsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>, TError = ErrorType<void>>(
 params?: GetDepotsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getDepotById = (
    depotId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetDepotById200AllOf>(
      {url: `/api/v1/depots/${depotId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetDepotByIdQueryKey = (depotId: string,) => {
    return [`/api/v1/depots/${depotId}`] as const;
    }

    
export const getGetDepotByIdQueryOptions = <TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(depotId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotByIdQueryKey(depotId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotById>>> = ({ signal }) => getDepotById(depotId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(depotId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotById>>>
export type GetDepotByIdQueryError = ErrorType<void>


export function useGetDepotById<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotById<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotById<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotById<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotByIdQueryOptions(depotId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(depotId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotByIdQueryKey(depotId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotById>>> = ({ signal }) => getDepotById(depotId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotById>>>
export type GetDepotByIdSuspenseQueryError = ErrorType<void>


export function useGetDepotByIdSuspense<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotByIdSuspense<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotByIdSuspense<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotByIdSuspense<TData = Awaited<ReturnType<typeof getDepotById>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotByIdSuspenseQueryOptions(depotId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetDepotByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>, TError = ErrorType<void>>(depotId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDepotByIdQueryKey(depotId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotById>>> = ({ signal }) => getDepotById(depotId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetDepotByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getDepotById>>>
export type GetDepotByIdSuspenseInfiniteQueryError = ErrorType<void>


export function useGetDepotByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>, TError = ErrorType<void>>(
 depotId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetDepotByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetDepotByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>, TError = ErrorType<void>>(
 depotId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetDepotByIdSuspenseInfiniteQueryOptions(depotId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateDepotById = (
    depotId: string,
    updateDepotByIdBody?: BodyType<UpdateDepotByIdBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      const formData = new FormData();
if(updateDepotByIdBody?.thumbnails !== undefined) {
 updateDepotByIdBody?.thumbnails.forEach(value => formData.append('thumbnails', value));
 }
if(updateDepotByIdBody?.videos !== undefined) {
 updateDepotByIdBody?.videos.forEach(value => formData.append('videos', value));
 }
if(updateDepotByIdBody?.images !== undefined) {
 updateDepotByIdBody?.images.forEach(value => formData.append('images', value));
 }

      return customInstance<UpdateDepotById200AllOf>(
      {url: `/api/v1/depots/${depotId}`, method: 'PATCH',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      options);
    }
  


export const getUpdateDepotByIdMutationOptions = <TData = Awaited<ReturnType<typeof updateDepotById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{depotId: string;data: BodyType<UpdateDepotByIdBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateDepotById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDepotById>>, {depotId: string;data: BodyType<UpdateDepotByIdBody>}> = (props) => {
          const {depotId,data} = props ?? {};

          return  updateDepotById(depotId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{depotId: string;data: BodyType<UpdateDepotByIdBody>}, TContext>}

    export type UpdateDepotByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateDepotById>>>
    export type UpdateDepotByIdMutationBody = BodyType<UpdateDepotByIdBody>
    export type UpdateDepotByIdMutationError = ErrorType<void>

    export const useUpdateDepotById = <TData = Awaited<ReturnType<typeof updateDepotById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{depotId: string;data: BodyType<UpdateDepotByIdBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {depotId: string;data: BodyType<UpdateDepotByIdBody>},
        TContext
      > => {

      const mutationOptions = getUpdateDepotByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteDepot = (
    depotId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteDepot200AllOf>(
      {url: `/api/v1/depots/${depotId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDepotMutationOptions = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{depotId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteDepot'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDepot>>, {depotId: string}> = (props) => {
          const {depotId} = props ?? {};

          return  deleteDepot(depotId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{depotId: string}, TContext>}

    export type DeleteDepotMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDepot>>>
    
    export type DeleteDepotMutationError = ErrorType<void>

    export const useDeleteDepot = <TData = Awaited<ReturnType<typeof deleteDepot>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{depotId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {depotId: string},
        TContext
      > => {

      const mutationOptions = getDeleteDepotMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getExercisesByQuery = (
    params?: GetExercisesByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetExercisesByQuery200AllOf>(
      {url: `/api/v1/exercises`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetExercisesByQueryQueryKey = (params?: GetExercisesByQueryParams,) => {
    return [`/api/v1/exercises`, ...(params ? [params]: [])] as const;
    }

    
export const getGetExercisesByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesByQuery>>> = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExercisesByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesByQuery>>>
export type GetExercisesByQueryQueryError = ErrorType<void>


export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetExercisesByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExercisesByQuery<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExercisesByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExercisesByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesByQuery>>> = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExercisesByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesByQuery>>>
export type GetExercisesByQuerySuspenseQueryError = ErrorType<void>


export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetExercisesByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExercisesByQuerySuspense<TData = Awaited<ReturnType<typeof getExercisesByQuery>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExercisesByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExercisesByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<void>>(params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercisesByQuery>>> = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExercisesByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getExercisesByQuery>>>
export type GetExercisesByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetExercisesByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExercisesByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>, TError = ErrorType<void>>(
 params?: GetExercisesByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercisesByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExercisesByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const createExercise = (
    createExerciseDto: BodyType<CreateExerciseDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateExercise200AllOf>(
      {url: `/api/v1/exercises`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createExerciseDto, signal
    },
      options);
    }
  


export const getCreateExerciseMutationOptions = <TData = Awaited<ReturnType<typeof createExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExercise>>, {data: BodyType<CreateExerciseDto>}> = (props) => {
          const {data} = props ?? {};

          return  createExercise(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateExerciseDto>}, TContext>}

    export type CreateExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof createExercise>>>
    export type CreateExerciseMutationBody = BodyType<CreateExerciseDto>
    export type CreateExerciseMutationError = ErrorType<void>

    export const useCreateExercise = <TData = Awaited<ReturnType<typeof createExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateExerciseDto>},
        TContext
      > => {

      const mutationOptions = getCreateExerciseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getExercise = (
    exerciseId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetExerciseQueryKey = (exerciseId: string,) => {
    return [`/api/v1/exercises/${exerciseId}`] as const;
    }

    
export const getGetExerciseQueryOptions = <TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({ signal }) => getExercise(exerciseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExerciseQueryResult = NonNullable<Awaited<ReturnType<typeof getExercise>>>
export type GetExerciseQueryError = ErrorType<void>


export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercise>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercise>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExercise<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExerciseQueryOptions(exerciseId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExerciseSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({ signal }) => getExercise(exerciseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExerciseSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getExercise>>>
export type GetExerciseSuspenseQueryError = ErrorType<void>


export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExerciseSuspense<TData = Awaited<ReturnType<typeof getExercise>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExerciseSuspenseQueryOptions(exerciseId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetExerciseSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<void>>(exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({ signal }) => getExercise(exerciseId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetExerciseSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getExercise>>>
export type GetExerciseSuspenseInfiniteQueryError = ErrorType<void>


export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<void>>(
 exerciseId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetExerciseSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>, TError = ErrorType<void>>(
 exerciseId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetExerciseSuspenseInfiniteQueryOptions(exerciseId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateExercise = (
    exerciseId: string,
    updateExerciseDto: BodyType<UpdateExerciseDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateExerciseDto
    },
      options);
    }
  


export const getUpdateExerciseMutationOptions = <TData = Awaited<ReturnType<typeof updateExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{exerciseId: string;data: BodyType<UpdateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateExercise>>, {exerciseId: string;data: BodyType<UpdateExerciseDto>}> = (props) => {
          const {exerciseId,data} = props ?? {};

          return  updateExercise(exerciseId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{exerciseId: string;data: BodyType<UpdateExerciseDto>}, TContext>}

    export type UpdateExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof updateExercise>>>
    export type UpdateExerciseMutationBody = BodyType<UpdateExerciseDto>
    export type UpdateExerciseMutationError = ErrorType<void>

    export const useUpdateExercise = <TData = Awaited<ReturnType<typeof updateExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{exerciseId: string;data: BodyType<UpdateExerciseDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {exerciseId: string;data: BodyType<UpdateExerciseDto>},
        TContext
      > => {

      const mutationOptions = getUpdateExerciseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteExercise = (
    exerciseId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteExerciseMutationOptions = <TData = Awaited<ReturnType<typeof deleteExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteExercise>>, {exerciseId: string}> = (props) => {
          const {exerciseId} = props ?? {};

          return  deleteExercise(exerciseId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{exerciseId: string}, TContext>}

    export type DeleteExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof deleteExercise>>>
    
    export type DeleteExerciseMutationError = ErrorType<void>

    export const useDeleteExercise = <TData = Awaited<ReturnType<typeof deleteExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {exerciseId: string},
        TContext
      > => {

      const mutationOptions = getDeleteExerciseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeExercise = (
    exerciseId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveExercise200AllOf>(
      {url: `/api/v1/exercises/${exerciseId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveExerciseMutationOptions = <TData = Awaited<ReturnType<typeof removeExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeExercise'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeExercise>>, {exerciseId: string}> = (props) => {
          const {exerciseId} = props ?? {};

          return  removeExercise(exerciseId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{exerciseId: string}, TContext>}

    export type RemoveExerciseMutationResult = NonNullable<Awaited<ReturnType<typeof removeExercise>>>
    
    export type RemoveExerciseMutationError = ErrorType<void>

    export const useRemoveExercise = <TData = Awaited<ReturnType<typeof removeExercise>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{exerciseId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {exerciseId: string},
        TContext
      > => {

      const mutationOptions = getRemoveExerciseMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getFileById = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetFileById200AllOf>(
      {url: `/api/v1/file/${fileId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetFileByIdQueryKey = (fileId: string,) => {
    return [`/api/v1/file/${fileId}`] as const;
    }

    
export const getGetFileByIdQueryOptions = <TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(fileId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFileByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdQueryError = ErrorType<void>


export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFileById<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFileByIdQueryOptions(fileId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFileByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdSuspenseQueryError = ErrorType<void>


export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFileByIdSuspense<TData = Awaited<ReturnType<typeof getFileById>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFileByIdSuspenseQueryOptions(fileId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetFileByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<void>>(fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({ signal }) => getFileById(fileId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetFileByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getFileById>>>
export type GetFileByIdSuspenseInfiniteQueryError = ErrorType<void>


export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<void>>(
 fileId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetFileByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>, TError = ErrorType<void>>(
 fileId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetFileByIdSuspenseInfiniteQueryOptions(fileId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateFileById = (
    fileId: string,
    updateFileByIdBody?: BodyType<UpdateFileByIdBody>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      const formData = new FormData();
if(updateFileByIdBody?.files !== undefined) {
 formData.append('files', updateFileByIdBody.files)
 }

      return customInstance<UpdateFileById200AllOf>(
      {url: `/api/v1/file/${fileId}`, method: 'PATCH',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData
    },
      options);
    }
  


export const getUpdateFileByIdMutationOptions = <TData = Awaited<ReturnType<typeof updateFileById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{fileId: string;data: BodyType<UpdateFileByIdBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateFileById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateFileById>>, {fileId: string;data: BodyType<UpdateFileByIdBody>}> = (props) => {
          const {fileId,data} = props ?? {};

          return  updateFileById(fileId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{fileId: string;data: BodyType<UpdateFileByIdBody>}, TContext>}

    export type UpdateFileByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateFileById>>>
    export type UpdateFileByIdMutationBody = BodyType<UpdateFileByIdBody>
    export type UpdateFileByIdMutationError = ErrorType<void>

    export const useUpdateFileById = <TData = Awaited<ReturnType<typeof updateFileById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{fileId: string;data: BodyType<UpdateFileByIdBody>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {fileId: string;data: BodyType<UpdateFileByIdBody>},
        TContext
      > => {

      const mutationOptions = getUpdateFileByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createFile = (
    createFileDto: BodyType<CreateFileDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateFile201AllOf>(
      {url: `/api/v1/file`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createFileDto, signal
    },
      options);
    }
  


export const getCreateFileMutationOptions = <TData = Awaited<ReturnType<typeof createFile>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateFileDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createFile'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createFile>>, {data: BodyType<CreateFileDto>}> = (props) => {
          const {data} = props ?? {};

          return  createFile(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateFileDto>}, TContext>}

    export type CreateFileMutationResult = NonNullable<Awaited<ReturnType<typeof createFile>>>
    export type CreateFileMutationBody = BodyType<CreateFileDto>
    export type CreateFileMutationError = ErrorType<void>

    export const useCreateFile = <TData = Awaited<ReturnType<typeof createFile>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateFileDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateFileDto>},
        TContext
      > => {

      const mutationOptions = getCreateFileMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeFileById = (
    fileId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveFileById200AllOf>(
      {url: `/api/v1/file/${fileId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveFileByIdMutationOptions = <TData = Awaited<ReturnType<typeof removeFileById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{fileId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeFileById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeFileById>>, {fileId: string}> = (props) => {
          const {fileId} = props ?? {};

          return  removeFileById(fileId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{fileId: string}, TContext>}

    export type RemoveFileByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeFileById>>>
    
    export type RemoveFileByIdMutationError = ErrorType<void>

    export const useRemoveFileById = <TData = Awaited<ReturnType<typeof removeFileById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{fileId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {fileId: string},
        TContext
      > => {

      const mutationOptions = getRemoveFileByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const createTenant = (
    createTenantDto: BodyType<CreateTenantDto>,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<CreateTenant200AllOf>(
      {url: `/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createTenantDto, signal
    },
      options);
    }
  


export const getCreateTenantMutationOptions = <TData = Awaited<ReturnType<typeof createTenant>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['createTenant'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTenant>>, {data: BodyType<CreateTenantDto>}> = (props) => {
          const {data} = props ?? {};

          return  createTenant(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{data: BodyType<CreateTenantDto>}, TContext>}

    export type CreateTenantMutationResult = NonNullable<Awaited<ReturnType<typeof createTenant>>>
    export type CreateTenantMutationBody = BodyType<CreateTenantDto>
    export type CreateTenantMutationError = ErrorType<void>

    export const useCreateTenant = <TData = Awaited<ReturnType<typeof createTenant>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{data: BodyType<CreateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {data: BodyType<CreateTenantDto>},
        TContext
      > => {

      const mutationOptions = getCreateTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getTenantsByQuery = (
    params?: GetTenantsByQueryParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTenantsByQuery200AllOf>(
      {url: `/`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetTenantsByQueryQueryKey = (params?: GetTenantsByQueryParams,) => {
    return [`/`, ...(params ? [params]: [])] as const;
    }

    
export const getGetTenantsByQueryQueryOptions = <TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsByQuery>>> = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantsByQueryQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsByQuery>>>
export type GetTenantsByQueryQueryError = ErrorType<void>


export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetTenantsByQueryParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsByQuery>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTenantsByQuery<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantsByQueryQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantsByQuerySuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsByQuery>>> = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantsByQuerySuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsByQuery>>>
export type GetTenantsByQuerySuspenseQueryError = ErrorType<void>


export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params: undefined |  GetTenantsByQueryParams, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTenantsByQuerySuspense<TData = Awaited<ReturnType<typeof getTenantsByQuery>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantsByQuerySuspenseQueryOptions(params,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantsByQuerySuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<void>>(params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantsByQuery>>> = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantsByQuerySuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantsByQuery>>>
export type GetTenantsByQuerySuspenseInfiniteQueryError = ErrorType<void>


export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<void>>(
 params: undefined |  GetTenantsByQueryParams, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTenantsByQuerySuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>, TError = ErrorType<void>>(
 params?: GetTenantsByQueryParams, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantsByQuery>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantsByQuerySuspenseInfiniteQueryOptions(params,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getTenantById = (
    tenantId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetTenantById200AllOf>(
      {url: `/${tenantId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetTenantByIdQueryKey = (tenantId: string,) => {
    return [`/${tenantId}`] as const;
    }

    
export const getGetTenantByIdQueryOptions = <TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({ signal }) => getTenantById(tenantId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(tenantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantById>>>
export type GetTenantByIdQueryError = ErrorType<void>


export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantById>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTenantById<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantByIdQueryOptions(tenantId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantByIdSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({ signal }) => getTenantById(tenantId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantByIdSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantById>>>
export type GetTenantByIdSuspenseQueryError = ErrorType<void>


export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTenantByIdSuspense<TData = Awaited<ReturnType<typeof getTenantById>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantByIdSuspenseQueryOptions(tenantId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetTenantByIdSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<void>>(tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({ signal }) => getTenantById(tenantId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetTenantByIdSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getTenantById>>>
export type GetTenantByIdSuspenseInfiniteQueryError = ErrorType<void>


export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<void>>(
 tenantId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetTenantByIdSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>, TError = ErrorType<void>>(
 tenantId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetTenantByIdSuspenseInfiniteQueryOptions(tenantId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const updateTenantById = (
    tenantId: string,
    updateTenantDto: BodyType<UpdateTenantDto>,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<UpdateTenantById200AllOf>(
      {url: `/${tenantId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateTenantDto
    },
      options);
    }
  


export const getUpdateTenantByIdMutationOptions = <TData = Awaited<ReturnType<typeof updateTenantById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{tenantId: string;data: BodyType<UpdateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['updateTenantById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTenantById>>, {tenantId: string;data: BodyType<UpdateTenantDto>}> = (props) => {
          const {tenantId,data} = props ?? {};

          return  updateTenantById(tenantId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{tenantId: string;data: BodyType<UpdateTenantDto>}, TContext>}

    export type UpdateTenantByIdMutationResult = NonNullable<Awaited<ReturnType<typeof updateTenantById>>>
    export type UpdateTenantByIdMutationBody = BodyType<UpdateTenantDto>
    export type UpdateTenantByIdMutationError = ErrorType<void>

    export const useUpdateTenantById = <TData = Awaited<ReturnType<typeof updateTenantById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{tenantId: string;data: BodyType<UpdateTenantDto>}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {tenantId: string;data: BodyType<UpdateTenantDto>},
        TContext
      > => {

      const mutationOptions = getUpdateTenantByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const deleteTenant = (
    tenantId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<DeleteTenant200AllOf>(
      {url: `/${tenantId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteTenantMutationOptions = <TData = Awaited<ReturnType<typeof deleteTenant>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['deleteTenant'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTenant>>, {tenantId: string}> = (props) => {
          const {tenantId} = props ?? {};

          return  deleteTenant(tenantId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{tenantId: string}, TContext>}

    export type DeleteTenantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTenant>>>
    
    export type DeleteTenantMutationError = ErrorType<void>

    export const useDeleteTenant = <TData = Awaited<ReturnType<typeof deleteTenant>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {tenantId: string},
        TContext
      > => {

      const mutationOptions = getDeleteTenantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const removeTenantById = (
    tenantId: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<RemoveTenantById200AllOf>(
      {url: `/${tenantId}/removedAt`, method: 'PATCH'
    },
      options);
    }
  


export const getRemoveTenantByIdMutationOptions = <TData = Awaited<ReturnType<typeof removeTenantById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
) => {
const mutationKey = ['removeTenantById'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeTenantById>>, {tenantId: string}> = (props) => {
          const {tenantId} = props ?? {};

          return  removeTenantById(tenantId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions } as UseMutationOptions<TData, TError,{tenantId: string}, TContext>}

    export type RemoveTenantByIdMutationResult = NonNullable<Awaited<ReturnType<typeof removeTenantById>>>
    
    export type RemoveTenantByIdMutationError = ErrorType<void>

    export const useRemoveTenantById = <TData = Awaited<ReturnType<typeof removeTenantById>>, TError = ErrorType<void>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<TData, TError,{tenantId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationResult<
        TData,
        TError,
        {tenantId: string},
        TContext
      > => {

      const mutationOptions = getRemoveTenantByIdMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getAdminAuthLoginRoute = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminAuthLoginRoute200AllOf>(
      {url: `/api/v1/admin/auth/login`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminAuthLoginRouteQueryKey = () => {
    return [`/api/v1/admin/auth/login`] as const;
    }

    
export const getGetAdminAuthLoginRouteQueryOptions = <TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAuthLoginRouteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>> = ({ signal }) => getAdminAuthLoginRoute(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAuthLoginRouteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>
export type GetAdminAuthLoginRouteQueryError = ErrorType<unknown>


export function useGetAdminAuthLoginRoute<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAuthLoginRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAuthLoginRoute<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminAuthLoginRoute>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAuthLoginRoute<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminAuthLoginRoute<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAuthLoginRouteQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminAuthLoginRouteSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAuthLoginRouteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>> = ({ signal }) => getAdminAuthLoginRoute(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAuthLoginRouteSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>
export type GetAdminAuthLoginRouteSuspenseQueryError = ErrorType<unknown>


export function useGetAdminAuthLoginRouteSuspense<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAuthLoginRouteSuspense<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAuthLoginRouteSuspense<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminAuthLoginRouteSuspense<TData = Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAuthLoginRouteSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminAuthLoginRouteSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminAuthLoginRouteQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>> = ({ signal }) => getAdminAuthLoginRoute(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminAuthLoginRouteSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>
export type GetAdminAuthLoginRouteSuspenseInfiniteQueryError = ErrorType<unknown>


export function useGetAdminAuthLoginRouteSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAuthLoginRouteSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminAuthLoginRouteSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminAuthLoginRouteSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminAuthLoginRoute>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminAuthLoginRouteSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainTenantsPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainTenantsPage200AllOf>(
      {url: `/api/v1/admin/main/tenants`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainTenantsPageQueryKey = () => {
    return [`/api/v1/admin/main/tenants`] as const;
    }

    
export const getGetAdminMainTenantsPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTenantsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTenantsPage>>> = ({ signal }) => getAdminMainTenantsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTenantsPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>
export type GetAdminMainTenantsPageQueryError = ErrorType<void>


export function useGetAdminMainTenantsPage<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTenantsPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTenantsPage<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTenantsPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTenantsPage<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTenantsPage<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTenantsPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTenantsPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTenantsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTenantsPage>>> = ({ signal }) => getAdminMainTenantsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTenantsPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>
export type GetAdminMainTenantsPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainTenantsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTenantsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTenantsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTenantsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTenantsPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTenantsPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTenantsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTenantsPage>>> = ({ signal }) => getAdminMainTenantsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTenantsPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>
export type GetAdminMainTenantsPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainTenantsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTenantsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTenantsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTenantsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTenantsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTenantsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTenantsPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainCategoriesPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainCategoriesPage200AllOf>(
      {url: `/api/v1/admin/main/categories`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainCategoriesPageQueryKey = () => {
    return [`/api/v1/admin/main/categories`] as const;
    }

    
export const getGetAdminMainCategoriesPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoriesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>> = ({ signal }) => getAdminMainCategoriesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoriesPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>
export type GetAdminMainCategoriesPageQueryError = ErrorType<void>


export function useGetAdminMainCategoriesPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainCategoriesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainCategoriesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoriesPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoriesPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainCategoriesPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoriesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>> = ({ signal }) => getAdminMainCategoriesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoriesPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>
export type GetAdminMainCategoriesPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainCategoriesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoriesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoriesPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainCategoriesPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoriesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>> = ({ signal }) => getAdminMainCategoriesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoriesPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>
export type GetAdminMainCategoriesPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainCategoriesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoriesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoriesPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainCategoryPage = (
    categoryId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainCategoryPage200AllOf>(
      {url: `/api/v1/admin/main/categories/${categoryId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainCategoryPageQueryKey = (categoryId: string,) => {
    return [`/api/v1/admin/main/categories/${categoryId}`] as const;
    }

    
export const getGetAdminMainCategoryPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoryPageQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoryPage>>> = ({ signal }) => getAdminMainCategoryPage(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoryPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>
export type GetAdminMainCategoryPageQueryError = ErrorType<void>


export function useGetAdminMainCategoryPage<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainCategoryPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoryPage<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainCategoryPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoryPage<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoryPage<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoryPageQueryOptions(categoryId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainCategoryPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoryPageQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoryPage>>> = ({ signal }) => getAdminMainCategoryPage(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoryPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>
export type GetAdminMainCategoryPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainCategoryPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoryPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoryPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoryPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoryPageSuspenseQueryOptions(categoryId,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainCategoryPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>, TError = ErrorType<void>>(categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoryPageQueryKey(categoryId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoryPage>>> = ({ signal }) => getAdminMainCategoryPage(categoryId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoryPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>
export type GetAdminMainCategoryPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainCategoryPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>, TError = ErrorType<void>>(
 categoryId: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoryPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoryPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoryPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoryPage>>>, TError = ErrorType<void>>(
 categoryId: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoryPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoryPageSuspenseInfiniteQueryOptions(categoryId,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainCategoriesEditPage = (
    categoryId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainCategoriesEditPage200AllOf>(
      {url: `/api/v1/admin/main/categories/${categoryId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainCategoriesEditPageQueryKey = (categoryId: string,
    type: string,) => {
    return [`/api/v1/admin/main/categories/${categoryId}/${type}`] as const;
    }

    
export const getGetAdminMainCategoriesEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(categoryId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoriesEditPageQueryKey(categoryId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>> = ({ signal }) => getAdminMainCategoriesEditPage(categoryId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(categoryId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoriesEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>
export type GetAdminMainCategoriesEditPageQueryError = ErrorType<void>


export function useGetAdminMainCategoriesEditPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesEditPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesEditPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoriesEditPage<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoriesEditPageQueryOptions(categoryId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainCategoriesEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoriesEditPageQueryKey(categoryId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>> = ({ signal }) => getAdminMainCategoriesEditPage(categoryId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoriesEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>
export type GetAdminMainCategoriesEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainCategoriesEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoriesEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoriesEditPageSuspenseQueryOptions(categoryId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainCategoriesEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>, TError = ErrorType<void>>(categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainCategoriesEditPageQueryKey(categoryId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>> = ({ signal }) => getAdminMainCategoriesEditPage(categoryId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainCategoriesEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>
export type GetAdminMainCategoriesEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainCategoriesEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainCategoriesEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainCategoriesEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>>, TError = ErrorType<void>>(
 categoryId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainCategoriesEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainCategoriesEditPageSuspenseInfiniteQueryOptions(categoryId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainServicesPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainServicesPage200AllOf>(
      {url: `/api/v1/admin/main/services`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainServicesPageQueryKey = () => {
    return [`/api/v1/admin/main/services`] as const;
    }

    
export const getGetAdminMainServicesPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainServicesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainServicesPage>>> = ({ signal }) => getAdminMainServicesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainServicesPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainServicesPage>>>
export type GetAdminMainServicesPageQueryError = ErrorType<void>


export function useGetAdminMainServicesPage<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainServicesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainServicesPage<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainServicesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainServicesPage<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainServicesPage<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainServicesPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainServicesPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainServicesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainServicesPage>>> = ({ signal }) => getAdminMainServicesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainServicesPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainServicesPage>>>
export type GetAdminMainServicesPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainServicesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainServicesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainServicesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainServicesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainServicesPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainServicesPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainServicesPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainServicesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainServicesPage>>> = ({ signal }) => getAdminMainServicesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainServicesPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainServicesPage>>>
export type GetAdminMainServicesPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainServicesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainServicesPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainServicesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainServicesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainServicesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainServicesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainServicesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainServicesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainServicesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainServicesPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainGroupsPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainGroupsPage200AllOf>(
      {url: `/api/v1/admin/main/groups`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainGroupsPageQueryKey = () => {
    return [`/api/v1/admin/main/groups`] as const;
    }

    
export const getGetAdminMainGroupsPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainGroupsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainGroupsPage>>> = ({ signal }) => getAdminMainGroupsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainGroupsPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>
export type GetAdminMainGroupsPageQueryError = ErrorType<void>


export function useGetAdminMainGroupsPage<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainGroupsPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupsPage<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainGroupsPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupsPage<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainGroupsPage<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainGroupsPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainGroupsPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainGroupsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainGroupsPage>>> = ({ signal }) => getAdminMainGroupsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainGroupsPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>
export type GetAdminMainGroupsPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainGroupsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainGroupsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainGroupsPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainGroupsPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainGroupsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainGroupsPage>>> = ({ signal }) => getAdminMainGroupsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainGroupsPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>
export type GetAdminMainGroupsPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainGroupsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainGroupsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainGroupsPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainGroupEditPage = (
    groupId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainGroupEditPage200AllOf>(
      {url: `/api/v1/admin/main/groups/${groupId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainGroupEditPageQueryKey = (groupId: string,
    type: string,) => {
    return [`/api/v1/admin/main/groups/${groupId}/${type}`] as const;
    }

    
export const getGetAdminMainGroupEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(groupId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainGroupEditPageQueryKey(groupId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>> = ({ signal }) => getAdminMainGroupEditPage(groupId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(groupId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainGroupEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>
export type GetAdminMainGroupEditPageQueryError = ErrorType<void>


export function useGetAdminMainGroupEditPage<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainGroupEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupEditPage<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainGroupEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupEditPage<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainGroupEditPage<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainGroupEditPageQueryOptions(groupId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainGroupEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainGroupEditPageQueryKey(groupId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>> = ({ signal }) => getAdminMainGroupEditPage(groupId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainGroupEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>
export type GetAdminMainGroupEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainGroupEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainGroupEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainGroupEditPageSuspenseQueryOptions(groupId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainGroupEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>, TError = ErrorType<void>>(groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainGroupEditPageQueryKey(groupId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>> = ({ signal }) => getAdminMainGroupEditPage(groupId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainGroupEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>
export type GetAdminMainGroupEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainGroupEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainGroupEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainGroupEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>>, TError = ErrorType<void>>(
 groupId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainGroupEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainGroupEditPageSuspenseInfiniteQueryOptions(groupId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainTimelinesPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainTimelinesPage200AllOf>(
      {url: `/api/v1/admin/main/timelines`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainTimelinesPageQueryKey = () => {
    return [`/api/v1/admin/main/timelines`] as const;
    }

    
export const getGetAdminMainTimelinesPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTimelinesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>> = ({ signal }) => getAdminMainTimelinesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTimelinesPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>
export type GetAdminMainTimelinesPageQueryError = ErrorType<void>


export function useGetAdminMainTimelinesPage<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTimelinesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelinesPage<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTimelinesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelinesPage<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTimelinesPage<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTimelinesPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTimelinesPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTimelinesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>> = ({ signal }) => getAdminMainTimelinesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTimelinesPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>
export type GetAdminMainTimelinesPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainTimelinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTimelinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTimelinesPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTimelinesPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTimelinesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>> = ({ signal }) => getAdminMainTimelinesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTimelinesPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>
export type GetAdminMainTimelinesPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainTimelinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTimelinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTimelinesPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainTimelineEditPage = (
    timelineId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainTimelineEditPage200AllOf>(
      {url: `/api/v1/admin/main/timelines/${timelineId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainTimelineEditPageQueryKey = (timelineId: string,
    type: string,) => {
    return [`/api/v1/admin/main/timelines/${timelineId}/${type}`] as const;
    }

    
export const getGetAdminMainTimelineEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(timelineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTimelineEditPageQueryKey(timelineId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>> = ({ signal }) => getAdminMainTimelineEditPage(timelineId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(timelineId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTimelineEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>
export type GetAdminMainTimelineEditPageQueryError = ErrorType<void>


export function useGetAdminMainTimelineEditPage<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelineEditPage<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelineEditPage<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTimelineEditPage<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTimelineEditPageQueryOptions(timelineId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTimelineEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTimelineEditPageQueryKey(timelineId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>> = ({ signal }) => getAdminMainTimelineEditPage(timelineId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTimelineEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>
export type GetAdminMainTimelineEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainTimelineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTimelineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTimelineEditPageSuspenseQueryOptions(timelineId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTimelineEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>, TError = ErrorType<void>>(timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTimelineEditPageQueryKey(timelineId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>> = ({ signal }) => getAdminMainTimelineEditPage(timelineId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTimelineEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>
export type GetAdminMainTimelineEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainTimelineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTimelineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTimelineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>>, TError = ErrorType<void>>(
 timelineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTimelineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTimelineEditPageSuspenseInfiniteQueryOptions(timelineId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainSessionsPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainSessionsPage200AllOf>(
      {url: `/api/v1/admin/main/sessions`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainSessionsPageQueryKey = () => {
    return [`/api/v1/admin/main/sessions`] as const;
    }

    
export const getGetAdminMainSessionsPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainSessionsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainSessionsPage>>> = ({ signal }) => getAdminMainSessionsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainSessionsPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>
export type GetAdminMainSessionsPageQueryError = ErrorType<void>


export function useGetAdminMainSessionsPage<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainSessionsPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionsPage<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainSessionsPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionsPage<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainSessionsPage<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainSessionsPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainSessionsPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainSessionsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainSessionsPage>>> = ({ signal }) => getAdminMainSessionsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainSessionsPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>
export type GetAdminMainSessionsPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainSessionsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainSessionsPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainSessionsPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainSessionsPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainSessionsPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainSessionsPage>>> = ({ signal }) => getAdminMainSessionsPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainSessionsPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>
export type GetAdminMainSessionsPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainSessionsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainSessionsPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionsPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionsPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainSessionsPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainSessionEditPage = (
    sessionId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainSessionEditPage200AllOf>(
      {url: `/api/v1/admin/main/sessions/${sessionId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainSessionEditPageQueryKey = (sessionId: string,
    type: string,) => {
    return [`/api/v1/admin/main/sessions/${sessionId}/${type}`] as const;
    }

    
export const getGetAdminMainSessionEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(sessionId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainSessionEditPageQueryKey(sessionId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>> = ({ signal }) => getAdminMainSessionEditPage(sessionId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(sessionId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainSessionEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>
export type GetAdminMainSessionEditPageQueryError = ErrorType<void>


export function useGetAdminMainSessionEditPage<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainSessionEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionEditPage<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainSessionEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionEditPage<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainSessionEditPage<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainSessionEditPageQueryOptions(sessionId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainSessionEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainSessionEditPageQueryKey(sessionId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>> = ({ signal }) => getAdminMainSessionEditPage(sessionId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainSessionEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>
export type GetAdminMainSessionEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainSessionEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainSessionEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainSessionEditPageSuspenseQueryOptions(sessionId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainSessionEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>, TError = ErrorType<void>>(sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainSessionEditPageQueryKey(sessionId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>> = ({ signal }) => getAdminMainSessionEditPage(sessionId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainSessionEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>
export type GetAdminMainSessionEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainSessionEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainSessionEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainSessionEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>>, TError = ErrorType<void>>(
 sessionId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainSessionEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainSessionEditPageSuspenseInfiniteQueryOptions(sessionId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainRoutinesPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainRoutinesPage200AllOf>(
      {url: `/api/v1/admin/main/routines`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainRoutinesPageQueryKey = () => {
    return [`/api/v1/admin/main/routines`] as const;
    }

    
export const getGetAdminMainRoutinesPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainRoutinesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>> = ({ signal }) => getAdminMainRoutinesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainRoutinesPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>
export type GetAdminMainRoutinesPageQueryError = ErrorType<void>


export function useGetAdminMainRoutinesPage<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainRoutinesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutinesPage<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainRoutinesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutinesPage<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainRoutinesPage<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainRoutinesPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainRoutinesPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainRoutinesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>> = ({ signal }) => getAdminMainRoutinesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainRoutinesPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>
export type GetAdminMainRoutinesPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainRoutinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainRoutinesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainRoutinesPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainRoutinesPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainRoutinesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>> = ({ signal }) => getAdminMainRoutinesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainRoutinesPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>
export type GetAdminMainRoutinesPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainRoutinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainRoutinesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutinesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainRoutinesPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainRoutineEditPage = (
    routineId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainRoutineEditPage200AllOf>(
      {url: `/api/v1/admin/main/routines/${routineId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainRoutineEditPageQueryKey = (routineId: string,
    type: string,) => {
    return [`/api/v1/admin/main/routines/${routineId}/${type}`] as const;
    }

    
export const getGetAdminMainRoutineEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(routineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainRoutineEditPageQueryKey(routineId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>> = ({ signal }) => getAdminMainRoutineEditPage(routineId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(routineId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainRoutineEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>
export type GetAdminMainRoutineEditPageQueryError = ErrorType<void>


export function useGetAdminMainRoutineEditPage<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutineEditPage<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutineEditPage<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainRoutineEditPage<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainRoutineEditPageQueryOptions(routineId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainRoutineEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainRoutineEditPageQueryKey(routineId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>> = ({ signal }) => getAdminMainRoutineEditPage(routineId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainRoutineEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>
export type GetAdminMainRoutineEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainRoutineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainRoutineEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainRoutineEditPageSuspenseQueryOptions(routineId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainRoutineEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>, TError = ErrorType<void>>(routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainRoutineEditPageQueryKey(routineId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>> = ({ signal }) => getAdminMainRoutineEditPage(routineId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainRoutineEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>
export type GetAdminMainRoutineEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainRoutineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainRoutineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainRoutineEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>>, TError = ErrorType<void>>(
 routineId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainRoutineEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainRoutineEditPageSuspenseInfiniteQueryOptions(routineId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainTasksPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainTasksPage200AllOf>(
      {url: `/api/v1/admin/main/tasks`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainTasksPageQueryKey = () => {
    return [`/api/v1/admin/main/tasks`] as const;
    }

    
export const getGetAdminMainTasksPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTasksPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTasksPage>>> = ({ signal }) => getAdminMainTasksPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTasksPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTasksPage>>>
export type GetAdminMainTasksPageQueryError = ErrorType<void>


export function useGetAdminMainTasksPage<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTasksPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTasksPage<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTasksPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTasksPage<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTasksPage<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTasksPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTasksPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTasksPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTasksPage>>> = ({ signal }) => getAdminMainTasksPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTasksPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTasksPage>>>
export type GetAdminMainTasksPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainTasksPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTasksPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTasksPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTasksPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTasksPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTasksPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTasksPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTasksPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTasksPage>>> = ({ signal }) => getAdminMainTasksPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTasksPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTasksPage>>>
export type GetAdminMainTasksPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainTasksPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTasksPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTasksPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTasksPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTasksPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTasksPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTasksPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTasksPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTasksPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTasksPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainTaskEditPage = (
    taskId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainTaskEditPage200AllOf>(
      {url: `/api/v1/admin/main/tasks/${taskId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainTaskEditPageQueryKey = (taskId: string,
    type: string,) => {
    return [`/api/v1/admin/main/tasks/${taskId}/${type}`] as const;
    }

    
export const getGetAdminMainTaskEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(taskId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTaskEditPageQueryKey(taskId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>> = ({ signal }) => getAdminMainTaskEditPage(taskId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTaskEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>
export type GetAdminMainTaskEditPageQueryError = ErrorType<void>


export function useGetAdminMainTaskEditPage<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTaskEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTaskEditPage<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainTaskEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTaskEditPage<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTaskEditPage<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTaskEditPageQueryOptions(taskId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTaskEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTaskEditPageQueryKey(taskId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>> = ({ signal }) => getAdminMainTaskEditPage(taskId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTaskEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>
export type GetAdminMainTaskEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainTaskEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTaskEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTaskEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTaskEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTaskEditPageSuspenseQueryOptions(taskId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainTaskEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>, TError = ErrorType<void>>(taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainTaskEditPageQueryKey(taskId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>> = ({ signal }) => getAdminMainTaskEditPage(taskId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainTaskEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>
export type GetAdminMainTaskEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainTaskEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTaskEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainTaskEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainTaskEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>>, TError = ErrorType<void>>(
 taskId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainTaskEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainTaskEditPageSuspenseInfiniteQueryOptions(taskId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainExercisesPage = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainExercisesPage200AllOf>(
      {url: `/api/v1/admin/main/exercises`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainExercisesPageQueryKey = () => {
    return [`/api/v1/admin/main/exercises`] as const;
    }

    
export const getGetAdminMainExercisesPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainExercisesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainExercisesPage>>> = ({ signal }) => getAdminMainExercisesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainExercisesPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>
export type GetAdminMainExercisesPageQueryError = ErrorType<void>


export function useGetAdminMainExercisesPage<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainExercisesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExercisesPage<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainExercisesPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExercisesPage<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainExercisesPage<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainExercisesPageQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainExercisesPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainExercisesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainExercisesPage>>> = ({ signal }) => getAdminMainExercisesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainExercisesPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>
export type GetAdminMainExercisesPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainExercisesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExercisesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExercisesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainExercisesPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainExercisesPageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainExercisesPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>, TError = ErrorType<void>>( options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainExercisesPageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainExercisesPage>>> = ({ signal }) => getAdminMainExercisesPage(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainExercisesPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>
export type GetAdminMainExercisesPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainExercisesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>, TError = ErrorType<void>>(
  options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExercisesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExercisesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainExercisesPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExercisesPage>>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExercisesPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainExercisesPageSuspenseInfiniteQueryOptions(options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const getAdminMainExerciseEditPage = (
    exerciseId: string,
    type: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<GetAdminMainExerciseEditPage200AllOf>(
      {url: `/api/v1/admin/main/exercises/${exerciseId}/${type}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetAdminMainExerciseEditPageQueryKey = (exerciseId: string,
    type: string,) => {
    return [`/api/v1/admin/main/exercises/${exerciseId}/${type}`] as const;
    }

    
export const getGetAdminMainExerciseEditPageQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(exerciseId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainExerciseEditPageQueryKey(exerciseId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>> = ({ signal }) => getAdminMainExerciseEditPage(exerciseId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(exerciseId && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainExerciseEditPageQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>
export type GetAdminMainExerciseEditPageQueryError = ErrorType<void>


export function useGetAdminMainExerciseEditPage<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExerciseEditPage<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>,
          TError,
          TData
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExerciseEditPage<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainExerciseEditPage<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainExerciseEditPageQueryOptions(exerciseId,type,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainExerciseEditPageSuspenseQueryOptions = <TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainExerciseEditPageQueryKey(exerciseId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>> = ({ signal }) => getAdminMainExerciseEditPage(exerciseId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainExerciseEditPageSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>
export type GetAdminMainExerciseEditPageSuspenseQueryError = ErrorType<void>


export function useGetAdminMainExerciseEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options: { query:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExerciseEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExerciseEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainExerciseEditPageSuspense<TData = Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainExerciseEditPageSuspenseQueryOptions(exerciseId,type,options)

  const query = useSuspenseQuery(queryOptions) as  UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



export const getGetAdminMainExerciseEditPageSuspenseInfiniteQueryOptions = <TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>, TError = ErrorType<void>>(exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAdminMainExerciseEditPageQueryKey(exerciseId,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>> = ({ signal }) => getAdminMainExerciseEditPage(exerciseId,type, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetAdminMainExerciseEditPageSuspenseInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>
export type GetAdminMainExerciseEditPageSuspenseInfiniteQueryError = ErrorType<void>


export function useGetAdminMainExerciseEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options: { query:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExerciseEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetAdminMainExerciseEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }

export function useGetAdminMainExerciseEditPageSuspenseInfinite<TData = InfiniteData<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>>, TError = ErrorType<void>>(
 exerciseId: string,
    type: string, options?: { query?:Partial<UseSuspenseInfiniteQueryOptions<Awaited<ReturnType<typeof getAdminMainExerciseEditPage>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}

  ):  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetAdminMainExerciseEditPageSuspenseInfiniteQueryOptions(exerciseId,type,options)

  const query = useSuspenseInfiniteQuery(queryOptions) as  UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




