/**
 * Generated by orval v6.25.0 üç∫
 * Do not edit manually.
 * PROMISE Server
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  CreateAuthzDto,
  CreateSignUpPayloadDto,
  LoginPayloadDto,
  UpdateAuthzDto
} from './model'
import {
  faker
} from '@faker-js/faker'
import {
  HttpResponse,
  delay,
  http
} from 'msw'
import type {
  MenuDto,
  TokenDto
} from './model'




export const login = (
    loginPayloadDto: LoginPayloadDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TokenDto>> => {
    
    return axios.post(
      `http://localhost:3004/api/auth/login`,
      loginPayloadDto,options
    );
  }



export const getLoginMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginPayloadDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginPayloadDto}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof login>>, {data: LoginPayloadDto}> = (props) => {
          const {data} = props ?? {};

          return  login(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type LoginMutationResult = NonNullable<Awaited<ReturnType<typeof login>>>
    export type LoginMutationBody = LoginPayloadDto
    export type LoginMutationError = AxiosError<unknown>

    export const useLogin = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof login>>, TError,{data: LoginPayloadDto}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getLoginMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const signUpUser = (
    createSignUpPayloadDto: CreateSignUpPayloadDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `http://localhost:3004/api/auth/sign-up`,
      createSignUpPayloadDto,options
    );
  }



export const getSignUpUserMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: CreateSignUpPayloadDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: CreateSignUpPayloadDto}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof signUpUser>>, {data: CreateSignUpPayloadDto}> = (props) => {
          const {data} = props ?? {};

          return  signUpUser(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type SignUpUserMutationResult = NonNullable<Awaited<ReturnType<typeof signUpUser>>>
    export type SignUpUserMutationBody = CreateSignUpPayloadDto
    export type SignUpUserMutationError = AxiosError<unknown>

    export const useSignUpUser = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof signUpUser>>, TError,{data: CreateSignUpPayloadDto}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getSignUpUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const create = (
    createAuthzDto: CreateAuthzDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.post(
      `http://localhost:3004/api/authz`,
      createAuthzDto,options
    );
  }



export const getCreateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: CreateAuthzDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: CreateAuthzDto}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof create>>, {data: CreateAuthzDto}> = (props) => {
          const {data} = props ?? {};

          return  create(data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type CreateMutationResult = NonNullable<Awaited<ReturnType<typeof create>>>
    export type CreateMutationBody = CreateAuthzDto
    export type CreateMutationError = AxiosError<unknown>

    export const useCreate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof create>>, TError,{data: CreateAuthzDto}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getCreateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const findAll = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `http://localhost:3004/api/authz`,options
    );
  }


export const getFindAllQueryKey = () => {
    return [`http://localhost:3004/api/authz`] as const;
    }

    
export const getFindAllQueryOptions = <TData = Awaited<ReturnType<typeof findAll>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findAll>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findAll>>> = ({ signal }) => findAll({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findAll>>, TError, TData> & { queryKey: QueryKey }
}

export type FindAllQueryResult = NonNullable<Awaited<ReturnType<typeof findAll>>>
export type FindAllQueryError = AxiosError<unknown>

export const useFindAll = <TData = Awaited<ReturnType<typeof findAll>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findAll>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFindAllQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const findOne = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.get(
      `http://localhost:3004/api/authz/${id}`,options
    );
  }


export const getFindOneQueryKey = (id: string,) => {
    return [`http://localhost:3004/api/authz/${id}`] as const;
    }

    
export const getFindOneQueryOptions = <TData = Awaited<ReturnType<typeof findOne>>, TError = AxiosError<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findOne>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof findOne>>> = ({ signal }) => findOne(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof findOne>>, TError, TData> & { queryKey: QueryKey }
}

export type FindOneQueryResult = NonNullable<Awaited<ReturnType<typeof findOne>>>
export type FindOneQueryError = AxiosError<unknown>

export const useFindOne = <TData = Awaited<ReturnType<typeof findOne>>, TError = AxiosError<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof findOne>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const update = (
    id: string,
    updateAuthzDto: UpdateAuthzDto, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.patch(
      `http://localhost:3004/api/authz/${id}`,
      updateAuthzDto,options
    );
  }



export const getUpdateMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: string;data: UpdateAuthzDto}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: string;data: UpdateAuthzDto}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof update>>, {id: string;data: UpdateAuthzDto}> = (props) => {
          const {id,data} = props ?? {};

          return  update(id,data,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type UpdateMutationResult = NonNullable<Awaited<ReturnType<typeof update>>>
    export type UpdateMutationBody = UpdateAuthzDto
    export type UpdateMutationError = AxiosError<unknown>

    export const useUpdate = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof update>>, TError,{id: string;data: UpdateAuthzDto}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getUpdateMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const remove = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<void>> => {
    
    return axios.delete(
      `http://localhost:3004/api/authz/${id}`,options
    );
  }



export const getRemoveMutationOptions = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof remove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof remove>>, TError,{id: string}, TContext> => {
 const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof remove>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  remove(id,axiosOptions)
        }

        


   return  { mutationFn, ...mutationOptions }}

    export type RemoveMutationResult = NonNullable<Awaited<ReturnType<typeof remove>>>
    
    export type RemoveMutationError = AxiosError<unknown>

    export const useRemove = <TError = AxiosError<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof remove>>, TError,{id: string}, TContext>, axios?: AxiosRequestConfig}
) => {

      const mutationOptions = getRemoveMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export const getMemus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MenuDto[]>> => {
    
    return axios.get(
      `http://localhost:3004/api/admin/menus`,options
    );
  }


export const getGetMemusQueryKey = () => {
    return [`http://localhost:3004/api/admin/menus`] as const;
    }

    
export const getGetMemusQueryOptions = <TData = Awaited<ReturnType<typeof getMemus>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMemusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemus>>> = ({ signal }) => getMemus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMemus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMemusQueryResult = NonNullable<Awaited<ReturnType<typeof getMemus>>>
export type GetMemusQueryError = AxiosError<unknown>

export const useGetMemus = <TData = Awaited<ReturnType<typeof getMemus>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemus>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetMemusQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}






export const getLoginResponseMock = (overrideResponse: any = {}): TokenDto => ({accessToken: faker.word.sample(), refreshToken: faker.word.sample(), ...overrideResponse})

export const getGetMemusResponseMock = (overrideResponse: any = {}): MenuDto[] => (Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({children: faker.helpers.arrayElement([Array.from({ length: faker.number.int({ min: 1, max: 10 }) }, (_, i) => i + 1).map(() => ({pathname: faker.helpers.arrayElement(['admin/userService/users','admin/userService/users/:id'] as const), text: faker.word.sample(), ...overrideResponse})), undefined]), pathname: faker.helpers.arrayElement([faker.helpers.arrayElement(['admin/userService/users','admin/userService/users/:id'] as const), undefined]), text: faker.word.sample(), ...overrideResponse})))


export const getLoginMockHandler = (overrideResponse?: TokenDto) => {
  return http.post('*/auth/login', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse ? overrideResponse : getLoginResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getSignUpUserMockHandler = () => {
  return http.post('*/auth/sign-up', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getCreateMockHandler = () => {
  return http.post('*/authz', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getFindAllMockHandler = () => {
  return http.get('*/authz', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getFindOneMockHandler = () => {
  return http.get('*/authz/:id', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getUpdateMockHandler = () => {
  return http.patch('*/authz/:id', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getRemoveMockHandler = () => {
  return http.delete('*/authz/:id', async () => {
    await delay(1000);
    return new HttpResponse(null,
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}

export const getGetMemusMockHandler = (overrideResponse?: MenuDto[]) => {
  return http.get('*/admin/menus', async () => {
    await delay(1000);
    return new HttpResponse(JSON.stringify(overrideResponse ? overrideResponse : getGetMemusResponseMock()),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
        }
      }
    )
  })
}
export const getPROMISEServerMock = () => [
  getLoginMockHandler(),
  getSignUpUserMockHandler(),
  getCreateMockHandler(),
  getFindAllMockHandler(),
  getFindOneMockHandler(),
  getUpdateMockHandler(),
  getRemoveMockHandler(),
  getGetMemusMockHandler()
]
