/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Tenant` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Tenant
 *
 */
export type TenantModel =
	runtime.Types.Result.DefaultSelection<Prisma.$TenantPayload>;

export type AggregateTenant = {
	_count: TenantCountAggregateOutputType | null;
	_avg: TenantAvgAggregateOutputType | null;
	_sum: TenantSumAggregateOutputType | null;
	_min: TenantMinAggregateOutputType | null;
	_max: TenantMaxAggregateOutputType | null;
};

export type TenantAvgAggregateOutputType = {
	seq: number | null;
};

export type TenantSumAggregateOutputType = {
	seq: number | null;
};

export type TenantMinAggregateOutputType = {
	id: string | null;
	seq: number | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	removedAt: Date | null;
	userId: string | null;
	spaceId: string | null;
	roleId: string | null;
	main: boolean | null;
};

export type TenantMaxAggregateOutputType = {
	id: string | null;
	seq: number | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	removedAt: Date | null;
	userId: string | null;
	spaceId: string | null;
	roleId: string | null;
	main: boolean | null;
};

export type TenantCountAggregateOutputType = {
	id: number;
	seq: number;
	createdAt: number;
	updatedAt: number;
	removedAt: number;
	userId: number;
	spaceId: number;
	roleId: number;
	main: number;
	_all: number;
};

export type TenantAvgAggregateInputType = {
	seq?: true;
};

export type TenantSumAggregateInputType = {
	seq?: true;
};

export type TenantMinAggregateInputType = {
	id?: true;
	seq?: true;
	createdAt?: true;
	updatedAt?: true;
	removedAt?: true;
	userId?: true;
	spaceId?: true;
	roleId?: true;
	main?: true;
};

export type TenantMaxAggregateInputType = {
	id?: true;
	seq?: true;
	createdAt?: true;
	updatedAt?: true;
	removedAt?: true;
	userId?: true;
	spaceId?: true;
	roleId?: true;
	main?: true;
};

export type TenantCountAggregateInputType = {
	id?: true;
	seq?: true;
	createdAt?: true;
	updatedAt?: true;
	removedAt?: true;
	userId?: true;
	spaceId?: true;
	roleId?: true;
	main?: true;
	_all?: true;
};

export type TenantAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Tenant to aggregate.
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Tenants to fetch.
	 */
	orderBy?:
		| Prisma.TenantOrderByWithRelationInput
		| Prisma.TenantOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.TenantWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Tenants from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Tenants.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Tenants
	 **/
	_count?: true | TenantCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: TenantAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: TenantSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: TenantMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: TenantMaxAggregateInputType;
};

export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
	[P in keyof T & keyof AggregateTenant]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateTenant[P]>
		: Prisma.GetScalarType<T[P], AggregateTenant[P]>;
};

export type TenantGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.TenantWhereInput;
	orderBy?:
		| Prisma.TenantOrderByWithAggregationInput
		| Prisma.TenantOrderByWithAggregationInput[];
	by: Prisma.TenantScalarFieldEnum[] | Prisma.TenantScalarFieldEnum;
	having?: Prisma.TenantScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: TenantCountAggregateInputType | true;
	_avg?: TenantAvgAggregateInputType;
	_sum?: TenantSumAggregateInputType;
	_min?: TenantMinAggregateInputType;
	_max?: TenantMaxAggregateInputType;
};

export type TenantGroupByOutputType = {
	id: string;
	seq: number;
	createdAt: Date;
	updatedAt: Date | null;
	removedAt: Date | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main: boolean;
	_count: TenantCountAggregateOutputType | null;
	_avg: TenantAvgAggregateOutputType | null;
	_sum: TenantSumAggregateOutputType | null;
	_min: TenantMinAggregateOutputType | null;
	_max: TenantMaxAggregateOutputType | null;
};

type GetTenantGroupByPayload<T extends TenantGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<TenantGroupByOutputType, T["by"]> & {
				[P in keyof T & keyof TenantGroupByOutputType]: P extends "_count"
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<T[P], TenantGroupByOutputType[P]>
					: Prisma.GetScalarType<T[P], TenantGroupByOutputType[P]>;
			}
		>
	>;

export type TenantWhereInput = {
	AND?: Prisma.TenantWhereInput | Prisma.TenantWhereInput[];
	OR?: Prisma.TenantWhereInput[];
	NOT?: Prisma.TenantWhereInput | Prisma.TenantWhereInput[];
	id?: Prisma.StringFilter<"Tenant"> | string;
	seq?: Prisma.IntFilter<"Tenant"> | number;
	createdAt?: Prisma.DateTimeFilter<"Tenant"> | Date | string;
	updatedAt?: Prisma.DateTimeNullableFilter<"Tenant"> | Date | string | null;
	removedAt?: Prisma.DateTimeNullableFilter<"Tenant"> | Date | string | null;
	userId?: Prisma.StringFilter<"Tenant"> | string;
	spaceId?: Prisma.StringFilter<"Tenant"> | string;
	roleId?: Prisma.StringFilter<"Tenant"> | string;
	main?: Prisma.BoolFilter<"Tenant"> | boolean;
	assignments?: Prisma.AssignmentListRelationFilter;
	categories?: Prisma.CategoryListRelationFilter;
	contents?: Prisma.ContentListRelationFilter;
	files?: Prisma.FileListRelationFilter;
	groups?: Prisma.GroupListRelationFilter;
	safeWallets?: Prisma.SafeWalletListRelationFilter;
	role?: Prisma.XOR<Prisma.RoleScalarRelationFilter, Prisma.RoleWhereInput>;
	space?: Prisma.XOR<Prisma.SpaceScalarRelationFilter, Prisma.SpaceWhereInput>;
	user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
};

export type TenantOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	removedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	spaceId?: Prisma.SortOrder;
	roleId?: Prisma.SortOrder;
	main?: Prisma.SortOrder;
	assignments?: Prisma.AssignmentOrderByRelationAggregateInput;
	categories?: Prisma.CategoryOrderByRelationAggregateInput;
	contents?: Prisma.ContentOrderByRelationAggregateInput;
	files?: Prisma.FileOrderByRelationAggregateInput;
	groups?: Prisma.GroupOrderByRelationAggregateInput;
	safeWallets?: Prisma.SafeWalletOrderByRelationAggregateInput;
	role?: Prisma.RoleOrderByWithRelationInput;
	space?: Prisma.SpaceOrderByWithRelationInput;
	user?: Prisma.UserOrderByWithRelationInput;
};

export type TenantWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		seq?: number;
		AND?: Prisma.TenantWhereInput | Prisma.TenantWhereInput[];
		OR?: Prisma.TenantWhereInput[];
		NOT?: Prisma.TenantWhereInput | Prisma.TenantWhereInput[];
		createdAt?: Prisma.DateTimeFilter<"Tenant"> | Date | string;
		updatedAt?: Prisma.DateTimeNullableFilter<"Tenant"> | Date | string | null;
		removedAt?: Prisma.DateTimeNullableFilter<"Tenant"> | Date | string | null;
		userId?: Prisma.StringFilter<"Tenant"> | string;
		spaceId?: Prisma.StringFilter<"Tenant"> | string;
		roleId?: Prisma.StringFilter<"Tenant"> | string;
		main?: Prisma.BoolFilter<"Tenant"> | boolean;
		assignments?: Prisma.AssignmentListRelationFilter;
		categories?: Prisma.CategoryListRelationFilter;
		contents?: Prisma.ContentListRelationFilter;
		files?: Prisma.FileListRelationFilter;
		groups?: Prisma.GroupListRelationFilter;
		safeWallets?: Prisma.SafeWalletListRelationFilter;
		role?: Prisma.XOR<Prisma.RoleScalarRelationFilter, Prisma.RoleWhereInput>;
		space?: Prisma.XOR<
			Prisma.SpaceScalarRelationFilter,
			Prisma.SpaceWhereInput
		>;
		user?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
	},
	"id" | "seq"
>;

export type TenantOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	removedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	spaceId?: Prisma.SortOrder;
	roleId?: Prisma.SortOrder;
	main?: Prisma.SortOrder;
	_count?: Prisma.TenantCountOrderByAggregateInput;
	_avg?: Prisma.TenantAvgOrderByAggregateInput;
	_max?: Prisma.TenantMaxOrderByAggregateInput;
	_min?: Prisma.TenantMinOrderByAggregateInput;
	_sum?: Prisma.TenantSumOrderByAggregateInput;
};

export type TenantScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.TenantScalarWhereWithAggregatesInput
		| Prisma.TenantScalarWhereWithAggregatesInput[];
	OR?: Prisma.TenantScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.TenantScalarWhereWithAggregatesInput
		| Prisma.TenantScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"Tenant"> | string;
	seq?: Prisma.IntWithAggregatesFilter<"Tenant"> | number;
	createdAt?: Prisma.DateTimeWithAggregatesFilter<"Tenant"> | Date | string;
	updatedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Tenant">
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Tenant">
		| Date
		| string
		| null;
	userId?: Prisma.StringWithAggregatesFilter<"Tenant"> | string;
	spaceId?: Prisma.StringWithAggregatesFilter<"Tenant"> | string;
	roleId?: Prisma.StringWithAggregatesFilter<"Tenant"> | string;
	main?: Prisma.BoolWithAggregatesFilter<"Tenant"> | boolean;
};

export type TenantCreateInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateManyInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
};

export type TenantUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
};

export type TenantUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
};

export type TenantScalarRelationFilter = {
	is?: Prisma.TenantWhereInput;
	isNot?: Prisma.TenantWhereInput;
};

export type TenantCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	removedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	spaceId?: Prisma.SortOrder;
	roleId?: Prisma.SortOrder;
	main?: Prisma.SortOrder;
};

export type TenantAvgOrderByAggregateInput = {
	seq?: Prisma.SortOrder;
};

export type TenantMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	removedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	spaceId?: Prisma.SortOrder;
	roleId?: Prisma.SortOrder;
	main?: Prisma.SortOrder;
};

export type TenantMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	removedAt?: Prisma.SortOrder;
	userId?: Prisma.SortOrder;
	spaceId?: Prisma.SortOrder;
	roleId?: Prisma.SortOrder;
	main?: Prisma.SortOrder;
};

export type TenantSumOrderByAggregateInput = {
	seq?: Prisma.SortOrder;
};

export type TenantListRelationFilter = {
	every?: Prisma.TenantWhereInput;
	some?: Prisma.TenantWhereInput;
	none?: Prisma.TenantWhereInput;
};

export type TenantOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type TenantCreateNestedOneWithoutCategoriesInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutCategoriesInput,
		Prisma.TenantUncheckedCreateWithoutCategoriesInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutCategoriesInput;
	connect?: Prisma.TenantWhereUniqueInput;
};

export type TenantUpdateOneRequiredWithoutCategoriesNestedInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutCategoriesInput,
		Prisma.TenantUncheckedCreateWithoutCategoriesInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutCategoriesInput;
	upsert?: Prisma.TenantUpsertWithoutCategoriesInput;
	connect?: Prisma.TenantWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TenantUpdateToOneWithWhereWithoutCategoriesInput,
			Prisma.TenantUpdateWithoutCategoriesInput
		>,
		Prisma.TenantUncheckedUpdateWithoutCategoriesInput
	>;
};

export type TenantCreateNestedOneWithoutGroupsInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutGroupsInput,
		Prisma.TenantUncheckedCreateWithoutGroupsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutGroupsInput;
	connect?: Prisma.TenantWhereUniqueInput;
};

export type TenantUpdateOneRequiredWithoutGroupsNestedInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutGroupsInput,
		Prisma.TenantUncheckedCreateWithoutGroupsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutGroupsInput;
	upsert?: Prisma.TenantUpsertWithoutGroupsInput;
	connect?: Prisma.TenantWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TenantUpdateToOneWithWhereWithoutGroupsInput,
			Prisma.TenantUpdateWithoutGroupsInput
		>,
		Prisma.TenantUncheckedUpdateWithoutGroupsInput
	>;
};

export type BoolFieldUpdateOperationsInput = {
	set?: boolean;
};

export type TenantCreateNestedOneWithoutAssignmentsInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutAssignmentsInput,
		Prisma.TenantUncheckedCreateWithoutAssignmentsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutAssignmentsInput;
	connect?: Prisma.TenantWhereUniqueInput;
};

export type TenantUpdateOneRequiredWithoutAssignmentsNestedInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutAssignmentsInput,
		Prisma.TenantUncheckedCreateWithoutAssignmentsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutAssignmentsInput;
	upsert?: Prisma.TenantUpsertWithoutAssignmentsInput;
	connect?: Prisma.TenantWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TenantUpdateToOneWithWhereWithoutAssignmentsInput,
			Prisma.TenantUpdateWithoutAssignmentsInput
		>,
		Prisma.TenantUncheckedUpdateWithoutAssignmentsInput
	>;
};

export type TenantCreateNestedOneWithoutContentsInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutContentsInput,
		Prisma.TenantUncheckedCreateWithoutContentsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutContentsInput;
	connect?: Prisma.TenantWhereUniqueInput;
};

export type TenantUpdateOneRequiredWithoutContentsNestedInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutContentsInput,
		Prisma.TenantUncheckedCreateWithoutContentsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutContentsInput;
	upsert?: Prisma.TenantUpsertWithoutContentsInput;
	connect?: Prisma.TenantWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TenantUpdateToOneWithWhereWithoutContentsInput,
			Prisma.TenantUpdateWithoutContentsInput
		>,
		Prisma.TenantUncheckedUpdateWithoutContentsInput
	>;
};

export type TenantCreateNestedOneWithoutFilesInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutFilesInput,
		Prisma.TenantUncheckedCreateWithoutFilesInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutFilesInput;
	connect?: Prisma.TenantWhereUniqueInput;
};

export type TenantUpdateOneRequiredWithoutFilesNestedInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutFilesInput,
		Prisma.TenantUncheckedCreateWithoutFilesInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutFilesInput;
	upsert?: Prisma.TenantUpsertWithoutFilesInput;
	connect?: Prisma.TenantWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TenantUpdateToOneWithWhereWithoutFilesInput,
			Prisma.TenantUpdateWithoutFilesInput
		>,
		Prisma.TenantUncheckedUpdateWithoutFilesInput
	>;
};

export type TenantCreateNestedManyWithoutRoleInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutRoleInput,
				Prisma.TenantUncheckedCreateWithoutRoleInput
		  >
		| Prisma.TenantCreateWithoutRoleInput[]
		| Prisma.TenantUncheckedCreateWithoutRoleInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutRoleInput
		| Prisma.TenantCreateOrConnectWithoutRoleInput[];
	createMany?: Prisma.TenantCreateManyRoleInputEnvelope;
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
};

export type TenantUncheckedCreateNestedManyWithoutRoleInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutRoleInput,
				Prisma.TenantUncheckedCreateWithoutRoleInput
		  >
		| Prisma.TenantCreateWithoutRoleInput[]
		| Prisma.TenantUncheckedCreateWithoutRoleInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutRoleInput
		| Prisma.TenantCreateOrConnectWithoutRoleInput[];
	createMany?: Prisma.TenantCreateManyRoleInputEnvelope;
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
};

export type TenantUpdateManyWithoutRoleNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutRoleInput,
				Prisma.TenantUncheckedCreateWithoutRoleInput
		  >
		| Prisma.TenantCreateWithoutRoleInput[]
		| Prisma.TenantUncheckedCreateWithoutRoleInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutRoleInput
		| Prisma.TenantCreateOrConnectWithoutRoleInput[];
	upsert?:
		| Prisma.TenantUpsertWithWhereUniqueWithoutRoleInput
		| Prisma.TenantUpsertWithWhereUniqueWithoutRoleInput[];
	createMany?: Prisma.TenantCreateManyRoleInputEnvelope;
	set?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	disconnect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	delete?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	update?:
		| Prisma.TenantUpdateWithWhereUniqueWithoutRoleInput
		| Prisma.TenantUpdateWithWhereUniqueWithoutRoleInput[];
	updateMany?:
		| Prisma.TenantUpdateManyWithWhereWithoutRoleInput
		| Prisma.TenantUpdateManyWithWhereWithoutRoleInput[];
	deleteMany?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
};

export type TenantUncheckedUpdateManyWithoutRoleNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutRoleInput,
				Prisma.TenantUncheckedCreateWithoutRoleInput
		  >
		| Prisma.TenantCreateWithoutRoleInput[]
		| Prisma.TenantUncheckedCreateWithoutRoleInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutRoleInput
		| Prisma.TenantCreateOrConnectWithoutRoleInput[];
	upsert?:
		| Prisma.TenantUpsertWithWhereUniqueWithoutRoleInput
		| Prisma.TenantUpsertWithWhereUniqueWithoutRoleInput[];
	createMany?: Prisma.TenantCreateManyRoleInputEnvelope;
	set?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	disconnect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	delete?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	update?:
		| Prisma.TenantUpdateWithWhereUniqueWithoutRoleInput
		| Prisma.TenantUpdateWithWhereUniqueWithoutRoleInput[];
	updateMany?:
		| Prisma.TenantUpdateManyWithWhereWithoutRoleInput
		| Prisma.TenantUpdateManyWithWhereWithoutRoleInput[];
	deleteMany?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
};

export type TenantCreateNestedOneWithoutSafeWalletsInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutSafeWalletsInput,
		Prisma.TenantUncheckedCreateWithoutSafeWalletsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutSafeWalletsInput;
	connect?: Prisma.TenantWhereUniqueInput;
};

export type TenantUpdateOneRequiredWithoutSafeWalletsNestedInput = {
	create?: Prisma.XOR<
		Prisma.TenantCreateWithoutSafeWalletsInput,
		Prisma.TenantUncheckedCreateWithoutSafeWalletsInput
	>;
	connectOrCreate?: Prisma.TenantCreateOrConnectWithoutSafeWalletsInput;
	upsert?: Prisma.TenantUpsertWithoutSafeWalletsInput;
	connect?: Prisma.TenantWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.TenantUpdateToOneWithWhereWithoutSafeWalletsInput,
			Prisma.TenantUpdateWithoutSafeWalletsInput
		>,
		Prisma.TenantUncheckedUpdateWithoutSafeWalletsInput
	>;
};

export type TenantCreateNestedManyWithoutSpaceInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutSpaceInput,
				Prisma.TenantUncheckedCreateWithoutSpaceInput
		  >
		| Prisma.TenantCreateWithoutSpaceInput[]
		| Prisma.TenantUncheckedCreateWithoutSpaceInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutSpaceInput
		| Prisma.TenantCreateOrConnectWithoutSpaceInput[];
	createMany?: Prisma.TenantCreateManySpaceInputEnvelope;
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
};

export type TenantUncheckedCreateNestedManyWithoutSpaceInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutSpaceInput,
				Prisma.TenantUncheckedCreateWithoutSpaceInput
		  >
		| Prisma.TenantCreateWithoutSpaceInput[]
		| Prisma.TenantUncheckedCreateWithoutSpaceInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutSpaceInput
		| Prisma.TenantCreateOrConnectWithoutSpaceInput[];
	createMany?: Prisma.TenantCreateManySpaceInputEnvelope;
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
};

export type TenantUpdateManyWithoutSpaceNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutSpaceInput,
				Prisma.TenantUncheckedCreateWithoutSpaceInput
		  >
		| Prisma.TenantCreateWithoutSpaceInput[]
		| Prisma.TenantUncheckedCreateWithoutSpaceInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutSpaceInput
		| Prisma.TenantCreateOrConnectWithoutSpaceInput[];
	upsert?:
		| Prisma.TenantUpsertWithWhereUniqueWithoutSpaceInput
		| Prisma.TenantUpsertWithWhereUniqueWithoutSpaceInput[];
	createMany?: Prisma.TenantCreateManySpaceInputEnvelope;
	set?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	disconnect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	delete?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	update?:
		| Prisma.TenantUpdateWithWhereUniqueWithoutSpaceInput
		| Prisma.TenantUpdateWithWhereUniqueWithoutSpaceInput[];
	updateMany?:
		| Prisma.TenantUpdateManyWithWhereWithoutSpaceInput
		| Prisma.TenantUpdateManyWithWhereWithoutSpaceInput[];
	deleteMany?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
};

export type TenantUncheckedUpdateManyWithoutSpaceNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutSpaceInput,
				Prisma.TenantUncheckedCreateWithoutSpaceInput
		  >
		| Prisma.TenantCreateWithoutSpaceInput[]
		| Prisma.TenantUncheckedCreateWithoutSpaceInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutSpaceInput
		| Prisma.TenantCreateOrConnectWithoutSpaceInput[];
	upsert?:
		| Prisma.TenantUpsertWithWhereUniqueWithoutSpaceInput
		| Prisma.TenantUpsertWithWhereUniqueWithoutSpaceInput[];
	createMany?: Prisma.TenantCreateManySpaceInputEnvelope;
	set?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	disconnect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	delete?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	update?:
		| Prisma.TenantUpdateWithWhereUniqueWithoutSpaceInput
		| Prisma.TenantUpdateWithWhereUniqueWithoutSpaceInput[];
	updateMany?:
		| Prisma.TenantUpdateManyWithWhereWithoutSpaceInput
		| Prisma.TenantUpdateManyWithWhereWithoutSpaceInput[];
	deleteMany?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
};

export type TenantCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutUserInput,
				Prisma.TenantUncheckedCreateWithoutUserInput
		  >
		| Prisma.TenantCreateWithoutUserInput[]
		| Prisma.TenantUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutUserInput
		| Prisma.TenantCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.TenantCreateManyUserInputEnvelope;
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
};

export type TenantUncheckedCreateNestedManyWithoutUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutUserInput,
				Prisma.TenantUncheckedCreateWithoutUserInput
		  >
		| Prisma.TenantCreateWithoutUserInput[]
		| Prisma.TenantUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutUserInput
		| Prisma.TenantCreateOrConnectWithoutUserInput[];
	createMany?: Prisma.TenantCreateManyUserInputEnvelope;
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
};

export type TenantUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutUserInput,
				Prisma.TenantUncheckedCreateWithoutUserInput
		  >
		| Prisma.TenantCreateWithoutUserInput[]
		| Prisma.TenantUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutUserInput
		| Prisma.TenantCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.TenantUpsertWithWhereUniqueWithoutUserInput
		| Prisma.TenantUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.TenantCreateManyUserInputEnvelope;
	set?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	disconnect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	delete?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	update?:
		| Prisma.TenantUpdateWithWhereUniqueWithoutUserInput
		| Prisma.TenantUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.TenantUpdateManyWithWhereWithoutUserInput
		| Prisma.TenantUpdateManyWithWhereWithoutUserInput[];
	deleteMany?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
};

export type TenantUncheckedUpdateManyWithoutUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.TenantCreateWithoutUserInput,
				Prisma.TenantUncheckedCreateWithoutUserInput
		  >
		| Prisma.TenantCreateWithoutUserInput[]
		| Prisma.TenantUncheckedCreateWithoutUserInput[];
	connectOrCreate?:
		| Prisma.TenantCreateOrConnectWithoutUserInput
		| Prisma.TenantCreateOrConnectWithoutUserInput[];
	upsert?:
		| Prisma.TenantUpsertWithWhereUniqueWithoutUserInput
		| Prisma.TenantUpsertWithWhereUniqueWithoutUserInput[];
	createMany?: Prisma.TenantCreateManyUserInputEnvelope;
	set?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	disconnect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	delete?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	connect?: Prisma.TenantWhereUniqueInput | Prisma.TenantWhereUniqueInput[];
	update?:
		| Prisma.TenantUpdateWithWhereUniqueWithoutUserInput
		| Prisma.TenantUpdateWithWhereUniqueWithoutUserInput[];
	updateMany?:
		| Prisma.TenantUpdateManyWithWhereWithoutUserInput
		| Prisma.TenantUpdateManyWithWhereWithoutUserInput[];
	deleteMany?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
};

export type TenantCreateWithoutCategoriesInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutCategoriesInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutCategoriesInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutCategoriesInput,
		Prisma.TenantUncheckedCreateWithoutCategoriesInput
	>;
};

export type TenantUpsertWithoutCategoriesInput = {
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutCategoriesInput,
		Prisma.TenantUncheckedUpdateWithoutCategoriesInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutCategoriesInput,
		Prisma.TenantUncheckedCreateWithoutCategoriesInput
	>;
	where?: Prisma.TenantWhereInput;
};

export type TenantUpdateToOneWithWhereWithoutCategoriesInput = {
	where?: Prisma.TenantWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutCategoriesInput,
		Prisma.TenantUncheckedUpdateWithoutCategoriesInput
	>;
};

export type TenantUpdateWithoutCategoriesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutCategoriesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateWithoutGroupsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutGroupsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutGroupsInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutGroupsInput,
		Prisma.TenantUncheckedCreateWithoutGroupsInput
	>;
};

export type TenantUpsertWithoutGroupsInput = {
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutGroupsInput,
		Prisma.TenantUncheckedUpdateWithoutGroupsInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutGroupsInput,
		Prisma.TenantUncheckedCreateWithoutGroupsInput
	>;
	where?: Prisma.TenantWhereInput;
};

export type TenantUpdateToOneWithWhereWithoutGroupsInput = {
	where?: Prisma.TenantWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutGroupsInput,
		Prisma.TenantUncheckedUpdateWithoutGroupsInput
	>;
};

export type TenantUpdateWithoutGroupsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutGroupsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateWithoutAssignmentsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutAssignmentsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutAssignmentsInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutAssignmentsInput,
		Prisma.TenantUncheckedCreateWithoutAssignmentsInput
	>;
};

export type TenantUpsertWithoutAssignmentsInput = {
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutAssignmentsInput,
		Prisma.TenantUncheckedUpdateWithoutAssignmentsInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutAssignmentsInput,
		Prisma.TenantUncheckedCreateWithoutAssignmentsInput
	>;
	where?: Prisma.TenantWhereInput;
};

export type TenantUpdateToOneWithWhereWithoutAssignmentsInput = {
	where?: Prisma.TenantWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutAssignmentsInput,
		Prisma.TenantUncheckedUpdateWithoutAssignmentsInput
	>;
};

export type TenantUpdateWithoutAssignmentsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutAssignmentsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateWithoutContentsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutContentsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutContentsInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutContentsInput,
		Prisma.TenantUncheckedCreateWithoutContentsInput
	>;
};

export type TenantUpsertWithoutContentsInput = {
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutContentsInput,
		Prisma.TenantUncheckedUpdateWithoutContentsInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutContentsInput,
		Prisma.TenantUncheckedCreateWithoutContentsInput
	>;
	where?: Prisma.TenantWhereInput;
};

export type TenantUpdateToOneWithWhereWithoutContentsInput = {
	where?: Prisma.TenantWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutContentsInput,
		Prisma.TenantUncheckedUpdateWithoutContentsInput
	>;
};

export type TenantUpdateWithoutContentsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutContentsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateWithoutFilesInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutFilesInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutFilesInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutFilesInput,
		Prisma.TenantUncheckedCreateWithoutFilesInput
	>;
};

export type TenantUpsertWithoutFilesInput = {
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutFilesInput,
		Prisma.TenantUncheckedUpdateWithoutFilesInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutFilesInput,
		Prisma.TenantUncheckedCreateWithoutFilesInput
	>;
	where?: Prisma.TenantWhereInput;
};

export type TenantUpdateToOneWithWhereWithoutFilesInput = {
	where?: Prisma.TenantWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutFilesInput,
		Prisma.TenantUncheckedUpdateWithoutFilesInput
	>;
};

export type TenantUpdateWithoutFilesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutFilesInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateWithoutRoleInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutRoleInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutRoleInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutRoleInput,
		Prisma.TenantUncheckedCreateWithoutRoleInput
	>;
};

export type TenantCreateManyRoleInputEnvelope = {
	data: Prisma.TenantCreateManyRoleInput | Prisma.TenantCreateManyRoleInput[];
	skipDuplicates?: boolean;
};

export type TenantUpsertWithWhereUniqueWithoutRoleInput = {
	where: Prisma.TenantWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutRoleInput,
		Prisma.TenantUncheckedUpdateWithoutRoleInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutRoleInput,
		Prisma.TenantUncheckedCreateWithoutRoleInput
	>;
};

export type TenantUpdateWithWhereUniqueWithoutRoleInput = {
	where: Prisma.TenantWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutRoleInput,
		Prisma.TenantUncheckedUpdateWithoutRoleInput
	>;
};

export type TenantUpdateManyWithWhereWithoutRoleInput = {
	where: Prisma.TenantScalarWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateManyMutationInput,
		Prisma.TenantUncheckedUpdateManyWithoutRoleInput
	>;
};

export type TenantScalarWhereInput = {
	AND?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
	OR?: Prisma.TenantScalarWhereInput[];
	NOT?: Prisma.TenantScalarWhereInput | Prisma.TenantScalarWhereInput[];
	id?: Prisma.StringFilter<"Tenant"> | string;
	seq?: Prisma.IntFilter<"Tenant"> | number;
	createdAt?: Prisma.DateTimeFilter<"Tenant"> | Date | string;
	updatedAt?: Prisma.DateTimeNullableFilter<"Tenant"> | Date | string | null;
	removedAt?: Prisma.DateTimeNullableFilter<"Tenant"> | Date | string | null;
	userId?: Prisma.StringFilter<"Tenant"> | string;
	spaceId?: Prisma.StringFilter<"Tenant"> | string;
	roleId?: Prisma.StringFilter<"Tenant"> | string;
	main?: Prisma.BoolFilter<"Tenant"> | boolean;
};

export type TenantCreateWithoutSafeWalletsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutSafeWalletsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutSafeWalletsInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutSafeWalletsInput,
		Prisma.TenantUncheckedCreateWithoutSafeWalletsInput
	>;
};

export type TenantUpsertWithoutSafeWalletsInput = {
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutSafeWalletsInput,
		Prisma.TenantUncheckedUpdateWithoutSafeWalletsInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutSafeWalletsInput,
		Prisma.TenantUncheckedCreateWithoutSafeWalletsInput
	>;
	where?: Prisma.TenantWhereInput;
};

export type TenantUpdateToOneWithWhereWithoutSafeWalletsInput = {
	where?: Prisma.TenantWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutSafeWalletsInput,
		Prisma.TenantUncheckedUpdateWithoutSafeWalletsInput
	>;
};

export type TenantUpdateWithoutSafeWalletsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutSafeWalletsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantCreateWithoutSpaceInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	user: Prisma.UserCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutSpaceInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutSpaceInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutSpaceInput,
		Prisma.TenantUncheckedCreateWithoutSpaceInput
	>;
};

export type TenantCreateManySpaceInputEnvelope = {
	data: Prisma.TenantCreateManySpaceInput | Prisma.TenantCreateManySpaceInput[];
	skipDuplicates?: boolean;
};

export type TenantUpsertWithWhereUniqueWithoutSpaceInput = {
	where: Prisma.TenantWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutSpaceInput,
		Prisma.TenantUncheckedUpdateWithoutSpaceInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutSpaceInput,
		Prisma.TenantUncheckedCreateWithoutSpaceInput
	>;
};

export type TenantUpdateWithWhereUniqueWithoutSpaceInput = {
	where: Prisma.TenantWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutSpaceInput,
		Prisma.TenantUncheckedUpdateWithoutSpaceInput
	>;
};

export type TenantUpdateManyWithWhereWithoutSpaceInput = {
	where: Prisma.TenantScalarWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateManyMutationInput,
		Prisma.TenantUncheckedUpdateManyWithoutSpaceInput
	>;
};

export type TenantCreateWithoutUserInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	main?: boolean;
	assignments?: Prisma.AssignmentCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletCreateNestedManyWithoutTenantInput;
	role: Prisma.RoleCreateNestedOneWithoutTenantsInput;
	space: Prisma.SpaceCreateNestedOneWithoutTenantsInput;
};

export type TenantUncheckedCreateWithoutUserInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	spaceId: string;
	roleId: string;
	main?: boolean;
	assignments?: Prisma.AssignmentUncheckedCreateNestedManyWithoutTenantInput;
	categories?: Prisma.CategoryUncheckedCreateNestedManyWithoutTenantInput;
	contents?: Prisma.ContentUncheckedCreateNestedManyWithoutTenantInput;
	files?: Prisma.FileUncheckedCreateNestedManyWithoutTenantInput;
	groups?: Prisma.GroupUncheckedCreateNestedManyWithoutTenantInput;
	safeWallets?: Prisma.SafeWalletUncheckedCreateNestedManyWithoutTenantInput;
};

export type TenantCreateOrConnectWithoutUserInput = {
	where: Prisma.TenantWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutUserInput,
		Prisma.TenantUncheckedCreateWithoutUserInput
	>;
};

export type TenantCreateManyUserInputEnvelope = {
	data: Prisma.TenantCreateManyUserInput | Prisma.TenantCreateManyUserInput[];
	skipDuplicates?: boolean;
};

export type TenantUpsertWithWhereUniqueWithoutUserInput = {
	where: Prisma.TenantWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.TenantUpdateWithoutUserInput,
		Prisma.TenantUncheckedUpdateWithoutUserInput
	>;
	create: Prisma.XOR<
		Prisma.TenantCreateWithoutUserInput,
		Prisma.TenantUncheckedCreateWithoutUserInput
	>;
};

export type TenantUpdateWithWhereUniqueWithoutUserInput = {
	where: Prisma.TenantWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateWithoutUserInput,
		Prisma.TenantUncheckedUpdateWithoutUserInput
	>;
};

export type TenantUpdateManyWithWhereWithoutUserInput = {
	where: Prisma.TenantScalarWhereInput;
	data: Prisma.XOR<
		Prisma.TenantUpdateManyMutationInput,
		Prisma.TenantUncheckedUpdateManyWithoutUserInput
	>;
};

export type TenantCreateManyRoleInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	spaceId: string;
	main?: boolean;
};

export type TenantUpdateWithoutRoleInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutRoleInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantUncheckedUpdateManyWithoutRoleInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
};

export type TenantCreateManySpaceInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	userId: string;
	roleId: string;
	main?: boolean;
};

export type TenantUpdateWithoutSpaceInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	user?: Prisma.UserUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutSpaceInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantUncheckedUpdateManyWithoutSpaceInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	userId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
};

export type TenantCreateManyUserInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	spaceId: string;
	roleId: string;
	main?: boolean;
};

export type TenantUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUpdateManyWithoutTenantNestedInput;
	role?: Prisma.RoleUpdateOneRequiredWithoutTenantsNestedInput;
	space?: Prisma.SpaceUpdateOneRequiredWithoutTenantsNestedInput;
};

export type TenantUncheckedUpdateWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	assignments?: Prisma.AssignmentUncheckedUpdateManyWithoutTenantNestedInput;
	categories?: Prisma.CategoryUncheckedUpdateManyWithoutTenantNestedInput;
	contents?: Prisma.ContentUncheckedUpdateManyWithoutTenantNestedInput;
	files?: Prisma.FileUncheckedUpdateManyWithoutTenantNestedInput;
	groups?: Prisma.GroupUncheckedUpdateManyWithoutTenantNestedInput;
	safeWallets?: Prisma.SafeWalletUncheckedUpdateManyWithoutTenantNestedInput;
};

export type TenantUncheckedUpdateManyWithoutUserInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	spaceId?: Prisma.StringFieldUpdateOperationsInput | string;
	roleId?: Prisma.StringFieldUpdateOperationsInput | string;
	main?: Prisma.BoolFieldUpdateOperationsInput | boolean;
};

/**
 * Count Type TenantCountOutputType
 */

export type TenantCountOutputType = {
	assignments: number;
	categories: number;
	contents: number;
	files: number;
	groups: number;
	safeWallets: number;
};

export type TenantCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	assignments?: boolean | TenantCountOutputTypeCountAssignmentsArgs;
	categories?: boolean | TenantCountOutputTypeCountCategoriesArgs;
	contents?: boolean | TenantCountOutputTypeCountContentsArgs;
	files?: boolean | TenantCountOutputTypeCountFilesArgs;
	groups?: boolean | TenantCountOutputTypeCountGroupsArgs;
	safeWallets?: boolean | TenantCountOutputTypeCountSafeWalletsArgs;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the TenantCountOutputType
	 */
	select?: Prisma.TenantCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeCountAssignmentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.AssignmentWhereInput;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeCountCategoriesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CategoryWhereInput;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeCountContentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.ContentWhereInput;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeCountFilesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.FileWhereInput;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeCountGroupsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.GroupWhereInput;
};

/**
 * TenantCountOutputType without action
 */
export type TenantCountOutputTypeCountSafeWalletsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.SafeWalletWhereInput;
};

export type TenantSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		seq?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		removedAt?: boolean;
		userId?: boolean;
		spaceId?: boolean;
		roleId?: boolean;
		main?: boolean;
		assignments?: boolean | Prisma.Tenant$assignmentsArgs<ExtArgs>;
		categories?: boolean | Prisma.Tenant$categoriesArgs<ExtArgs>;
		contents?: boolean | Prisma.Tenant$contentsArgs<ExtArgs>;
		files?: boolean | Prisma.Tenant$filesArgs<ExtArgs>;
		groups?: boolean | Prisma.Tenant$groupsArgs<ExtArgs>;
		safeWallets?: boolean | Prisma.Tenant$safeWalletsArgs<ExtArgs>;
		role?: boolean | Prisma.RoleDefaultArgs<ExtArgs>;
		space?: boolean | Prisma.SpaceDefaultArgs<ExtArgs>;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		_count?: boolean | Prisma.TenantCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["tenant"]
>;

export type TenantSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		seq?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		removedAt?: boolean;
		userId?: boolean;
		spaceId?: boolean;
		roleId?: boolean;
		main?: boolean;
		role?: boolean | Prisma.RoleDefaultArgs<ExtArgs>;
		space?: boolean | Prisma.SpaceDefaultArgs<ExtArgs>;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["tenant"]
>;

export type TenantSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		seq?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		removedAt?: boolean;
		userId?: boolean;
		spaceId?: boolean;
		roleId?: boolean;
		main?: boolean;
		role?: boolean | Prisma.RoleDefaultArgs<ExtArgs>;
		space?: boolean | Prisma.SpaceDefaultArgs<ExtArgs>;
		user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["tenant"]
>;

export type TenantSelectScalar = {
	id?: boolean;
	seq?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
	removedAt?: boolean;
	userId?: boolean;
	spaceId?: boolean;
	roleId?: boolean;
	main?: boolean;
};

export type TenantOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "seq"
	| "createdAt"
	| "updatedAt"
	| "removedAt"
	| "userId"
	| "spaceId"
	| "roleId"
	| "main",
	ExtArgs["result"]["tenant"]
>;
export type TenantInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	assignments?: boolean | Prisma.Tenant$assignmentsArgs<ExtArgs>;
	categories?: boolean | Prisma.Tenant$categoriesArgs<ExtArgs>;
	contents?: boolean | Prisma.Tenant$contentsArgs<ExtArgs>;
	files?: boolean | Prisma.Tenant$filesArgs<ExtArgs>;
	groups?: boolean | Prisma.Tenant$groupsArgs<ExtArgs>;
	safeWallets?: boolean | Prisma.Tenant$safeWalletsArgs<ExtArgs>;
	role?: boolean | Prisma.RoleDefaultArgs<ExtArgs>;
	space?: boolean | Prisma.SpaceDefaultArgs<ExtArgs>;
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	_count?: boolean | Prisma.TenantCountOutputTypeDefaultArgs<ExtArgs>;
};
export type TenantIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	role?: boolean | Prisma.RoleDefaultArgs<ExtArgs>;
	space?: boolean | Prisma.SpaceDefaultArgs<ExtArgs>;
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type TenantIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	role?: boolean | Prisma.RoleDefaultArgs<ExtArgs>;
	space?: boolean | Prisma.SpaceDefaultArgs<ExtArgs>;
	user?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $TenantPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "Tenant";
	objects: {
		assignments: Prisma.$AssignmentPayload<ExtArgs>[];
		categories: Prisma.$CategoryPayload<ExtArgs>[];
		contents: Prisma.$ContentPayload<ExtArgs>[];
		files: Prisma.$FilePayload<ExtArgs>[];
		groups: Prisma.$GroupPayload<ExtArgs>[];
		safeWallets: Prisma.$SafeWalletPayload<ExtArgs>[];
		role: Prisma.$RolePayload<ExtArgs>;
		space: Prisma.$SpacePayload<ExtArgs>;
		user: Prisma.$UserPayload<ExtArgs>;
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			seq: number;
			createdAt: Date;
			updatedAt: Date | null;
			removedAt: Date | null;
			userId: string;
			spaceId: string;
			roleId: string;
			main: boolean;
		},
		ExtArgs["result"]["tenant"]
	>;
	composites: {};
};

export type TenantGetPayload<
	S extends boolean | null | undefined | TenantDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$TenantPayload, S>;

export type TenantCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<TenantFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: TenantCountAggregateInputType | true;
};

export interface TenantDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["Tenant"];
		meta: { name: "Tenant" };
	};
	/**
	 * Find zero or one Tenant that matches the filter.
	 * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
	 * @example
	 * // Get one Tenant
	 * const tenant = await prisma.tenant.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends TenantFindUniqueArgs>(
		args: Prisma.SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
	 * @example
	 * // Get one Tenant
	 * const tenant = await prisma.tenant.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Tenant that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
	 * @example
	 * // Get one Tenant
	 * const tenant = await prisma.tenant.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends TenantFindFirstArgs>(
		args?: Prisma.SelectSubset<T, TenantFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Tenant that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
	 * @example
	 * // Get one Tenant
	 * const tenant = await prisma.tenant.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Tenants that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Tenants
	 * const tenants = await prisma.tenant.findMany()
	 *
	 * // Get first 10 Tenants
	 * const tenants = await prisma.tenant.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends TenantFindManyArgs>(
		args?: Prisma.SelectSubset<T, TenantFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Tenant.
	 * @param {TenantCreateArgs} args - Arguments to create a Tenant.
	 * @example
	 * // Create one Tenant
	 * const Tenant = await prisma.tenant.create({
	 *   data: {
	 *     // ... data to create a Tenant
	 *   }
	 * })
	 *
	 */
	create<T extends TenantCreateArgs>(
		args: Prisma.SelectSubset<T, TenantCreateArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Tenants.
	 * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
	 * @example
	 * // Create many Tenants
	 * const tenant = await prisma.tenant.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends TenantCreateManyArgs>(
		args?: Prisma.SelectSubset<T, TenantCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many Tenants and returns the data saved in the database.
	 * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
	 * @example
	 * // Create many Tenants
	 * const tenant = await prisma.tenant.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Tenants and only return the `id`
	 * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a Tenant.
	 * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
	 * @example
	 * // Delete one Tenant
	 * const Tenant = await prisma.tenant.delete({
	 *   where: {
	 *     // ... filter to delete one Tenant
	 *   }
	 * })
	 *
	 */
	delete<T extends TenantDeleteArgs>(
		args: Prisma.SelectSubset<T, TenantDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Tenant.
	 * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
	 * @example
	 * // Update one Tenant
	 * const tenant = await prisma.tenant.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends TenantUpdateArgs>(
		args: Prisma.SelectSubset<T, TenantUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Tenants.
	 * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
	 * @example
	 * // Delete a few Tenants
	 * const { count } = await prisma.tenant.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends TenantDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Tenants.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Tenants
	 * const tenant = await prisma.tenant.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends TenantUpdateManyArgs>(
		args: Prisma.SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Tenants and returns the data updated in the database.
	 * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
	 * @example
	 * // Update many Tenants
	 * const tenant = await prisma.tenant.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Tenants and only return the `id`
	 * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one Tenant.
	 * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
	 * @example
	 * // Update or create a Tenant
	 * const tenant = await prisma.tenant.upsert({
	 *   create: {
	 *     // ... data to create a Tenant
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Tenant we want to update
	 *   }
	 * })
	 */
	upsert<T extends TenantUpsertArgs>(
		args: Prisma.SelectSubset<T, TenantUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		runtime.Types.Result.GetResult<
			Prisma.$TenantPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of Tenants.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
	 * @example
	 * // Count the number of Tenants
	 * const count = await prisma.tenant.count({
	 *   where: {
	 *     // ... the filter for the Tenants we want to count
	 *   }
	 * })
	 **/
	count<T extends TenantCountArgs>(
		args?: Prisma.Subset<T, TenantCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], TenantCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Tenant.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends TenantAggregateArgs>(
		args: Prisma.Subset<T, TenantAggregateArgs>,
	): Prisma.PrismaPromise<GetTenantAggregateType<T>>;

	/**
	 * Group by Tenant.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {TenantGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends TenantGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: TenantGroupByArgs["orderBy"] }
			: { orderBy?: TenantGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, TenantGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetTenantGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Tenant model
	 */
	readonly fields: TenantFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Tenant.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__TenantClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	assignments<T extends Prisma.Tenant$assignmentsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Tenant$assignmentsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$AssignmentPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	categories<T extends Prisma.Tenant$categoriesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Tenant$categoriesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$CategoryPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	contents<T extends Prisma.Tenant$contentsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Tenant$contentsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$ContentPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	files<T extends Prisma.Tenant$filesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Tenant$filesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$FilePayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	groups<T extends Prisma.Tenant$groupsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Tenant$groupsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$GroupPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	safeWallets<T extends Prisma.Tenant$safeWalletsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Tenant$safeWalletsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$SafeWalletPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	role<T extends Prisma.RoleDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.RoleDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__RoleClient<
		| runtime.Types.Result.GetResult<
				Prisma.$RolePayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	space<T extends Prisma.SpaceDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.SpaceDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__SpaceClient<
		| runtime.Types.Result.GetResult<
				Prisma.$SpacePayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	user<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Tenant model
 */
export interface TenantFieldRefs {
	readonly id: Prisma.FieldRef<"Tenant", "String">;
	readonly seq: Prisma.FieldRef<"Tenant", "Int">;
	readonly createdAt: Prisma.FieldRef<"Tenant", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"Tenant", "DateTime">;
	readonly removedAt: Prisma.FieldRef<"Tenant", "DateTime">;
	readonly userId: Prisma.FieldRef<"Tenant", "String">;
	readonly spaceId: Prisma.FieldRef<"Tenant", "String">;
	readonly roleId: Prisma.FieldRef<"Tenant", "String">;
	readonly main: Prisma.FieldRef<"Tenant", "Boolean">;
}

// Custom InputTypes
/**
 * Tenant findUnique
 */
export type TenantFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * Filter, which Tenant to fetch.
	 */
	where: Prisma.TenantWhereUniqueInput;
};

/**
 * Tenant findUniqueOrThrow
 */
export type TenantFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * Filter, which Tenant to fetch.
	 */
	where: Prisma.TenantWhereUniqueInput;
};

/**
 * Tenant findFirst
 */
export type TenantFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * Filter, which Tenant to fetch.
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Tenants to fetch.
	 */
	orderBy?:
		| Prisma.TenantOrderByWithRelationInput
		| Prisma.TenantOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Tenants.
	 */
	cursor?: Prisma.TenantWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Tenants from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Tenants.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Tenants.
	 */
	distinct?: Prisma.TenantScalarFieldEnum | Prisma.TenantScalarFieldEnum[];
};

/**
 * Tenant findFirstOrThrow
 */
export type TenantFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * Filter, which Tenant to fetch.
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Tenants to fetch.
	 */
	orderBy?:
		| Prisma.TenantOrderByWithRelationInput
		| Prisma.TenantOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Tenants.
	 */
	cursor?: Prisma.TenantWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Tenants from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Tenants.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Tenants.
	 */
	distinct?: Prisma.TenantScalarFieldEnum | Prisma.TenantScalarFieldEnum[];
};

/**
 * Tenant findMany
 */
export type TenantFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * Filter, which Tenants to fetch.
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Tenants to fetch.
	 */
	orderBy?:
		| Prisma.TenantOrderByWithRelationInput
		| Prisma.TenantOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Tenants.
	 */
	cursor?: Prisma.TenantWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Tenants from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Tenants.
	 */
	skip?: number;
	distinct?: Prisma.TenantScalarFieldEnum | Prisma.TenantScalarFieldEnum[];
};

/**
 * Tenant create
 */
export type TenantCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Tenant.
	 */
	data: Prisma.XOR<Prisma.TenantCreateInput, Prisma.TenantUncheckedCreateInput>;
};

/**
 * Tenant createMany
 */
export type TenantCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Tenants.
	 */
	data: Prisma.TenantCreateManyInput | Prisma.TenantCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Tenant createManyAndReturn
 */
export type TenantCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * The data used to create many Tenants.
	 */
	data: Prisma.TenantCreateManyInput | Prisma.TenantCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Tenant update
 */
export type TenantUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Tenant.
	 */
	data: Prisma.XOR<Prisma.TenantUpdateInput, Prisma.TenantUncheckedUpdateInput>;
	/**
	 * Choose, which Tenant to update.
	 */
	where: Prisma.TenantWhereUniqueInput;
};

/**
 * Tenant updateMany
 */
export type TenantUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Tenants.
	 */
	data: Prisma.XOR<
		Prisma.TenantUpdateManyMutationInput,
		Prisma.TenantUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Tenants to update
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * Limit how many Tenants to update.
	 */
	limit?: number;
};

/**
 * Tenant updateManyAndReturn
 */
export type TenantUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * The data used to update Tenants.
	 */
	data: Prisma.XOR<
		Prisma.TenantUpdateManyMutationInput,
		Prisma.TenantUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Tenants to update
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * Limit how many Tenants to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Tenant upsert
 */
export type TenantUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Tenant to update in case it exists.
	 */
	where: Prisma.TenantWhereUniqueInput;
	/**
	 * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
	 */
	create: Prisma.XOR<
		Prisma.TenantCreateInput,
		Prisma.TenantUncheckedCreateInput
	>;
	/**
	 * In case the Tenant was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.TenantUpdateInput,
		Prisma.TenantUncheckedUpdateInput
	>;
};

/**
 * Tenant delete
 */
export type TenantDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
	/**
	 * Filter which Tenant to delete.
	 */
	where: Prisma.TenantWhereUniqueInput;
};

/**
 * Tenant deleteMany
 */
export type TenantDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Tenants to delete
	 */
	where?: Prisma.TenantWhereInput;
	/**
	 * Limit how many Tenants to delete.
	 */
	limit?: number;
};

/**
 * Tenant.assignments
 */
export type Tenant$assignmentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Assignment
	 */
	select?: Prisma.AssignmentSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Assignment
	 */
	omit?: Prisma.AssignmentOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.AssignmentInclude<ExtArgs> | null;
	where?: Prisma.AssignmentWhereInput;
	orderBy?:
		| Prisma.AssignmentOrderByWithRelationInput
		| Prisma.AssignmentOrderByWithRelationInput[];
	cursor?: Prisma.AssignmentWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.AssignmentScalarFieldEnum
		| Prisma.AssignmentScalarFieldEnum[];
};

/**
 * Tenant.categories
 */
export type Tenant$categoriesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	where?: Prisma.CategoryWhereInput;
	orderBy?:
		| Prisma.CategoryOrderByWithRelationInput
		| Prisma.CategoryOrderByWithRelationInput[];
	cursor?: Prisma.CategoryWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.CategoryScalarFieldEnum | Prisma.CategoryScalarFieldEnum[];
};

/**
 * Tenant.contents
 */
export type Tenant$contentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Content
	 */
	select?: Prisma.ContentSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Content
	 */
	omit?: Prisma.ContentOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.ContentInclude<ExtArgs> | null;
	where?: Prisma.ContentWhereInput;
	orderBy?:
		| Prisma.ContentOrderByWithRelationInput
		| Prisma.ContentOrderByWithRelationInput[];
	cursor?: Prisma.ContentWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.ContentScalarFieldEnum | Prisma.ContentScalarFieldEnum[];
};

/**
 * Tenant.files
 */
export type Tenant$filesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the File
	 */
	select?: Prisma.FileSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the File
	 */
	omit?: Prisma.FileOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FileInclude<ExtArgs> | null;
	where?: Prisma.FileWhereInput;
	orderBy?:
		| Prisma.FileOrderByWithRelationInput
		| Prisma.FileOrderByWithRelationInput[];
	cursor?: Prisma.FileWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.FileScalarFieldEnum | Prisma.FileScalarFieldEnum[];
};

/**
 * Tenant.groups
 */
export type Tenant$groupsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Group
	 */
	select?: Prisma.GroupSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Group
	 */
	omit?: Prisma.GroupOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.GroupInclude<ExtArgs> | null;
	where?: Prisma.GroupWhereInput;
	orderBy?:
		| Prisma.GroupOrderByWithRelationInput
		| Prisma.GroupOrderByWithRelationInput[];
	cursor?: Prisma.GroupWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.GroupScalarFieldEnum | Prisma.GroupScalarFieldEnum[];
};

/**
 * Tenant.safeWallets
 */
export type Tenant$safeWalletsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the SafeWallet
	 */
	select?: Prisma.SafeWalletSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the SafeWallet
	 */
	omit?: Prisma.SafeWalletOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.SafeWalletInclude<ExtArgs> | null;
	where?: Prisma.SafeWalletWhereInput;
	orderBy?:
		| Prisma.SafeWalletOrderByWithRelationInput
		| Prisma.SafeWalletOrderByWithRelationInput[];
	cursor?: Prisma.SafeWalletWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.SafeWalletScalarFieldEnum
		| Prisma.SafeWalletScalarFieldEnum[];
};

/**
 * Tenant without action
 */
export type TenantDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tenant
	 */
	select?: Prisma.TenantSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tenant
	 */
	omit?: Prisma.TenantOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TenantInclude<ExtArgs> | null;
};
