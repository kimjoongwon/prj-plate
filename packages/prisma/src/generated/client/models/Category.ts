/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Category` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";

/**
 * Model Category
 *
 */
export type CategoryModel =
	runtime.Types.Result.DefaultSelection<Prisma.$CategoryPayload>;

export type AggregateCategory = {
	_count: CategoryCountAggregateOutputType | null;
	_avg: CategoryAvgAggregateOutputType | null;
	_sum: CategorySumAggregateOutputType | null;
	_min: CategoryMinAggregateOutputType | null;
	_max: CategoryMaxAggregateOutputType | null;
};

export type CategoryAvgAggregateOutputType = {
	seq: number | null;
};

export type CategorySumAggregateOutputType = {
	seq: number | null;
};

export type CategoryMinAggregateOutputType = {
	id: string | null;
	seq: number | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	removedAt: Date | null;
	name: string | null;
	type: $Enums.CategoryTypes | null;
	parentId: string | null;
	tenantId: string | null;
};

export type CategoryMaxAggregateOutputType = {
	id: string | null;
	seq: number | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	removedAt: Date | null;
	name: string | null;
	type: $Enums.CategoryTypes | null;
	parentId: string | null;
	tenantId: string | null;
};

export type CategoryCountAggregateOutputType = {
	id: number;
	seq: number;
	createdAt: number;
	updatedAt: number;
	removedAt: number;
	name: number;
	type: number;
	parentId: number;
	tenantId: number;
	_all: number;
};

export type CategoryAvgAggregateInputType = {
	seq?: true;
};

export type CategorySumAggregateInputType = {
	seq?: true;
};

export type CategoryMinAggregateInputType = {
	id?: true;
	seq?: true;
	createdAt?: true;
	updatedAt?: true;
	removedAt?: true;
	name?: true;
	type?: true;
	parentId?: true;
	tenantId?: true;
};

export type CategoryMaxAggregateInputType = {
	id?: true;
	seq?: true;
	createdAt?: true;
	updatedAt?: true;
	removedAt?: true;
	name?: true;
	type?: true;
	parentId?: true;
	tenantId?: true;
};

export type CategoryCountAggregateInputType = {
	id?: true;
	seq?: true;
	createdAt?: true;
	updatedAt?: true;
	removedAt?: true;
	name?: true;
	type?: true;
	parentId?: true;
	tenantId?: true;
	_all?: true;
};

export type CategoryAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Category to aggregate.
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Categories to fetch.
	 */
	orderBy?:
		| Prisma.CategoryOrderByWithRelationInput
		| Prisma.CategoryOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.CategoryWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Categories from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Categories.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Categories
	 **/
	_count?: true | CategoryCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: CategoryAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: CategorySumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: CategoryMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: CategoryMaxAggregateInputType;
};

export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
	[P in keyof T & keyof AggregateCategory]: P extends "_count" | "count"
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregateCategory[P]>
		: Prisma.GetScalarType<T[P], AggregateCategory[P]>;
};

export type CategoryGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CategoryWhereInput;
	orderBy?:
		| Prisma.CategoryOrderByWithAggregationInput
		| Prisma.CategoryOrderByWithAggregationInput[];
	by: Prisma.CategoryScalarFieldEnum[] | Prisma.CategoryScalarFieldEnum;
	having?: Prisma.CategoryScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: CategoryCountAggregateInputType | true;
	_avg?: CategoryAvgAggregateInputType;
	_sum?: CategorySumAggregateInputType;
	_min?: CategoryMinAggregateInputType;
	_max?: CategoryMaxAggregateInputType;
};

export type CategoryGroupByOutputType = {
	id: string;
	seq: number;
	createdAt: Date;
	updatedAt: Date | null;
	removedAt: Date | null;
	name: string;
	type: $Enums.CategoryTypes;
	parentId: string | null;
	tenantId: string;
	_count: CategoryCountAggregateOutputType | null;
	_avg: CategoryAvgAggregateOutputType | null;
	_sum: CategorySumAggregateOutputType | null;
	_min: CategoryMinAggregateOutputType | null;
	_max: CategoryMaxAggregateOutputType | null;
};

type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> =
	Prisma.PrismaPromise<
		Array<
			Prisma.PickEnumerable<CategoryGroupByOutputType, T["by"]> & {
				[P in keyof T & keyof CategoryGroupByOutputType]: P extends "_count"
					? T[P] extends boolean
						? number
						: Prisma.GetScalarType<T[P], CategoryGroupByOutputType[P]>
					: Prisma.GetScalarType<T[P], CategoryGroupByOutputType[P]>;
			}
		>
	>;

export type CategoryWhereInput = {
	AND?: Prisma.CategoryWhereInput | Prisma.CategoryWhereInput[];
	OR?: Prisma.CategoryWhereInput[];
	NOT?: Prisma.CategoryWhereInput | Prisma.CategoryWhereInput[];
	id?: Prisma.StringFilter<"Category"> | string;
	seq?: Prisma.IntFilter<"Category"> | number;
	createdAt?: Prisma.DateTimeFilter<"Category"> | Date | string;
	updatedAt?: Prisma.DateTimeNullableFilter<"Category"> | Date | string | null;
	removedAt?: Prisma.DateTimeNullableFilter<"Category"> | Date | string | null;
	name?: Prisma.StringFilter<"Category"> | string;
	type?: Prisma.EnumCategoryTypesFilter<"Category"> | $Enums.CategoryTypes;
	parentId?: Prisma.StringNullableFilter<"Category"> | string | null;
	tenantId?: Prisma.StringFilter<"Category"> | string;
	parent?: Prisma.XOR<
		Prisma.CategoryNullableScalarRelationFilter,
		Prisma.CategoryWhereInput
	> | null;
	children?: Prisma.CategoryListRelationFilter;
	tenant?: Prisma.XOR<
		Prisma.TenantScalarRelationFilter,
		Prisma.TenantWhereInput
	>;
	fileClassifications?: Prisma.FileClassificationListRelationFilter;
	roleClassifications?: Prisma.RoleClassificationListRelationFilter;
	spaceClassifications?: Prisma.SpaceClassificationListRelationFilter;
	userClassifications?: Prisma.UserClassificationListRelationFilter;
};

export type CategoryOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	removedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	parentId?: Prisma.SortOrderInput | Prisma.SortOrder;
	tenantId?: Prisma.SortOrder;
	parent?: Prisma.CategoryOrderByWithRelationInput;
	children?: Prisma.CategoryOrderByRelationAggregateInput;
	tenant?: Prisma.TenantOrderByWithRelationInput;
	fileClassifications?: Prisma.FileClassificationOrderByRelationAggregateInput;
	roleClassifications?: Prisma.RoleClassificationOrderByRelationAggregateInput;
	spaceClassifications?: Prisma.SpaceClassificationOrderByRelationAggregateInput;
	userClassifications?: Prisma.UserClassificationOrderByRelationAggregateInput;
};

export type CategoryWhereUniqueInput = Prisma.AtLeast<
	{
		id?: string;
		seq?: number;
		name?: string;
		AND?: Prisma.CategoryWhereInput | Prisma.CategoryWhereInput[];
		OR?: Prisma.CategoryWhereInput[];
		NOT?: Prisma.CategoryWhereInput | Prisma.CategoryWhereInput[];
		createdAt?: Prisma.DateTimeFilter<"Category"> | Date | string;
		updatedAt?:
			| Prisma.DateTimeNullableFilter<"Category">
			| Date
			| string
			| null;
		removedAt?:
			| Prisma.DateTimeNullableFilter<"Category">
			| Date
			| string
			| null;
		type?: Prisma.EnumCategoryTypesFilter<"Category"> | $Enums.CategoryTypes;
		parentId?: Prisma.StringNullableFilter<"Category"> | string | null;
		tenantId?: Prisma.StringFilter<"Category"> | string;
		parent?: Prisma.XOR<
			Prisma.CategoryNullableScalarRelationFilter,
			Prisma.CategoryWhereInput
		> | null;
		children?: Prisma.CategoryListRelationFilter;
		tenant?: Prisma.XOR<
			Prisma.TenantScalarRelationFilter,
			Prisma.TenantWhereInput
		>;
		fileClassifications?: Prisma.FileClassificationListRelationFilter;
		roleClassifications?: Prisma.RoleClassificationListRelationFilter;
		spaceClassifications?: Prisma.SpaceClassificationListRelationFilter;
		userClassifications?: Prisma.UserClassificationListRelationFilter;
	},
	"id" | "seq" | "name"
>;

export type CategoryOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	removedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	parentId?: Prisma.SortOrderInput | Prisma.SortOrder;
	tenantId?: Prisma.SortOrder;
	_count?: Prisma.CategoryCountOrderByAggregateInput;
	_avg?: Prisma.CategoryAvgOrderByAggregateInput;
	_max?: Prisma.CategoryMaxOrderByAggregateInput;
	_min?: Prisma.CategoryMinOrderByAggregateInput;
	_sum?: Prisma.CategorySumOrderByAggregateInput;
};

export type CategoryScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.CategoryScalarWhereWithAggregatesInput
		| Prisma.CategoryScalarWhereWithAggregatesInput[];
	OR?: Prisma.CategoryScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.CategoryScalarWhereWithAggregatesInput
		| Prisma.CategoryScalarWhereWithAggregatesInput[];
	id?: Prisma.StringWithAggregatesFilter<"Category"> | string;
	seq?: Prisma.IntWithAggregatesFilter<"Category"> | number;
	createdAt?: Prisma.DateTimeWithAggregatesFilter<"Category"> | Date | string;
	updatedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Category">
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<"Category">
		| Date
		| string
		| null;
	name?: Prisma.StringWithAggregatesFilter<"Category"> | string;
	type?:
		| Prisma.EnumCategoryTypesWithAggregatesFilter<"Category">
		| $Enums.CategoryTypes;
	parentId?:
		| Prisma.StringNullableWithAggregatesFilter<"Category">
		| string
		| null;
	tenantId?: Prisma.StringWithAggregatesFilter<"Category"> | string;
};

export type CategoryCreateInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryCreateManyInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
};

export type CategoryUpdateManyMutationInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
};

export type CategoryUncheckedUpdateManyInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type CategoryNullableScalarRelationFilter = {
	is?: Prisma.CategoryWhereInput | null;
	isNot?: Prisma.CategoryWhereInput | null;
};

export type CategoryListRelationFilter = {
	every?: Prisma.CategoryWhereInput;
	some?: Prisma.CategoryWhereInput;
	none?: Prisma.CategoryWhereInput;
};

export type CategoryOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type CategoryCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	removedAt?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	parentId?: Prisma.SortOrder;
	tenantId?: Prisma.SortOrder;
};

export type CategoryAvgOrderByAggregateInput = {
	seq?: Prisma.SortOrder;
};

export type CategoryMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	removedAt?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	parentId?: Prisma.SortOrder;
	tenantId?: Prisma.SortOrder;
};

export type CategoryMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	seq?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	removedAt?: Prisma.SortOrder;
	name?: Prisma.SortOrder;
	type?: Prisma.SortOrder;
	parentId?: Prisma.SortOrder;
	tenantId?: Prisma.SortOrder;
};

export type CategorySumOrderByAggregateInput = {
	seq?: Prisma.SortOrder;
};

export type CategoryScalarRelationFilter = {
	is?: Prisma.CategoryWhereInput;
	isNot?: Prisma.CategoryWhereInput;
};

export type CategoryCreateNestedOneWithoutChildrenInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutChildrenInput,
		Prisma.CategoryUncheckedCreateWithoutChildrenInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutChildrenInput;
	connect?: Prisma.CategoryWhereUniqueInput;
};

export type CategoryCreateNestedManyWithoutParentInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutParentInput,
				Prisma.CategoryUncheckedCreateWithoutParentInput
		  >
		| Prisma.CategoryCreateWithoutParentInput[]
		| Prisma.CategoryUncheckedCreateWithoutParentInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutParentInput
		| Prisma.CategoryCreateOrConnectWithoutParentInput[];
	createMany?: Prisma.CategoryCreateManyParentInputEnvelope;
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
};

export type CategoryUncheckedCreateNestedManyWithoutParentInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutParentInput,
				Prisma.CategoryUncheckedCreateWithoutParentInput
		  >
		| Prisma.CategoryCreateWithoutParentInput[]
		| Prisma.CategoryUncheckedCreateWithoutParentInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutParentInput
		| Prisma.CategoryCreateOrConnectWithoutParentInput[];
	createMany?: Prisma.CategoryCreateManyParentInputEnvelope;
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
};

export type StringFieldUpdateOperationsInput = {
	set?: string;
};

export type DateTimeFieldUpdateOperationsInput = {
	set?: Date | string;
};

export type NullableDateTimeFieldUpdateOperationsInput = {
	set?: Date | string | null;
};

export type EnumCategoryTypesFieldUpdateOperationsInput = {
	set?: $Enums.CategoryTypes;
};

export type CategoryUpdateOneWithoutChildrenNestedInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutChildrenInput,
		Prisma.CategoryUncheckedCreateWithoutChildrenInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutChildrenInput;
	upsert?: Prisma.CategoryUpsertWithoutChildrenInput;
	disconnect?: Prisma.CategoryWhereInput | boolean;
	delete?: Prisma.CategoryWhereInput | boolean;
	connect?: Prisma.CategoryWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.CategoryUpdateToOneWithWhereWithoutChildrenInput,
			Prisma.CategoryUpdateWithoutChildrenInput
		>,
		Prisma.CategoryUncheckedUpdateWithoutChildrenInput
	>;
};

export type CategoryUpdateManyWithoutParentNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutParentInput,
				Prisma.CategoryUncheckedCreateWithoutParentInput
		  >
		| Prisma.CategoryCreateWithoutParentInput[]
		| Prisma.CategoryUncheckedCreateWithoutParentInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutParentInput
		| Prisma.CategoryCreateOrConnectWithoutParentInput[];
	upsert?:
		| Prisma.CategoryUpsertWithWhereUniqueWithoutParentInput
		| Prisma.CategoryUpsertWithWhereUniqueWithoutParentInput[];
	createMany?: Prisma.CategoryCreateManyParentInputEnvelope;
	set?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	disconnect?:
		| Prisma.CategoryWhereUniqueInput
		| Prisma.CategoryWhereUniqueInput[];
	delete?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	update?:
		| Prisma.CategoryUpdateWithWhereUniqueWithoutParentInput
		| Prisma.CategoryUpdateWithWhereUniqueWithoutParentInput[];
	updateMany?:
		| Prisma.CategoryUpdateManyWithWhereWithoutParentInput
		| Prisma.CategoryUpdateManyWithWhereWithoutParentInput[];
	deleteMany?:
		| Prisma.CategoryScalarWhereInput
		| Prisma.CategoryScalarWhereInput[];
};

export type IntFieldUpdateOperationsInput = {
	set?: number;
	increment?: number;
	decrement?: number;
	multiply?: number;
	divide?: number;
};

export type NullableStringFieldUpdateOperationsInput = {
	set?: string | null;
};

export type CategoryUncheckedUpdateManyWithoutParentNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutParentInput,
				Prisma.CategoryUncheckedCreateWithoutParentInput
		  >
		| Prisma.CategoryCreateWithoutParentInput[]
		| Prisma.CategoryUncheckedCreateWithoutParentInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutParentInput
		| Prisma.CategoryCreateOrConnectWithoutParentInput[];
	upsert?:
		| Prisma.CategoryUpsertWithWhereUniqueWithoutParentInput
		| Prisma.CategoryUpsertWithWhereUniqueWithoutParentInput[];
	createMany?: Prisma.CategoryCreateManyParentInputEnvelope;
	set?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	disconnect?:
		| Prisma.CategoryWhereUniqueInput
		| Prisma.CategoryWhereUniqueInput[];
	delete?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	update?:
		| Prisma.CategoryUpdateWithWhereUniqueWithoutParentInput
		| Prisma.CategoryUpdateWithWhereUniqueWithoutParentInput[];
	updateMany?:
		| Prisma.CategoryUpdateManyWithWhereWithoutParentInput
		| Prisma.CategoryUpdateManyWithWhereWithoutParentInput[];
	deleteMany?:
		| Prisma.CategoryScalarWhereInput
		| Prisma.CategoryScalarWhereInput[];
};

export type CategoryCreateNestedManyWithoutTenantInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutTenantInput,
				Prisma.CategoryUncheckedCreateWithoutTenantInput
		  >
		| Prisma.CategoryCreateWithoutTenantInput[]
		| Prisma.CategoryUncheckedCreateWithoutTenantInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutTenantInput
		| Prisma.CategoryCreateOrConnectWithoutTenantInput[];
	createMany?: Prisma.CategoryCreateManyTenantInputEnvelope;
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
};

export type CategoryUncheckedCreateNestedManyWithoutTenantInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutTenantInput,
				Prisma.CategoryUncheckedCreateWithoutTenantInput
		  >
		| Prisma.CategoryCreateWithoutTenantInput[]
		| Prisma.CategoryUncheckedCreateWithoutTenantInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutTenantInput
		| Prisma.CategoryCreateOrConnectWithoutTenantInput[];
	createMany?: Prisma.CategoryCreateManyTenantInputEnvelope;
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
};

export type CategoryUpdateManyWithoutTenantNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutTenantInput,
				Prisma.CategoryUncheckedCreateWithoutTenantInput
		  >
		| Prisma.CategoryCreateWithoutTenantInput[]
		| Prisma.CategoryUncheckedCreateWithoutTenantInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutTenantInput
		| Prisma.CategoryCreateOrConnectWithoutTenantInput[];
	upsert?:
		| Prisma.CategoryUpsertWithWhereUniqueWithoutTenantInput
		| Prisma.CategoryUpsertWithWhereUniqueWithoutTenantInput[];
	createMany?: Prisma.CategoryCreateManyTenantInputEnvelope;
	set?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	disconnect?:
		| Prisma.CategoryWhereUniqueInput
		| Prisma.CategoryWhereUniqueInput[];
	delete?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	update?:
		| Prisma.CategoryUpdateWithWhereUniqueWithoutTenantInput
		| Prisma.CategoryUpdateWithWhereUniqueWithoutTenantInput[];
	updateMany?:
		| Prisma.CategoryUpdateManyWithWhereWithoutTenantInput
		| Prisma.CategoryUpdateManyWithWhereWithoutTenantInput[];
	deleteMany?:
		| Prisma.CategoryScalarWhereInput
		| Prisma.CategoryScalarWhereInput[];
};

export type CategoryUncheckedUpdateManyWithoutTenantNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.CategoryCreateWithoutTenantInput,
				Prisma.CategoryUncheckedCreateWithoutTenantInput
		  >
		| Prisma.CategoryCreateWithoutTenantInput[]
		| Prisma.CategoryUncheckedCreateWithoutTenantInput[];
	connectOrCreate?:
		| Prisma.CategoryCreateOrConnectWithoutTenantInput
		| Prisma.CategoryCreateOrConnectWithoutTenantInput[];
	upsert?:
		| Prisma.CategoryUpsertWithWhereUniqueWithoutTenantInput
		| Prisma.CategoryUpsertWithWhereUniqueWithoutTenantInput[];
	createMany?: Prisma.CategoryCreateManyTenantInputEnvelope;
	set?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	disconnect?:
		| Prisma.CategoryWhereUniqueInput
		| Prisma.CategoryWhereUniqueInput[];
	delete?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	connect?: Prisma.CategoryWhereUniqueInput | Prisma.CategoryWhereUniqueInput[];
	update?:
		| Prisma.CategoryUpdateWithWhereUniqueWithoutTenantInput
		| Prisma.CategoryUpdateWithWhereUniqueWithoutTenantInput[];
	updateMany?:
		| Prisma.CategoryUpdateManyWithWhereWithoutTenantInput
		| Prisma.CategoryUpdateManyWithWhereWithoutTenantInput[];
	deleteMany?:
		| Prisma.CategoryScalarWhereInput
		| Prisma.CategoryScalarWhereInput[];
};

export type CategoryCreateNestedOneWithoutFileClassificationsInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutFileClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutFileClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutFileClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
};

export type CategoryUpdateOneRequiredWithoutFileClassificationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutFileClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutFileClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutFileClassificationsInput;
	upsert?: Prisma.CategoryUpsertWithoutFileClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.CategoryUpdateToOneWithWhereWithoutFileClassificationsInput,
			Prisma.CategoryUpdateWithoutFileClassificationsInput
		>,
		Prisma.CategoryUncheckedUpdateWithoutFileClassificationsInput
	>;
};

export type CategoryCreateNestedOneWithoutRoleClassificationsInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutRoleClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutRoleClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutRoleClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
};

export type CategoryUpdateOneRequiredWithoutRoleClassificationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutRoleClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutRoleClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutRoleClassificationsInput;
	upsert?: Prisma.CategoryUpsertWithoutRoleClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.CategoryUpdateToOneWithWhereWithoutRoleClassificationsInput,
			Prisma.CategoryUpdateWithoutRoleClassificationsInput
		>,
		Prisma.CategoryUncheckedUpdateWithoutRoleClassificationsInput
	>;
};

export type CategoryCreateNestedOneWithoutSpaceClassificationsInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutSpaceClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutSpaceClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutSpaceClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
};

export type CategoryUpdateOneRequiredWithoutSpaceClassificationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutSpaceClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutSpaceClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutSpaceClassificationsInput;
	upsert?: Prisma.CategoryUpsertWithoutSpaceClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.CategoryUpdateToOneWithWhereWithoutSpaceClassificationsInput,
			Prisma.CategoryUpdateWithoutSpaceClassificationsInput
		>,
		Prisma.CategoryUncheckedUpdateWithoutSpaceClassificationsInput
	>;
};

export type CategoryCreateNestedOneWithoutUserClassificationsInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutUserClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutUserClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutUserClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
};

export type CategoryUpdateOneRequiredWithoutUserClassificationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.CategoryCreateWithoutUserClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutUserClassificationsInput
	>;
	connectOrCreate?: Prisma.CategoryCreateOrConnectWithoutUserClassificationsInput;
	upsert?: Prisma.CategoryUpsertWithoutUserClassificationsInput;
	connect?: Prisma.CategoryWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.CategoryUpdateToOneWithWhereWithoutUserClassificationsInput,
			Prisma.CategoryUpdateWithoutUserClassificationsInput
		>,
		Prisma.CategoryUncheckedUpdateWithoutUserClassificationsInput
	>;
};

export type CategoryCreateWithoutChildrenInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutChildrenInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutChildrenInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutChildrenInput,
		Prisma.CategoryUncheckedCreateWithoutChildrenInput
	>;
};

export type CategoryCreateWithoutParentInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutParentInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	tenantId: string;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutParentInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutParentInput,
		Prisma.CategoryUncheckedCreateWithoutParentInput
	>;
};

export type CategoryCreateManyParentInputEnvelope = {
	data:
		| Prisma.CategoryCreateManyParentInput
		| Prisma.CategoryCreateManyParentInput[];
	skipDuplicates?: boolean;
};

export type CategoryUpsertWithoutChildrenInput = {
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutChildrenInput,
		Prisma.CategoryUncheckedUpdateWithoutChildrenInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutChildrenInput,
		Prisma.CategoryUncheckedCreateWithoutChildrenInput
	>;
	where?: Prisma.CategoryWhereInput;
};

export type CategoryUpdateToOneWithWhereWithoutChildrenInput = {
	where?: Prisma.CategoryWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutChildrenInput,
		Prisma.CategoryUncheckedUpdateWithoutChildrenInput
	>;
};

export type CategoryUpdateWithoutChildrenInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutChildrenInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUpsertWithWhereUniqueWithoutParentInput = {
	where: Prisma.CategoryWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutParentInput,
		Prisma.CategoryUncheckedUpdateWithoutParentInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutParentInput,
		Prisma.CategoryUncheckedCreateWithoutParentInput
	>;
};

export type CategoryUpdateWithWhereUniqueWithoutParentInput = {
	where: Prisma.CategoryWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutParentInput,
		Prisma.CategoryUncheckedUpdateWithoutParentInput
	>;
};

export type CategoryUpdateManyWithWhereWithoutParentInput = {
	where: Prisma.CategoryScalarWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateManyMutationInput,
		Prisma.CategoryUncheckedUpdateManyWithoutParentInput
	>;
};

export type CategoryScalarWhereInput = {
	AND?: Prisma.CategoryScalarWhereInput | Prisma.CategoryScalarWhereInput[];
	OR?: Prisma.CategoryScalarWhereInput[];
	NOT?: Prisma.CategoryScalarWhereInput | Prisma.CategoryScalarWhereInput[];
	id?: Prisma.StringFilter<"Category"> | string;
	seq?: Prisma.IntFilter<"Category"> | number;
	createdAt?: Prisma.DateTimeFilter<"Category"> | Date | string;
	updatedAt?: Prisma.DateTimeNullableFilter<"Category"> | Date | string | null;
	removedAt?: Prisma.DateTimeNullableFilter<"Category"> | Date | string | null;
	name?: Prisma.StringFilter<"Category"> | string;
	type?: Prisma.EnumCategoryTypesFilter<"Category"> | $Enums.CategoryTypes;
	parentId?: Prisma.StringNullableFilter<"Category"> | string | null;
	tenantId?: Prisma.StringFilter<"Category"> | string;
};

export type CategoryCreateWithoutTenantInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutTenantInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutTenantInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutTenantInput,
		Prisma.CategoryUncheckedCreateWithoutTenantInput
	>;
};

export type CategoryCreateManyTenantInputEnvelope = {
	data:
		| Prisma.CategoryCreateManyTenantInput
		| Prisma.CategoryCreateManyTenantInput[];
	skipDuplicates?: boolean;
};

export type CategoryUpsertWithWhereUniqueWithoutTenantInput = {
	where: Prisma.CategoryWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutTenantInput,
		Prisma.CategoryUncheckedUpdateWithoutTenantInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutTenantInput,
		Prisma.CategoryUncheckedCreateWithoutTenantInput
	>;
};

export type CategoryUpdateWithWhereUniqueWithoutTenantInput = {
	where: Prisma.CategoryWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutTenantInput,
		Prisma.CategoryUncheckedUpdateWithoutTenantInput
	>;
};

export type CategoryUpdateManyWithWhereWithoutTenantInput = {
	where: Prisma.CategoryScalarWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateManyMutationInput,
		Prisma.CategoryUncheckedUpdateManyWithoutTenantInput
	>;
};

export type CategoryCreateWithoutFileClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutFileClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutFileClassificationsInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutFileClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutFileClassificationsInput
	>;
};

export type CategoryUpsertWithoutFileClassificationsInput = {
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutFileClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutFileClassificationsInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutFileClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutFileClassificationsInput
	>;
	where?: Prisma.CategoryWhereInput;
};

export type CategoryUpdateToOneWithWhereWithoutFileClassificationsInput = {
	where?: Prisma.CategoryWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutFileClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutFileClassificationsInput
	>;
};

export type CategoryUpdateWithoutFileClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutFileClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryCreateWithoutRoleClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutRoleClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutRoleClassificationsInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutRoleClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutRoleClassificationsInput
	>;
};

export type CategoryUpsertWithoutRoleClassificationsInput = {
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutRoleClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutRoleClassificationsInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutRoleClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutRoleClassificationsInput
	>;
	where?: Prisma.CategoryWhereInput;
};

export type CategoryUpdateToOneWithWhereWithoutRoleClassificationsInput = {
	where?: Prisma.CategoryWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutRoleClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutRoleClassificationsInput
	>;
};

export type CategoryUpdateWithoutRoleClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutRoleClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryCreateWithoutSpaceClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutSpaceClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	userClassifications?: Prisma.UserClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutSpaceClassificationsInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutSpaceClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutSpaceClassificationsInput
	>;
};

export type CategoryUpsertWithoutSpaceClassificationsInput = {
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutSpaceClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutSpaceClassificationsInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutSpaceClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutSpaceClassificationsInput
	>;
	where?: Prisma.CategoryWhereInput;
};

export type CategoryUpdateToOneWithWhereWithoutSpaceClassificationsInput = {
	where?: Prisma.CategoryWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutSpaceClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutSpaceClassificationsInput
	>;
};

export type CategoryUpdateWithoutSpaceClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutSpaceClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryCreateWithoutUserClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parent?: Prisma.CategoryCreateNestedOneWithoutChildrenInput;
	children?: Prisma.CategoryCreateNestedManyWithoutParentInput;
	tenant: Prisma.TenantCreateNestedOneWithoutCategoriesInput;
	fileClassifications?: Prisma.FileClassificationCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationCreateNestedManyWithoutCategoryInput;
};

export type CategoryUncheckedCreateWithoutUserClassificationsInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
	tenantId: string;
	children?: Prisma.CategoryUncheckedCreateNestedManyWithoutParentInput;
	fileClassifications?: Prisma.FileClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedCreateNestedManyWithoutCategoryInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedCreateNestedManyWithoutCategoryInput;
};

export type CategoryCreateOrConnectWithoutUserClassificationsInput = {
	where: Prisma.CategoryWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutUserClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutUserClassificationsInput
	>;
};

export type CategoryUpsertWithoutUserClassificationsInput = {
	update: Prisma.XOR<
		Prisma.CategoryUpdateWithoutUserClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutUserClassificationsInput
	>;
	create: Prisma.XOR<
		Prisma.CategoryCreateWithoutUserClassificationsInput,
		Prisma.CategoryUncheckedCreateWithoutUserClassificationsInput
	>;
	where?: Prisma.CategoryWhereInput;
};

export type CategoryUpdateToOneWithWhereWithoutUserClassificationsInput = {
	where?: Prisma.CategoryWhereInput;
	data: Prisma.XOR<
		Prisma.CategoryUpdateWithoutUserClassificationsInput,
		Prisma.CategoryUncheckedUpdateWithoutUserClassificationsInput
	>;
};

export type CategoryUpdateWithoutUserClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutUserClassificationsInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryCreateManyParentInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	tenantId: string;
};

export type CategoryUpdateWithoutParentInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	tenant?: Prisma.TenantUpdateOneRequiredWithoutCategoriesNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutParentInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateManyWithoutParentInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	tenantId?: Prisma.StringFieldUpdateOperationsInput | string;
};

export type CategoryCreateManyTenantInput = {
	id?: string;
	seq?: number;
	createdAt?: Date | string;
	updatedAt?: Date | string | null;
	removedAt?: Date | string | null;
	name: string;
	type?: $Enums.CategoryTypes;
	parentId?: string | null;
};

export type CategoryUpdateWithoutTenantInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parent?: Prisma.CategoryUpdateOneWithoutChildrenNestedInput;
	children?: Prisma.CategoryUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateWithoutTenantInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	children?: Prisma.CategoryUncheckedUpdateManyWithoutParentNestedInput;
	fileClassifications?: Prisma.FileClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	roleClassifications?: Prisma.RoleClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	spaceClassifications?: Prisma.SpaceClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
	userClassifications?: Prisma.UserClassificationUncheckedUpdateManyWithoutCategoryNestedInput;
};

export type CategoryUncheckedUpdateManyWithoutTenantInput = {
	id?: Prisma.StringFieldUpdateOperationsInput | string;
	seq?: Prisma.IntFieldUpdateOperationsInput | number;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	removedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	name?: Prisma.StringFieldUpdateOperationsInput | string;
	type?:
		| Prisma.EnumCategoryTypesFieldUpdateOperationsInput
		| $Enums.CategoryTypes;
	parentId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

/**
 * Count Type CategoryCountOutputType
 */

export type CategoryCountOutputType = {
	children: number;
	fileClassifications: number;
	roleClassifications: number;
	spaceClassifications: number;
	userClassifications: number;
};

export type CategoryCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	children?: boolean | CategoryCountOutputTypeCountChildrenArgs;
	fileClassifications?:
		| boolean
		| CategoryCountOutputTypeCountFileClassificationsArgs;
	roleClassifications?:
		| boolean
		| CategoryCountOutputTypeCountRoleClassificationsArgs;
	spaceClassifications?:
		| boolean
		| CategoryCountOutputTypeCountSpaceClassificationsArgs;
	userClassifications?:
		| boolean
		| CategoryCountOutputTypeCountUserClassificationsArgs;
};

/**
 * CategoryCountOutputType without action
 */
export type CategoryCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the CategoryCountOutputType
	 */
	select?: Prisma.CategoryCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * CategoryCountOutputType without action
 */
export type CategoryCountOutputTypeCountChildrenArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CategoryWhereInput;
};

/**
 * CategoryCountOutputType without action
 */
export type CategoryCountOutputTypeCountFileClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.FileClassificationWhereInput;
};

/**
 * CategoryCountOutputType without action
 */
export type CategoryCountOutputTypeCountRoleClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.RoleClassificationWhereInput;
};

/**
 * CategoryCountOutputType without action
 */
export type CategoryCountOutputTypeCountSpaceClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.SpaceClassificationWhereInput;
};

/**
 * CategoryCountOutputType without action
 */
export type CategoryCountOutputTypeCountUserClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.UserClassificationWhereInput;
};

export type CategorySelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		seq?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		removedAt?: boolean;
		name?: boolean;
		type?: boolean;
		parentId?: boolean;
		tenantId?: boolean;
		parent?: boolean | Prisma.Category$parentArgs<ExtArgs>;
		children?: boolean | Prisma.Category$childrenArgs<ExtArgs>;
		tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>;
		fileClassifications?:
			| boolean
			| Prisma.Category$fileClassificationsArgs<ExtArgs>;
		roleClassifications?:
			| boolean
			| Prisma.Category$roleClassificationsArgs<ExtArgs>;
		spaceClassifications?:
			| boolean
			| Prisma.Category$spaceClassificationsArgs<ExtArgs>;
		userClassifications?:
			| boolean
			| Prisma.Category$userClassificationsArgs<ExtArgs>;
		_count?: boolean | Prisma.CategoryCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["category"]
>;

export type CategorySelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		seq?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		removedAt?: boolean;
		name?: boolean;
		type?: boolean;
		parentId?: boolean;
		tenantId?: boolean;
		parent?: boolean | Prisma.Category$parentArgs<ExtArgs>;
		tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["category"]
>;

export type CategorySelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		seq?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		removedAt?: boolean;
		name?: boolean;
		type?: boolean;
		parentId?: boolean;
		tenantId?: boolean;
		parent?: boolean | Prisma.Category$parentArgs<ExtArgs>;
		tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>;
	},
	ExtArgs["result"]["category"]
>;

export type CategorySelectScalar = {
	id?: boolean;
	seq?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
	removedAt?: boolean;
	name?: boolean;
	type?: boolean;
	parentId?: boolean;
	tenantId?: boolean;
};

export type CategoryOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| "id"
	| "seq"
	| "createdAt"
	| "updatedAt"
	| "removedAt"
	| "name"
	| "type"
	| "parentId"
	| "tenantId",
	ExtArgs["result"]["category"]
>;
export type CategoryInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	parent?: boolean | Prisma.Category$parentArgs<ExtArgs>;
	children?: boolean | Prisma.Category$childrenArgs<ExtArgs>;
	tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>;
	fileClassifications?:
		| boolean
		| Prisma.Category$fileClassificationsArgs<ExtArgs>;
	roleClassifications?:
		| boolean
		| Prisma.Category$roleClassificationsArgs<ExtArgs>;
	spaceClassifications?:
		| boolean
		| Prisma.Category$spaceClassificationsArgs<ExtArgs>;
	userClassifications?:
		| boolean
		| Prisma.Category$userClassificationsArgs<ExtArgs>;
	_count?: boolean | Prisma.CategoryCountOutputTypeDefaultArgs<ExtArgs>;
};
export type CategoryIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	parent?: boolean | Prisma.Category$parentArgs<ExtArgs>;
	tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>;
};
export type CategoryIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	parent?: boolean | Prisma.Category$parentArgs<ExtArgs>;
	tenant?: boolean | Prisma.TenantDefaultArgs<ExtArgs>;
};

export type $CategoryPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: "Category";
	objects: {
		parent: Prisma.$CategoryPayload<ExtArgs> | null;
		children: Prisma.$CategoryPayload<ExtArgs>[];
		tenant: Prisma.$TenantPayload<ExtArgs>;
		fileClassifications: Prisma.$FileClassificationPayload<ExtArgs>[];
		roleClassifications: Prisma.$RoleClassificationPayload<ExtArgs>[];
		spaceClassifications: Prisma.$SpaceClassificationPayload<ExtArgs>[];
		userClassifications: Prisma.$UserClassificationPayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: string;
			seq: number;
			createdAt: Date;
			updatedAt: Date | null;
			removedAt: Date | null;
			name: string;
			type: $Enums.CategoryTypes;
			parentId: string | null;
			tenantId: string;
		},
		ExtArgs["result"]["category"]
	>;
	composites: {};
};

export type CategoryGetPayload<
	S extends boolean | null | undefined | CategoryDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$CategoryPayload, S>;

export type CategoryCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<CategoryFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
	select?: CategoryCountAggregateInputType | true;
};

export interface CategoryDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>["model"]["Category"];
		meta: { name: "Category" };
	};
	/**
	 * Find zero or one Category that matches the filter.
	 * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
	 * @example
	 * // Get one Category
	 * const category = await prisma.category.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends CategoryFindUniqueArgs>(
		args: Prisma.SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"findUnique",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Category that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
	 * @example
	 * // Get one Category
	 * const category = await prisma.category.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Category that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryFindFirstArgs} args - Arguments to find a Category
	 * @example
	 * // Get one Category
	 * const category = await prisma.category.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends CategoryFindFirstArgs>(
		args?: Prisma.SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"findFirst",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Category that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
	 * @example
	 * // Get one Category
	 * const category = await prisma.category.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"findFirstOrThrow",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Categories that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Categories
	 * const categories = await prisma.category.findMany()
	 *
	 * // Get first 10 Categories
	 * const categories = await prisma.category.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends CategoryFindManyArgs>(
		args?: Prisma.SelectSubset<T, CategoryFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"findMany",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Category.
	 * @param {CategoryCreateArgs} args - Arguments to create a Category.
	 * @example
	 * // Create one Category
	 * const Category = await prisma.category.create({
	 *   data: {
	 *     // ... data to create a Category
	 *   }
	 * })
	 *
	 */
	create<T extends CategoryCreateArgs>(
		args: Prisma.SelectSubset<T, CategoryCreateArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"create",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Categories.
	 * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
	 * @example
	 * // Create many Categories
	 * const category = await prisma.category.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends CategoryCreateManyArgs>(
		args?: Prisma.SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many Categories and returns the data saved in the database.
	 * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
	 * @example
	 * // Create many Categories
	 * const category = await prisma.category.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Categories and only return the `id`
	 * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"createManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a Category.
	 * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
	 * @example
	 * // Delete one Category
	 * const Category = await prisma.category.delete({
	 *   where: {
	 *     // ... filter to delete one Category
	 *   }
	 * })
	 *
	 */
	delete<T extends CategoryDeleteArgs>(
		args: Prisma.SelectSubset<T, CategoryDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"delete",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Category.
	 * @param {CategoryUpdateArgs} args - Arguments to update one Category.
	 * @example
	 * // Update one Category
	 * const category = await prisma.category.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends CategoryUpdateArgs>(
		args: Prisma.SelectSubset<T, CategoryUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"update",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Categories.
	 * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
	 * @example
	 * // Delete a few Categories
	 * const { count } = await prisma.category.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends CategoryDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Categories.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Categories
	 * const category = await prisma.category.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends CategoryUpdateManyArgs>(
		args: Prisma.SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Categories and returns the data updated in the database.
	 * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
	 * @example
	 * // Update many Categories
	 * const category = await prisma.category.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Categories and only return the `id`
	 * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"updateManyAndReturn",
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one Category.
	 * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
	 * @example
	 * // Update or create a Category
	 * const category = await prisma.category.upsert({
	 *   create: {
	 *     // ... data to create a Category
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Category we want to update
	 *   }
	 * })
	 */
	upsert<T extends CategoryUpsertArgs>(
		args: Prisma.SelectSubset<T, CategoryUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"upsert",
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of Categories.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
	 * @example
	 * // Count the number of Categories
	 * const count = await prisma.category.count({
	 *   where: {
	 *     // ... the filter for the Categories we want to count
	 *   }
	 * })
	 **/
	count<T extends CategoryCountArgs>(
		args?: Prisma.Subset<T, CategoryCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<"select", any>
			? T["select"] extends true
				? number
				: Prisma.GetScalarType<T["select"], CategoryCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Category.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends CategoryAggregateArgs>(
		args: Prisma.Subset<T, CategoryAggregateArgs>,
	): Prisma.PrismaPromise<GetCategoryAggregateType<T>>;

	/**
	 * Group by Category.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {CategoryGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends CategoryGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<"skip", Prisma.Keys<T>>,
			Prisma.Extends<"take", Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: CategoryGroupByArgs["orderBy"] }
			: { orderBy?: CategoryGroupByArgs["orderBy"] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T["having"]>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										"Field ",
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: "take" extends Prisma.Keys<T>
					? "orderBy" extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: "skip" extends Prisma.Keys<T>
						? "orderBy" extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetCategoryGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Category model
	 */
	readonly fields: CategoryFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Category.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__CategoryClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: "PrismaPromise";
	parent<T extends Prisma.Category$parentArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Category$parentArgs<ExtArgs>>,
	): Prisma.Prisma__CategoryClient<
		runtime.Types.Result.GetResult<
			Prisma.$CategoryPayload<ExtArgs>,
			T,
			"findUniqueOrThrow",
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;
	children<T extends Prisma.Category$childrenArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Category$childrenArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$CategoryPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	tenant<T extends Prisma.TenantDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.TenantDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__TenantClient<
		| runtime.Types.Result.GetResult<
				Prisma.$TenantPayload<ExtArgs>,
				T,
				"findUniqueOrThrow",
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	fileClassifications<
		T extends Prisma.Category$fileClassificationsArgs<ExtArgs> = {},
	>(
		args?: Prisma.Subset<T, Prisma.Category$fileClassificationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$FileClassificationPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	roleClassifications<
		T extends Prisma.Category$roleClassificationsArgs<ExtArgs> = {},
	>(
		args?: Prisma.Subset<T, Prisma.Category$roleClassificationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$RoleClassificationPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	spaceClassifications<
		T extends Prisma.Category$spaceClassificationsArgs<ExtArgs> = {},
	>(
		args?: Prisma.Subset<T, Prisma.Category$spaceClassificationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$SpaceClassificationPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	userClassifications<
		T extends Prisma.Category$userClassificationsArgs<ExtArgs> = {},
	>(
		args?: Prisma.Subset<T, Prisma.Category$userClassificationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$UserClassificationPayload<ExtArgs>,
				T,
				"findMany",
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Category model
 */
export interface CategoryFieldRefs {
	readonly id: Prisma.FieldRef<"Category", "String">;
	readonly seq: Prisma.FieldRef<"Category", "Int">;
	readonly createdAt: Prisma.FieldRef<"Category", "DateTime">;
	readonly updatedAt: Prisma.FieldRef<"Category", "DateTime">;
	readonly removedAt: Prisma.FieldRef<"Category", "DateTime">;
	readonly name: Prisma.FieldRef<"Category", "String">;
	readonly type: Prisma.FieldRef<"Category", "CategoryTypes">;
	readonly parentId: Prisma.FieldRef<"Category", "String">;
	readonly tenantId: Prisma.FieldRef<"Category", "String">;
}

// Custom InputTypes
/**
 * Category findUnique
 */
export type CategoryFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * Filter, which Category to fetch.
	 */
	where: Prisma.CategoryWhereUniqueInput;
};

/**
 * Category findUniqueOrThrow
 */
export type CategoryFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * Filter, which Category to fetch.
	 */
	where: Prisma.CategoryWhereUniqueInput;
};

/**
 * Category findFirst
 */
export type CategoryFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * Filter, which Category to fetch.
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Categories to fetch.
	 */
	orderBy?:
		| Prisma.CategoryOrderByWithRelationInput
		| Prisma.CategoryOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Categories.
	 */
	cursor?: Prisma.CategoryWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Categories from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Categories.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Categories.
	 */
	distinct?: Prisma.CategoryScalarFieldEnum | Prisma.CategoryScalarFieldEnum[];
};

/**
 * Category findFirstOrThrow
 */
export type CategoryFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * Filter, which Category to fetch.
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Categories to fetch.
	 */
	orderBy?:
		| Prisma.CategoryOrderByWithRelationInput
		| Prisma.CategoryOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Categories.
	 */
	cursor?: Prisma.CategoryWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Categories from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Categories.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Categories.
	 */
	distinct?: Prisma.CategoryScalarFieldEnum | Prisma.CategoryScalarFieldEnum[];
};

/**
 * Category findMany
 */
export type CategoryFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * Filter, which Categories to fetch.
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Categories to fetch.
	 */
	orderBy?:
		| Prisma.CategoryOrderByWithRelationInput
		| Prisma.CategoryOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Categories.
	 */
	cursor?: Prisma.CategoryWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Categories from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Categories.
	 */
	skip?: number;
	distinct?: Prisma.CategoryScalarFieldEnum | Prisma.CategoryScalarFieldEnum[];
};

/**
 * Category create
 */
export type CategoryCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Category.
	 */
	data: Prisma.XOR<
		Prisma.CategoryCreateInput,
		Prisma.CategoryUncheckedCreateInput
	>;
};

/**
 * Category createMany
 */
export type CategoryCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Categories.
	 */
	data: Prisma.CategoryCreateManyInput | Prisma.CategoryCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Category createManyAndReturn
 */
export type CategoryCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * The data used to create many Categories.
	 */
	data: Prisma.CategoryCreateManyInput | Prisma.CategoryCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Category update
 */
export type CategoryUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Category.
	 */
	data: Prisma.XOR<
		Prisma.CategoryUpdateInput,
		Prisma.CategoryUncheckedUpdateInput
	>;
	/**
	 * Choose, which Category to update.
	 */
	where: Prisma.CategoryWhereUniqueInput;
};

/**
 * Category updateMany
 */
export type CategoryUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Categories.
	 */
	data: Prisma.XOR<
		Prisma.CategoryUpdateManyMutationInput,
		Prisma.CategoryUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Categories to update
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * Limit how many Categories to update.
	 */
	limit?: number;
};

/**
 * Category updateManyAndReturn
 */
export type CategoryUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * The data used to update Categories.
	 */
	data: Prisma.XOR<
		Prisma.CategoryUpdateManyMutationInput,
		Prisma.CategoryUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Categories to update
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * Limit how many Categories to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Category upsert
 */
export type CategoryUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Category to update in case it exists.
	 */
	where: Prisma.CategoryWhereUniqueInput;
	/**
	 * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
	 */
	create: Prisma.XOR<
		Prisma.CategoryCreateInput,
		Prisma.CategoryUncheckedCreateInput
	>;
	/**
	 * In case the Category was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<
		Prisma.CategoryUpdateInput,
		Prisma.CategoryUncheckedUpdateInput
	>;
};

/**
 * Category delete
 */
export type CategoryDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	/**
	 * Filter which Category to delete.
	 */
	where: Prisma.CategoryWhereUniqueInput;
};

/**
 * Category deleteMany
 */
export type CategoryDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Categories to delete
	 */
	where?: Prisma.CategoryWhereInput;
	/**
	 * Limit how many Categories to delete.
	 */
	limit?: number;
};

/**
 * Category.parent
 */
export type Category$parentArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	where?: Prisma.CategoryWhereInput;
};

/**
 * Category.children
 */
export type Category$childrenArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
	where?: Prisma.CategoryWhereInput;
	orderBy?:
		| Prisma.CategoryOrderByWithRelationInput
		| Prisma.CategoryOrderByWithRelationInput[];
	cursor?: Prisma.CategoryWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.CategoryScalarFieldEnum | Prisma.CategoryScalarFieldEnum[];
};

/**
 * Category.fileClassifications
 */
export type Category$fileClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the FileClassification
	 */
	select?: Prisma.FileClassificationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the FileClassification
	 */
	omit?: Prisma.FileClassificationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.FileClassificationInclude<ExtArgs> | null;
	where?: Prisma.FileClassificationWhereInput;
	orderBy?:
		| Prisma.FileClassificationOrderByWithRelationInput
		| Prisma.FileClassificationOrderByWithRelationInput[];
	cursor?: Prisma.FileClassificationWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.FileClassificationScalarFieldEnum
		| Prisma.FileClassificationScalarFieldEnum[];
};

/**
 * Category.roleClassifications
 */
export type Category$roleClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the RoleClassification
	 */
	select?: Prisma.RoleClassificationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the RoleClassification
	 */
	omit?: Prisma.RoleClassificationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.RoleClassificationInclude<ExtArgs> | null;
	where?: Prisma.RoleClassificationWhereInput;
	orderBy?:
		| Prisma.RoleClassificationOrderByWithRelationInput
		| Prisma.RoleClassificationOrderByWithRelationInput[];
	cursor?: Prisma.RoleClassificationWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.RoleClassificationScalarFieldEnum
		| Prisma.RoleClassificationScalarFieldEnum[];
};

/**
 * Category.spaceClassifications
 */
export type Category$spaceClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the SpaceClassification
	 */
	select?: Prisma.SpaceClassificationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the SpaceClassification
	 */
	omit?: Prisma.SpaceClassificationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.SpaceClassificationInclude<ExtArgs> | null;
	where?: Prisma.SpaceClassificationWhereInput;
	orderBy?:
		| Prisma.SpaceClassificationOrderByWithRelationInput
		| Prisma.SpaceClassificationOrderByWithRelationInput[];
	cursor?: Prisma.SpaceClassificationWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.SpaceClassificationScalarFieldEnum
		| Prisma.SpaceClassificationScalarFieldEnum[];
};

/**
 * Category.userClassifications
 */
export type Category$userClassificationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the UserClassification
	 */
	select?: Prisma.UserClassificationSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the UserClassification
	 */
	omit?: Prisma.UserClassificationOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserClassificationInclude<ExtArgs> | null;
	where?: Prisma.UserClassificationWhereInput;
	orderBy?:
		| Prisma.UserClassificationOrderByWithRelationInput
		| Prisma.UserClassificationOrderByWithRelationInput[];
	cursor?: Prisma.UserClassificationWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?:
		| Prisma.UserClassificationScalarFieldEnum
		| Prisma.UserClassificationScalarFieldEnum[];
};

/**
 * Category without action
 */
export type CategoryDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Category
	 */
	select?: Prisma.CategorySelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Category
	 */
	omit?: Prisma.CategoryOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CategoryInclude<ExtArgs> | null;
};
