/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client";
import type * as Prisma from "../models";
import { type PrismaClient } from "./class";

export type * from "../models";

export type DMMF = typeof runtime.DMMF;

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>;

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError =
	runtime.PrismaClientKnownRequestError;
export type PrismaClientKnownRequestError =
	runtime.PrismaClientKnownRequestError;

export const PrismaClientUnknownRequestError =
	runtime.PrismaClientUnknownRequestError;
export type PrismaClientUnknownRequestError =
	runtime.PrismaClientUnknownRequestError;

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;

export const PrismaClientInitializationError =
	runtime.PrismaClientInitializationError;
export type PrismaClientInitializationError =
	runtime.PrismaClientInitializationError;

export const PrismaClientValidationError = runtime.PrismaClientValidationError;
export type PrismaClientValidationError = runtime.PrismaClientValidationError;

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag;
export const empty = runtime.empty;
export const join = runtime.join;
export const raw = runtime.raw;
export const Sql = runtime.Sql;
export type Sql = runtime.Sql;

/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal;
export type Decimal = runtime.Decimal;

export type DecimalJsLike = runtime.DecimalJsLike;

/**
 * Extensions
 */
export type Extension = runtime.Types.Extensions.UserArgs;
export const getExtensionContext = runtime.Extensions.getExtensionContext;
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<
	T,
	F
>;
export type Payload<
	T,
	F extends runtime.Operation = never,
> = runtime.Types.Public.Payload<T, F>;
export type Result<
	T,
	A,
	F extends runtime.Operation,
> = runtime.Types.Public.Result<T, A, F>;
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>;

export type PrismaVersion = {
	client: string;
	engine: string;
};

/**
 * Prisma Client JS version: 7.1.0
 * Query Engine version: ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba
 */
export const prismaVersion: PrismaVersion = {
	client: "7.1.0",
	engine: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba",
};

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes;
export type JsonObject = runtime.JsonObject;
export type JsonArray = runtime.JsonArray;
export type JsonValue = runtime.JsonValue;
export type InputJsonObject = runtime.InputJsonObject;
export type InputJsonArray = runtime.InputJsonArray;
export type InputJsonValue = runtime.InputJsonValue;

export const NullTypes = {
	DbNull: runtime.NullTypes.DbNull as new (
		secret: never,
	) => typeof runtime.DbNull,
	JsonNull: runtime.NullTypes.JsonNull as new (
		secret: never,
	) => typeof runtime.JsonNull,
	AnyNull: runtime.NullTypes.AnyNull as new (
		secret: never,
	) => typeof runtime.AnyNull,
};
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull;

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull;

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull;

type SelectAndInclude = {
	select: any;
	include: any;
};

type SelectAndOmit = {
	select: any;
	omit: any;
};

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
	[P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
	[key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
	[key in keyof T]: key extends keyof U ? T[key] : never;
} & (T extends SelectAndInclude
	? "Please either choose `select` or `include`."
	: T extends SelectAndOmit
		? "Please either choose `select` or `omit`."
		: {});

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
	[key in keyof T]: key extends keyof U ? T[key] : never;
} & K;

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> = T extends object
	? U extends object
		? (Without<T, U> & U) | (Without<U, T> & T)
		: U
	: T;

/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
	? False
	: T extends Date
		? False
		: T extends Uint8Array
			? False
			: T extends BigInt
				? False
				: T extends object
					? True
					: False;

/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
	{
		// Merge all but K
		[P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
	}[K];

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

type _Either<O extends object, K extends Key, strict extends Boolean> = {
	1: EitherStrict<O, K>;
	0: EitherLoose<O, K>;
}[strict];

export type Either<
	O extends object,
	K extends Key,
	strict extends Boolean = 1,
> = O extends unknown ? _Either<O, K, strict> : never;

export type Union = any;

export type PatchUndefined<O extends object, O1 extends object> = {
	[K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
} & {};

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
	U extends unknown
		? (k: U) => void
		: never
) extends (k: infer I) => void
	? I
	: never;

export type Overwrite<O extends object, O1 extends object> = {
	[K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<
	Overwrite<
		U,
		{
			[K in keyof U]-?: At<U, K>;
		}
	>
>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown
	? AtStrict<O, K>
	: never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
	1: AtStrict<O, K>;
	0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function
	? A
	: {
			[K in keyof A]: A[K];
		} & {};

export type OptionalFlat<O> = {
	[K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
	[P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
	O extends unknown
		?
				| (K extends keyof O ? { [P in K]: O[P] } & O : O)
				| ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
		: never
>;

type _Strict<U, _U = U> = U extends unknown
	? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
	: never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False;

export type True = 1;

export type False = 0;

export type Not<B extends Boolean> = {
	0: 1;
	1: 0;
}[B];

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
	? 0 // anything `never` is false
	: A1 extends A2
		? 1
		: 0;

export type Has<U extends Union, U1 extends Union> = Not<
	Extends<Exclude<U1, U>, U1>
>;

export type Or<B1 extends Boolean, B2 extends Boolean> = {
	0: {
		0: 0;
		1: 1;
	};
	1: {
		0: 1;
		1: 1;
	};
}[B1][B2];

export type Keys<U extends Union> = U extends unknown ? keyof U : never;

export type GetScalarType<T, O> = O extends object
	? {
			[P in keyof T]: P extends keyof O ? O[P] : never;
		}
	: never;

type FieldPaths<
	T,
	U = Omit<T, "_avg" | "_sum" | "_count" | "_min" | "_max">,
> = IsObject<T> extends True ? U : T;

export type GetHavingFields<T> = {
	[K in keyof T]: Or<
		Or<Extends<"OR", K>, Extends<"AND", K>>,
		Extends<"NOT", K>
	> extends True
		? // infer is only needed to not hit TS limit
			// based on the brilliant idea of Pierre-Antoine Mills
			// https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
			T[K] extends infer TK
			? GetHavingFields<
					UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
				>
			: never
		: {} extends FieldPaths<T[K]>
			? never
			: K;
}[keyof T];

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<
	T,
	K extends Enumerable<keyof T> | keyof T,
> = Prisma__Pick<T, MaybeTupleToUnion<K>>;

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
	? never
	: T;

export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

type FieldRefInputType<Model, FieldType> = Model extends never
	? never
	: FieldRef<Model, FieldType>;

export const ModelName = {
	Category: "Category",
	Group: "Group",
	Tenant: "Tenant",
	Assignment: "Assignment",
	Action: "Action",
	Subject: "Subject",
	Ability: "Ability",
	Post: "Post",
	Content: "Content",
	File: "File",
	FileClassification: "FileClassification",
	FileAssociation: "FileAssociation",
	Role: "Role",
	RoleAssociation: "RoleAssociation",
	RoleClassification: "RoleClassification",
	SafeWallet: "SafeWallet",
	SafeTransaction: "SafeTransaction",
	SafeConfirmation: "SafeConfirmation",
	Space: "Space",
	SpaceClassification: "SpaceClassification",
	SpaceAssociation: "SpaceAssociation",
	Ground: "Ground",
	Timeline: "Timeline",
	Session: "Session",
	Program: "Program",
	Routine: "Routine",
	Activity: "Activity",
	Task: "Task",
	Exercise: "Exercise",
	User: "User",
	UserClassification: "UserClassification",
	UserAssociation: "UserAssociation",
	Profile: "Profile",
} as const;

export type ModelName = (typeof ModelName)[keyof typeof ModelName];

export interface TypeMapCb<GlobalOmitOptions = {}>
	extends runtime.Types.Utils.Fn<
		{ extArgs: runtime.Types.Extensions.InternalArgs },
		runtime.Types.Utils.Record<string, any>
	> {
	returns: TypeMap<this["params"]["extArgs"], GlobalOmitOptions>;
}

export type TypeMap<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> = {
	globalOmitOptions: {
		omit: GlobalOmitOptions;
	};
	meta: {
		modelProps:
			| "category"
			| "group"
			| "tenant"
			| "assignment"
			| "action"
			| "subject"
			| "ability"
			| "post"
			| "content"
			| "file"
			| "fileClassification"
			| "fileAssociation"
			| "role"
			| "roleAssociation"
			| "roleClassification"
			| "safeWallet"
			| "safeTransaction"
			| "safeConfirmation"
			| "space"
			| "spaceClassification"
			| "spaceAssociation"
			| "ground"
			| "timeline"
			| "session"
			| "program"
			| "routine"
			| "activity"
			| "task"
			| "exercise"
			| "user"
			| "userClassification"
			| "userAssociation"
			| "profile";
		txIsolationLevel: TransactionIsolationLevel;
	};
	model: {
		Category: {
			payload: Prisma.$CategoryPayload<ExtArgs>;
			fields: Prisma.CategoryFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.CategoryFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>;
				};
				findFirst: {
					args: Prisma.CategoryFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>;
				};
				findMany: {
					args: Prisma.CategoryFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[];
				};
				create: {
					args: Prisma.CategoryCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>;
				};
				createMany: {
					args: Prisma.CategoryCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[];
				};
				delete: {
					args: Prisma.CategoryDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>;
				};
				update: {
					args: Prisma.CategoryUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>;
				};
				deleteMany: {
					args: Prisma.CategoryDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.CategoryUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>[];
				};
				upsert: {
					args: Prisma.CategoryUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$CategoryPayload>;
				};
				aggregate: {
					args: Prisma.CategoryAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateCategory>;
				};
				groupBy: {
					args: Prisma.CategoryGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.CategoryGroupByOutputType>[];
				};
				count: {
					args: Prisma.CategoryCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.CategoryCountAggregateOutputType>
						| number;
				};
			};
		};
		Group: {
			payload: Prisma.$GroupPayload<ExtArgs>;
			fields: Prisma.GroupFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.GroupFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.GroupFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>;
				};
				findFirst: {
					args: Prisma.GroupFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.GroupFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>;
				};
				findMany: {
					args: Prisma.GroupFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>[];
				};
				create: {
					args: Prisma.GroupCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>;
				};
				createMany: {
					args: Prisma.GroupCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.GroupCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>[];
				};
				delete: {
					args: Prisma.GroupDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>;
				};
				update: {
					args: Prisma.GroupUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>;
				};
				deleteMany: {
					args: Prisma.GroupDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.GroupUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.GroupUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>[];
				};
				upsert: {
					args: Prisma.GroupUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupPayload>;
				};
				aggregate: {
					args: Prisma.GroupAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateGroup>;
				};
				groupBy: {
					args: Prisma.GroupGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.GroupGroupByOutputType>[];
				};
				count: {
					args: Prisma.GroupCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.GroupCountAggregateOutputType>
						| number;
				};
			};
		};
		Tenant: {
			payload: Prisma.$TenantPayload<ExtArgs>;
			fields: Prisma.TenantFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.TenantFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>;
				};
				findFirst: {
					args: Prisma.TenantFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>;
				};
				findMany: {
					args: Prisma.TenantFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[];
				};
				create: {
					args: Prisma.TenantCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>;
				};
				createMany: {
					args: Prisma.TenantCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[];
				};
				delete: {
					args: Prisma.TenantDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>;
				};
				update: {
					args: Prisma.TenantUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>;
				};
				deleteMany: {
					args: Prisma.TenantDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.TenantUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>[];
				};
				upsert: {
					args: Prisma.TenantUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TenantPayload>;
				};
				aggregate: {
					args: Prisma.TenantAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateTenant>;
				};
				groupBy: {
					args: Prisma.TenantGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.TenantGroupByOutputType>[];
				};
				count: {
					args: Prisma.TenantCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.TenantCountAggregateOutputType>
						| number;
				};
			};
		};
		Assignment: {
			payload: Prisma.$AssignmentPayload<ExtArgs>;
			fields: Prisma.AssignmentFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.AssignmentFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.AssignmentFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
				};
				findFirst: {
					args: Prisma.AssignmentFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.AssignmentFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
				};
				findMany: {
					args: Prisma.AssignmentFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[];
				};
				create: {
					args: Prisma.AssignmentCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
				};
				createMany: {
					args: Prisma.AssignmentCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.AssignmentCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[];
				};
				delete: {
					args: Prisma.AssignmentDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
				};
				update: {
					args: Prisma.AssignmentUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
				};
				deleteMany: {
					args: Prisma.AssignmentDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.AssignmentUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.AssignmentUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>[];
				};
				upsert: {
					args: Prisma.AssignmentUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AssignmentPayload>;
				};
				aggregate: {
					args: Prisma.AssignmentAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateAssignment>;
				};
				groupBy: {
					args: Prisma.AssignmentGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AssignmentGroupByOutputType>[];
				};
				count: {
					args: Prisma.AssignmentCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.AssignmentCountAggregateOutputType>
						| number;
				};
			};
		};
		Action: {
			payload: Prisma.$ActionPayload<ExtArgs>;
			fields: Prisma.ActionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ActionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ActionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>;
				};
				findFirst: {
					args: Prisma.ActionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ActionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>;
				};
				findMany: {
					args: Prisma.ActionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>[];
				};
				create: {
					args: Prisma.ActionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>;
				};
				createMany: {
					args: Prisma.ActionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ActionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>[];
				};
				delete: {
					args: Prisma.ActionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>;
				};
				update: {
					args: Prisma.ActionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>;
				};
				deleteMany: {
					args: Prisma.ActionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ActionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ActionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>[];
				};
				upsert: {
					args: Prisma.ActionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActionPayload>;
				};
				aggregate: {
					args: Prisma.ActionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateAction>;
				};
				groupBy: {
					args: Prisma.ActionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ActionGroupByOutputType>[];
				};
				count: {
					args: Prisma.ActionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ActionCountAggregateOutputType>
						| number;
				};
			};
		};
		Subject: {
			payload: Prisma.$SubjectPayload<ExtArgs>;
			fields: Prisma.SubjectFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SubjectFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SubjectFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
				};
				findFirst: {
					args: Prisma.SubjectFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SubjectFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
				};
				findMany: {
					args: Prisma.SubjectFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>[];
				};
				create: {
					args: Prisma.SubjectCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
				};
				createMany: {
					args: Prisma.SubjectCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SubjectCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>[];
				};
				delete: {
					args: Prisma.SubjectDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
				};
				update: {
					args: Prisma.SubjectUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
				};
				deleteMany: {
					args: Prisma.SubjectDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SubjectUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SubjectUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>[];
				};
				upsert: {
					args: Prisma.SubjectUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SubjectPayload>;
				};
				aggregate: {
					args: Prisma.SubjectAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSubject>;
				};
				groupBy: {
					args: Prisma.SubjectGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SubjectGroupByOutputType>[];
				};
				count: {
					args: Prisma.SubjectCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SubjectCountAggregateOutputType>
						| number;
				};
			};
		};
		Ability: {
			payload: Prisma.$AbilityPayload<ExtArgs>;
			fields: Prisma.AbilityFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.AbilityFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.AbilityFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>;
				};
				findFirst: {
					args: Prisma.AbilityFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.AbilityFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>;
				};
				findMany: {
					args: Prisma.AbilityFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>[];
				};
				create: {
					args: Prisma.AbilityCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>;
				};
				createMany: {
					args: Prisma.AbilityCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.AbilityCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>[];
				};
				delete: {
					args: Prisma.AbilityDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>;
				};
				update: {
					args: Prisma.AbilityUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>;
				};
				deleteMany: {
					args: Prisma.AbilityDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.AbilityUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.AbilityUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>[];
				};
				upsert: {
					args: Prisma.AbilityUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$AbilityPayload>;
				};
				aggregate: {
					args: Prisma.AbilityAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateAbility>;
				};
				groupBy: {
					args: Prisma.AbilityGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AbilityGroupByOutputType>[];
				};
				count: {
					args: Prisma.AbilityCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.AbilityCountAggregateOutputType>
						| number;
				};
			};
		};
		Post: {
			payload: Prisma.$PostPayload<ExtArgs>;
			fields: Prisma.PostFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.PostFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>;
				};
				findFirst: {
					args: Prisma.PostFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>;
				};
				findMany: {
					args: Prisma.PostFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[];
				};
				create: {
					args: Prisma.PostCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>;
				};
				createMany: {
					args: Prisma.PostCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[];
				};
				delete: {
					args: Prisma.PostDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>;
				};
				update: {
					args: Prisma.PostUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>;
				};
				deleteMany: {
					args: Prisma.PostDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.PostUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>[];
				};
				upsert: {
					args: Prisma.PostUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$PostPayload>;
				};
				aggregate: {
					args: Prisma.PostAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregatePost>;
				};
				groupBy: {
					args: Prisma.PostGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.PostGroupByOutputType>[];
				};
				count: {
					args: Prisma.PostCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.PostCountAggregateOutputType>
						| number;
				};
			};
		};
		Content: {
			payload: Prisma.$ContentPayload<ExtArgs>;
			fields: Prisma.ContentFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ContentFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>;
				};
				findFirst: {
					args: Prisma.ContentFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>;
				};
				findMany: {
					args: Prisma.ContentFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>[];
				};
				create: {
					args: Prisma.ContentCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>;
				};
				createMany: {
					args: Prisma.ContentCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>[];
				};
				delete: {
					args: Prisma.ContentDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>;
				};
				update: {
					args: Prisma.ContentUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>;
				};
				deleteMany: {
					args: Prisma.ContentDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ContentUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ContentUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>[];
				};
				upsert: {
					args: Prisma.ContentUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ContentPayload>;
				};
				aggregate: {
					args: Prisma.ContentAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateContent>;
				};
				groupBy: {
					args: Prisma.ContentGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ContentGroupByOutputType>[];
				};
				count: {
					args: Prisma.ContentCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ContentCountAggregateOutputType>
						| number;
				};
			};
		};
		File: {
			payload: Prisma.$FilePayload<ExtArgs>;
			fields: Prisma.FileFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FileFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
				};
				findFirst: {
					args: Prisma.FileFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
				};
				findMany: {
					args: Prisma.FileFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[];
				};
				create: {
					args: Prisma.FileCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
				};
				createMany: {
					args: Prisma.FileCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[];
				};
				delete: {
					args: Prisma.FileDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
				};
				update: {
					args: Prisma.FileUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
				};
				deleteMany: {
					args: Prisma.FileDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FileUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>[];
				};
				upsert: {
					args: Prisma.FileUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FilePayload>;
				};
				aggregate: {
					args: Prisma.FileAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFile>;
				};
				groupBy: {
					args: Prisma.FileGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FileGroupByOutputType>[];
				};
				count: {
					args: Prisma.FileCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FileCountAggregateOutputType>
						| number;
				};
			};
		};
		FileClassification: {
			payload: Prisma.$FileClassificationPayload<ExtArgs>;
			fields: Prisma.FileClassificationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FileClassificationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FileClassificationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>;
				};
				findFirst: {
					args: Prisma.FileClassificationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FileClassificationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>;
				};
				findMany: {
					args: Prisma.FileClassificationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>[];
				};
				create: {
					args: Prisma.FileClassificationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>;
				};
				createMany: {
					args: Prisma.FileClassificationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FileClassificationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>[];
				};
				delete: {
					args: Prisma.FileClassificationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>;
				};
				update: {
					args: Prisma.FileClassificationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>;
				};
				deleteMany: {
					args: Prisma.FileClassificationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FileClassificationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FileClassificationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>[];
				};
				upsert: {
					args: Prisma.FileClassificationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileClassificationPayload>;
				};
				aggregate: {
					args: Prisma.FileClassificationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFileClassification>;
				};
				groupBy: {
					args: Prisma.FileClassificationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FileClassificationGroupByOutputType>[];
				};
				count: {
					args: Prisma.FileClassificationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FileClassificationCountAggregateOutputType>
						| number;
				};
			};
		};
		FileAssociation: {
			payload: Prisma.$FileAssociationPayload<ExtArgs>;
			fields: Prisma.FileAssociationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.FileAssociationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.FileAssociationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>;
				};
				findFirst: {
					args: Prisma.FileAssociationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.FileAssociationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>;
				};
				findMany: {
					args: Prisma.FileAssociationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>[];
				};
				create: {
					args: Prisma.FileAssociationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>;
				};
				createMany: {
					args: Prisma.FileAssociationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.FileAssociationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>[];
				};
				delete: {
					args: Prisma.FileAssociationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>;
				};
				update: {
					args: Prisma.FileAssociationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>;
				};
				deleteMany: {
					args: Prisma.FileAssociationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.FileAssociationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.FileAssociationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>[];
				};
				upsert: {
					args: Prisma.FileAssociationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$FileAssociationPayload>;
				};
				aggregate: {
					args: Prisma.FileAssociationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateFileAssociation>;
				};
				groupBy: {
					args: Prisma.FileAssociationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.FileAssociationGroupByOutputType>[];
				};
				count: {
					args: Prisma.FileAssociationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.FileAssociationCountAggregateOutputType>
						| number;
				};
			};
		};
		Role: {
			payload: Prisma.$RolePayload<ExtArgs>;
			fields: Prisma.RoleFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.RoleFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
				};
				findFirst: {
					args: Prisma.RoleFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
				};
				findMany: {
					args: Prisma.RoleFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
				};
				create: {
					args: Prisma.RoleCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
				};
				createMany: {
					args: Prisma.RoleCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
				};
				delete: {
					args: Prisma.RoleDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
				};
				update: {
					args: Prisma.RoleUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
				};
				deleteMany: {
					args: Prisma.RoleDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.RoleUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>[];
				};
				upsert: {
					args: Prisma.RoleUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RolePayload>;
				};
				aggregate: {
					args: Prisma.RoleAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateRole>;
				};
				groupBy: {
					args: Prisma.RoleGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.RoleGroupByOutputType>[];
				};
				count: {
					args: Prisma.RoleCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.RoleCountAggregateOutputType>
						| number;
				};
			};
		};
		RoleAssociation: {
			payload: Prisma.$RoleAssociationPayload<ExtArgs>;
			fields: Prisma.RoleAssociationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.RoleAssociationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.RoleAssociationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>;
				};
				findFirst: {
					args: Prisma.RoleAssociationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.RoleAssociationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>;
				};
				findMany: {
					args: Prisma.RoleAssociationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>[];
				};
				create: {
					args: Prisma.RoleAssociationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>;
				};
				createMany: {
					args: Prisma.RoleAssociationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.RoleAssociationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>[];
				};
				delete: {
					args: Prisma.RoleAssociationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>;
				};
				update: {
					args: Prisma.RoleAssociationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>;
				};
				deleteMany: {
					args: Prisma.RoleAssociationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.RoleAssociationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.RoleAssociationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>[];
				};
				upsert: {
					args: Prisma.RoleAssociationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleAssociationPayload>;
				};
				aggregate: {
					args: Prisma.RoleAssociationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateRoleAssociation>;
				};
				groupBy: {
					args: Prisma.RoleAssociationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.RoleAssociationGroupByOutputType>[];
				};
				count: {
					args: Prisma.RoleAssociationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.RoleAssociationCountAggregateOutputType>
						| number;
				};
			};
		};
		RoleClassification: {
			payload: Prisma.$RoleClassificationPayload<ExtArgs>;
			fields: Prisma.RoleClassificationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.RoleClassificationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.RoleClassificationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>;
				};
				findFirst: {
					args: Prisma.RoleClassificationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.RoleClassificationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>;
				};
				findMany: {
					args: Prisma.RoleClassificationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>[];
				};
				create: {
					args: Prisma.RoleClassificationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>;
				};
				createMany: {
					args: Prisma.RoleClassificationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.RoleClassificationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>[];
				};
				delete: {
					args: Prisma.RoleClassificationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>;
				};
				update: {
					args: Prisma.RoleClassificationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>;
				};
				deleteMany: {
					args: Prisma.RoleClassificationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.RoleClassificationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.RoleClassificationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>[];
				};
				upsert: {
					args: Prisma.RoleClassificationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleClassificationPayload>;
				};
				aggregate: {
					args: Prisma.RoleClassificationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateRoleClassification>;
				};
				groupBy: {
					args: Prisma.RoleClassificationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.RoleClassificationGroupByOutputType>[];
				};
				count: {
					args: Prisma.RoleClassificationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.RoleClassificationCountAggregateOutputType>
						| number;
				};
			};
		};
		SafeWallet: {
			payload: Prisma.$SafeWalletPayload<ExtArgs>;
			fields: Prisma.SafeWalletFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SafeWalletFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SafeWalletFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>;
				};
				findFirst: {
					args: Prisma.SafeWalletFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SafeWalletFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>;
				};
				findMany: {
					args: Prisma.SafeWalletFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>[];
				};
				create: {
					args: Prisma.SafeWalletCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>;
				};
				createMany: {
					args: Prisma.SafeWalletCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SafeWalletCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>[];
				};
				delete: {
					args: Prisma.SafeWalletDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>;
				};
				update: {
					args: Prisma.SafeWalletUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>;
				};
				deleteMany: {
					args: Prisma.SafeWalletDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SafeWalletUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SafeWalletUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>[];
				};
				upsert: {
					args: Prisma.SafeWalletUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeWalletPayload>;
				};
				aggregate: {
					args: Prisma.SafeWalletAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSafeWallet>;
				};
				groupBy: {
					args: Prisma.SafeWalletGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SafeWalletGroupByOutputType>[];
				};
				count: {
					args: Prisma.SafeWalletCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SafeWalletCountAggregateOutputType>
						| number;
				};
			};
		};
		SafeTransaction: {
			payload: Prisma.$SafeTransactionPayload<ExtArgs>;
			fields: Prisma.SafeTransactionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SafeTransactionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SafeTransactionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>;
				};
				findFirst: {
					args: Prisma.SafeTransactionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SafeTransactionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>;
				};
				findMany: {
					args: Prisma.SafeTransactionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>[];
				};
				create: {
					args: Prisma.SafeTransactionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>;
				};
				createMany: {
					args: Prisma.SafeTransactionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SafeTransactionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>[];
				};
				delete: {
					args: Prisma.SafeTransactionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>;
				};
				update: {
					args: Prisma.SafeTransactionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>;
				};
				deleteMany: {
					args: Prisma.SafeTransactionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SafeTransactionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SafeTransactionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>[];
				};
				upsert: {
					args: Prisma.SafeTransactionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeTransactionPayload>;
				};
				aggregate: {
					args: Prisma.SafeTransactionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSafeTransaction>;
				};
				groupBy: {
					args: Prisma.SafeTransactionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SafeTransactionGroupByOutputType>[];
				};
				count: {
					args: Prisma.SafeTransactionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SafeTransactionCountAggregateOutputType>
						| number;
				};
			};
		};
		SafeConfirmation: {
			payload: Prisma.$SafeConfirmationPayload<ExtArgs>;
			fields: Prisma.SafeConfirmationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SafeConfirmationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SafeConfirmationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>;
				};
				findFirst: {
					args: Prisma.SafeConfirmationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SafeConfirmationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>;
				};
				findMany: {
					args: Prisma.SafeConfirmationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>[];
				};
				create: {
					args: Prisma.SafeConfirmationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>;
				};
				createMany: {
					args: Prisma.SafeConfirmationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SafeConfirmationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>[];
				};
				delete: {
					args: Prisma.SafeConfirmationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>;
				};
				update: {
					args: Prisma.SafeConfirmationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>;
				};
				deleteMany: {
					args: Prisma.SafeConfirmationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SafeConfirmationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SafeConfirmationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>[];
				};
				upsert: {
					args: Prisma.SafeConfirmationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SafeConfirmationPayload>;
				};
				aggregate: {
					args: Prisma.SafeConfirmationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSafeConfirmation>;
				};
				groupBy: {
					args: Prisma.SafeConfirmationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SafeConfirmationGroupByOutputType>[];
				};
				count: {
					args: Prisma.SafeConfirmationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SafeConfirmationCountAggregateOutputType>
						| number;
				};
			};
		};
		Space: {
			payload: Prisma.$SpacePayload<ExtArgs>;
			fields: Prisma.SpaceFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SpaceFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SpaceFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>;
				};
				findFirst: {
					args: Prisma.SpaceFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SpaceFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>;
				};
				findMany: {
					args: Prisma.SpaceFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>[];
				};
				create: {
					args: Prisma.SpaceCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>;
				};
				createMany: {
					args: Prisma.SpaceCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SpaceCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>[];
				};
				delete: {
					args: Prisma.SpaceDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>;
				};
				update: {
					args: Prisma.SpaceUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>;
				};
				deleteMany: {
					args: Prisma.SpaceDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SpaceUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SpaceUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>[];
				};
				upsert: {
					args: Prisma.SpaceUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpacePayload>;
				};
				aggregate: {
					args: Prisma.SpaceAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSpace>;
				};
				groupBy: {
					args: Prisma.SpaceGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SpaceGroupByOutputType>[];
				};
				count: {
					args: Prisma.SpaceCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SpaceCountAggregateOutputType>
						| number;
				};
			};
		};
		SpaceClassification: {
			payload: Prisma.$SpaceClassificationPayload<ExtArgs>;
			fields: Prisma.SpaceClassificationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SpaceClassificationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SpaceClassificationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>;
				};
				findFirst: {
					args: Prisma.SpaceClassificationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SpaceClassificationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>;
				};
				findMany: {
					args: Prisma.SpaceClassificationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>[];
				};
				create: {
					args: Prisma.SpaceClassificationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>;
				};
				createMany: {
					args: Prisma.SpaceClassificationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SpaceClassificationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>[];
				};
				delete: {
					args: Prisma.SpaceClassificationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>;
				};
				update: {
					args: Prisma.SpaceClassificationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>;
				};
				deleteMany: {
					args: Prisma.SpaceClassificationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SpaceClassificationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SpaceClassificationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>[];
				};
				upsert: {
					args: Prisma.SpaceClassificationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceClassificationPayload>;
				};
				aggregate: {
					args: Prisma.SpaceClassificationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSpaceClassification>;
				};
				groupBy: {
					args: Prisma.SpaceClassificationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SpaceClassificationGroupByOutputType>[];
				};
				count: {
					args: Prisma.SpaceClassificationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SpaceClassificationCountAggregateOutputType>
						| number;
				};
			};
		};
		SpaceAssociation: {
			payload: Prisma.$SpaceAssociationPayload<ExtArgs>;
			fields: Prisma.SpaceAssociationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SpaceAssociationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SpaceAssociationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>;
				};
				findFirst: {
					args: Prisma.SpaceAssociationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SpaceAssociationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>;
				};
				findMany: {
					args: Prisma.SpaceAssociationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>[];
				};
				create: {
					args: Prisma.SpaceAssociationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>;
				};
				createMany: {
					args: Prisma.SpaceAssociationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SpaceAssociationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>[];
				};
				delete: {
					args: Prisma.SpaceAssociationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>;
				};
				update: {
					args: Prisma.SpaceAssociationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>;
				};
				deleteMany: {
					args: Prisma.SpaceAssociationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SpaceAssociationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SpaceAssociationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>[];
				};
				upsert: {
					args: Prisma.SpaceAssociationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SpaceAssociationPayload>;
				};
				aggregate: {
					args: Prisma.SpaceAssociationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSpaceAssociation>;
				};
				groupBy: {
					args: Prisma.SpaceAssociationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SpaceAssociationGroupByOutputType>[];
				};
				count: {
					args: Prisma.SpaceAssociationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SpaceAssociationCountAggregateOutputType>
						| number;
				};
			};
		};
		Ground: {
			payload: Prisma.$GroundPayload<ExtArgs>;
			fields: Prisma.GroundFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.GroundFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.GroundFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>;
				};
				findFirst: {
					args: Prisma.GroundFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.GroundFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>;
				};
				findMany: {
					args: Prisma.GroundFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>[];
				};
				create: {
					args: Prisma.GroundCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>;
				};
				createMany: {
					args: Prisma.GroundCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.GroundCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>[];
				};
				delete: {
					args: Prisma.GroundDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>;
				};
				update: {
					args: Prisma.GroundUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>;
				};
				deleteMany: {
					args: Prisma.GroundDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.GroundUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.GroundUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>[];
				};
				upsert: {
					args: Prisma.GroundUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$GroundPayload>;
				};
				aggregate: {
					args: Prisma.GroundAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateGround>;
				};
				groupBy: {
					args: Prisma.GroundGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.GroundGroupByOutputType>[];
				};
				count: {
					args: Prisma.GroundCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.GroundCountAggregateOutputType>
						| number;
				};
			};
		};
		Timeline: {
			payload: Prisma.$TimelinePayload<ExtArgs>;
			fields: Prisma.TimelineFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.TimelineFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.TimelineFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>;
				};
				findFirst: {
					args: Prisma.TimelineFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.TimelineFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>;
				};
				findMany: {
					args: Prisma.TimelineFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>[];
				};
				create: {
					args: Prisma.TimelineCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>;
				};
				createMany: {
					args: Prisma.TimelineCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.TimelineCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>[];
				};
				delete: {
					args: Prisma.TimelineDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>;
				};
				update: {
					args: Prisma.TimelineUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>;
				};
				deleteMany: {
					args: Prisma.TimelineDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.TimelineUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.TimelineUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>[];
				};
				upsert: {
					args: Prisma.TimelineUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TimelinePayload>;
				};
				aggregate: {
					args: Prisma.TimelineAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateTimeline>;
				};
				groupBy: {
					args: Prisma.TimelineGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.TimelineGroupByOutputType>[];
				};
				count: {
					args: Prisma.TimelineCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.TimelineCountAggregateOutputType>
						| number;
				};
			};
		};
		Session: {
			payload: Prisma.$SessionPayload<ExtArgs>;
			fields: Prisma.SessionFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.SessionFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				findFirst: {
					args: Prisma.SessionFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				findMany: {
					args: Prisma.SessionFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
				};
				create: {
					args: Prisma.SessionCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				createMany: {
					args: Prisma.SessionCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
				};
				delete: {
					args: Prisma.SessionDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				update: {
					args: Prisma.SessionUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				deleteMany: {
					args: Prisma.SessionDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.SessionUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[];
				};
				upsert: {
					args: Prisma.SessionUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>;
				};
				aggregate: {
					args: Prisma.SessionAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateSession>;
				};
				groupBy: {
					args: Prisma.SessionGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[];
				};
				count: {
					args: Prisma.SessionCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType>
						| number;
				};
			};
		};
		Program: {
			payload: Prisma.$ProgramPayload<ExtArgs>;
			fields: Prisma.ProgramFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ProgramFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
				};
				findFirst: {
					args: Prisma.ProgramFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
				};
				findMany: {
					args: Prisma.ProgramFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[];
				};
				create: {
					args: Prisma.ProgramCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
				};
				createMany: {
					args: Prisma.ProgramCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[];
				};
				delete: {
					args: Prisma.ProgramDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
				};
				update: {
					args: Prisma.ProgramUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
				};
				deleteMany: {
					args: Prisma.ProgramDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ProgramUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ProgramUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>[];
				};
				upsert: {
					args: Prisma.ProgramUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgramPayload>;
				};
				aggregate: {
					args: Prisma.ProgramAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateProgram>;
				};
				groupBy: {
					args: Prisma.ProgramGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ProgramGroupByOutputType>[];
				};
				count: {
					args: Prisma.ProgramCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ProgramCountAggregateOutputType>
						| number;
				};
			};
		};
		Routine: {
			payload: Prisma.$RoutinePayload<ExtArgs>;
			fields: Prisma.RoutineFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.RoutineFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.RoutineFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>;
				};
				findFirst: {
					args: Prisma.RoutineFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.RoutineFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>;
				};
				findMany: {
					args: Prisma.RoutineFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>[];
				};
				create: {
					args: Prisma.RoutineCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>;
				};
				createMany: {
					args: Prisma.RoutineCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.RoutineCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>[];
				};
				delete: {
					args: Prisma.RoutineDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>;
				};
				update: {
					args: Prisma.RoutineUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>;
				};
				deleteMany: {
					args: Prisma.RoutineDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.RoutineUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.RoutineUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>[];
				};
				upsert: {
					args: Prisma.RoutineUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$RoutinePayload>;
				};
				aggregate: {
					args: Prisma.RoutineAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateRoutine>;
				};
				groupBy: {
					args: Prisma.RoutineGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.RoutineGroupByOutputType>[];
				};
				count: {
					args: Prisma.RoutineCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.RoutineCountAggregateOutputType>
						| number;
				};
			};
		};
		Activity: {
			payload: Prisma.$ActivityPayload<ExtArgs>;
			fields: Prisma.ActivityFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ActivityFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ActivityFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>;
				};
				findFirst: {
					args: Prisma.ActivityFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ActivityFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>;
				};
				findMany: {
					args: Prisma.ActivityFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[];
				};
				create: {
					args: Prisma.ActivityCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>;
				};
				createMany: {
					args: Prisma.ActivityCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ActivityCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[];
				};
				delete: {
					args: Prisma.ActivityDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>;
				};
				update: {
					args: Prisma.ActivityUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>;
				};
				deleteMany: {
					args: Prisma.ActivityDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ActivityUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ActivityUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>[];
				};
				upsert: {
					args: Prisma.ActivityUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityPayload>;
				};
				aggregate: {
					args: Prisma.ActivityAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateActivity>;
				};
				groupBy: {
					args: Prisma.ActivityGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ActivityGroupByOutputType>[];
				};
				count: {
					args: Prisma.ActivityCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ActivityCountAggregateOutputType>
						| number;
				};
			};
		};
		Task: {
			payload: Prisma.$TaskPayload<ExtArgs>;
			fields: Prisma.TaskFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.TaskFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>;
				};
				findFirst: {
					args: Prisma.TaskFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>;
				};
				findMany: {
					args: Prisma.TaskFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[];
				};
				create: {
					args: Prisma.TaskCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>;
				};
				createMany: {
					args: Prisma.TaskCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[];
				};
				delete: {
					args: Prisma.TaskDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>;
				};
				update: {
					args: Prisma.TaskUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>;
				};
				deleteMany: {
					args: Prisma.TaskDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.TaskUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>[];
				};
				upsert: {
					args: Prisma.TaskUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$TaskPayload>;
				};
				aggregate: {
					args: Prisma.TaskAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateTask>;
				};
				groupBy: {
					args: Prisma.TaskGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.TaskGroupByOutputType>[];
				};
				count: {
					args: Prisma.TaskCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.TaskCountAggregateOutputType>
						| number;
				};
			};
		};
		Exercise: {
			payload: Prisma.$ExercisePayload<ExtArgs>;
			fields: Prisma.ExerciseFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ExerciseFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ExerciseFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>;
				};
				findFirst: {
					args: Prisma.ExerciseFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ExerciseFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>;
				};
				findMany: {
					args: Prisma.ExerciseFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>[];
				};
				create: {
					args: Prisma.ExerciseCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>;
				};
				createMany: {
					args: Prisma.ExerciseCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ExerciseCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>[];
				};
				delete: {
					args: Prisma.ExerciseDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>;
				};
				update: {
					args: Prisma.ExerciseUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>;
				};
				deleteMany: {
					args: Prisma.ExerciseDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ExerciseUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ExerciseUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>[];
				};
				upsert: {
					args: Prisma.ExerciseUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ExercisePayload>;
				};
				aggregate: {
					args: Prisma.ExerciseAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateExercise>;
				};
				groupBy: {
					args: Prisma.ExerciseGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ExerciseGroupByOutputType>[];
				};
				count: {
					args: Prisma.ExerciseCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ExerciseCountAggregateOutputType>
						| number;
				};
			};
		};
		User: {
			payload: Prisma.$UserPayload<ExtArgs>;
			fields: Prisma.UserFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				findFirst: {
					args: Prisma.UserFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				findMany: {
					args: Prisma.UserFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
				};
				create: {
					args: Prisma.UserCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				createMany: {
					args: Prisma.UserCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
				};
				delete: {
					args: Prisma.UserDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				update: {
					args: Prisma.UserUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				deleteMany: {
					args: Prisma.UserDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[];
				};
				upsert: {
					args: Prisma.UserUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>;
				};
				aggregate: {
					args: Prisma.UserAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUser>;
				};
				groupBy: {
					args: Prisma.UserGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType>
						| number;
				};
			};
		};
		UserClassification: {
			payload: Prisma.$UserClassificationPayload<ExtArgs>;
			fields: Prisma.UserClassificationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserClassificationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserClassificationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>;
				};
				findFirst: {
					args: Prisma.UserClassificationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserClassificationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>;
				};
				findMany: {
					args: Prisma.UserClassificationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>[];
				};
				create: {
					args: Prisma.UserClassificationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>;
				};
				createMany: {
					args: Prisma.UserClassificationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserClassificationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>[];
				};
				delete: {
					args: Prisma.UserClassificationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>;
				};
				update: {
					args: Prisma.UserClassificationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>;
				};
				deleteMany: {
					args: Prisma.UserClassificationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserClassificationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserClassificationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>[];
				};
				upsert: {
					args: Prisma.UserClassificationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserClassificationPayload>;
				};
				aggregate: {
					args: Prisma.UserClassificationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserClassification>;
				};
				groupBy: {
					args: Prisma.UserClassificationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserClassificationGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserClassificationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserClassificationCountAggregateOutputType>
						| number;
				};
			};
		};
		UserAssociation: {
			payload: Prisma.$UserAssociationPayload<ExtArgs>;
			fields: Prisma.UserAssociationFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.UserAssociationFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.UserAssociationFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>;
				};
				findFirst: {
					args: Prisma.UserAssociationFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.UserAssociationFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>;
				};
				findMany: {
					args: Prisma.UserAssociationFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>[];
				};
				create: {
					args: Prisma.UserAssociationCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>;
				};
				createMany: {
					args: Prisma.UserAssociationCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.UserAssociationCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>[];
				};
				delete: {
					args: Prisma.UserAssociationDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>;
				};
				update: {
					args: Prisma.UserAssociationUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>;
				};
				deleteMany: {
					args: Prisma.UserAssociationDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.UserAssociationUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.UserAssociationUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>[];
				};
				upsert: {
					args: Prisma.UserAssociationUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$UserAssociationPayload>;
				};
				aggregate: {
					args: Prisma.UserAssociationAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateUserAssociation>;
				};
				groupBy: {
					args: Prisma.UserAssociationGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.UserAssociationGroupByOutputType>[];
				};
				count: {
					args: Prisma.UserAssociationCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.UserAssociationCountAggregateOutputType>
						| number;
				};
			};
		};
		Profile: {
			payload: Prisma.$ProfilePayload<ExtArgs>;
			fields: Prisma.ProfileFieldRefs;
			operations: {
				findUnique: {
					args: Prisma.ProfileFindUniqueArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null;
				};
				findUniqueOrThrow: {
					args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>;
				};
				findFirst: {
					args: Prisma.ProfileFindFirstArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload> | null;
				};
				findFirstOrThrow: {
					args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>;
				};
				findMany: {
					args: Prisma.ProfileFindManyArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[];
				};
				create: {
					args: Prisma.ProfileCreateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>;
				};
				createMany: {
					args: Prisma.ProfileCreateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				createManyAndReturn: {
					args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[];
				};
				delete: {
					args: Prisma.ProfileDeleteArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>;
				};
				update: {
					args: Prisma.ProfileUpdateArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>;
				};
				deleteMany: {
					args: Prisma.ProfileDeleteManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateMany: {
					args: Prisma.ProfileUpdateManyArgs<ExtArgs>;
					result: BatchPayload;
				};
				updateManyAndReturn: {
					args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>[];
				};
				upsert: {
					args: Prisma.ProfileUpsertArgs<ExtArgs>;
					result: runtime.Types.Utils.PayloadToResult<Prisma.$ProfilePayload>;
				};
				aggregate: {
					args: Prisma.ProfileAggregateArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.AggregateProfile>;
				};
				groupBy: {
					args: Prisma.ProfileGroupByArgs<ExtArgs>;
					result: runtime.Types.Utils.Optional<Prisma.ProfileGroupByOutputType>[];
				};
				count: {
					args: Prisma.ProfileCountArgs<ExtArgs>;
					result:
						| runtime.Types.Utils.Optional<Prisma.ProfileCountAggregateOutputType>
						| number;
				};
			};
		};
	};
} & {
	other: {
		payload: any;
		operations: {
			$executeRaw: {
				args: [query: TemplateStringsArray | Sql, ...values: any[]];
				result: any;
			};
			$executeRawUnsafe: {
				args: [query: string, ...values: any[]];
				result: any;
			};
			$queryRaw: {
				args: [query: TemplateStringsArray | Sql, ...values: any[]];
				result: any;
			};
			$queryRawUnsafe: {
				args: [query: string, ...values: any[]];
				result: any;
			};
		};
	};
};

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
	ReadUncommitted: "ReadUncommitted",
	ReadCommitted: "ReadCommitted",
	RepeatableRead: "RepeatableRead",
	Serializable: "Serializable",
} as const);

export type TransactionIsolationLevel =
	(typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

export const CategoryScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	type: "type",
	parentId: "parentId",
	tenantId: "tenantId",
} as const;

export type CategoryScalarFieldEnum =
	(typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum];

export const GroupScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	type: "type",
	label: "label",
	tenantId: "tenantId",
} as const;

export type GroupScalarFieldEnum =
	(typeof GroupScalarFieldEnum)[keyof typeof GroupScalarFieldEnum];

export const TenantScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	userId: "userId",
	spaceId: "spaceId",
	roleId: "roleId",
	main: "main",
} as const;

export type TenantScalarFieldEnum =
	(typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum];

export const AssignmentScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	roleId: "roleId",
	tenantId: "tenantId",
} as const;

export type AssignmentScalarFieldEnum =
	(typeof AssignmentScalarFieldEnum)[keyof typeof AssignmentScalarFieldEnum];

export const ActionScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	conditions: "conditions",
	tenantId: "tenantId",
} as const;

export type ActionScalarFieldEnum =
	(typeof ActionScalarFieldEnum)[keyof typeof ActionScalarFieldEnum];

export const SubjectScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	tenantId: "tenantId",
} as const;

export type SubjectScalarFieldEnum =
	(typeof SubjectScalarFieldEnum)[keyof typeof SubjectScalarFieldEnum];

export const AbilityScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	type: "type",
	roleId: "roleId",
	description: "description",
	conditions: "conditions",
	subjectId: "subjectId",
	tenantId: "tenantId",
} as const;

export type AbilityScalarFieldEnum =
	(typeof AbilityScalarFieldEnum)[keyof typeof AbilityScalarFieldEnum];

export const PostScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	contentId: "contentId",
} as const;

export type PostScalarFieldEnum =
	(typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum];

export const ContentScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	title: "title",
	description: "description",
	type: "type",
	text: "text",
	fileId: "fileId",
	tenantId: "tenantId",
} as const;

export type ContentScalarFieldEnum =
	(typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum];

export const FileScalarFieldEnum = {
	id: "id",
	seq: "seq",
	name: "name",
	size: "size",
	parentId: "parentId",
	mimeType: "mimeType",
	url: "url",
	tenantId: "tenantId",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
} as const;

export type FileScalarFieldEnum =
	(typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum];

export const FileClassificationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	categoryId: "categoryId",
	fileId: "fileId",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
} as const;

export type FileClassificationScalarFieldEnum =
	(typeof FileClassificationScalarFieldEnum)[keyof typeof FileClassificationScalarFieldEnum];

export const FileAssociationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	fileId: "fileId",
	groupId: "groupId",
} as const;

export type FileAssociationScalarFieldEnum =
	(typeof FileAssociationScalarFieldEnum)[keyof typeof FileAssociationScalarFieldEnum];

export const RoleScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
} as const;

export type RoleScalarFieldEnum =
	(typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum];

export const RoleAssociationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	roleId: "roleId",
	groupId: "groupId",
} as const;

export type RoleAssociationScalarFieldEnum =
	(typeof RoleAssociationScalarFieldEnum)[keyof typeof RoleAssociationScalarFieldEnum];

export const RoleClassificationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	categoryId: "categoryId",
	roleId: "roleId",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
} as const;

export type RoleClassificationScalarFieldEnum =
	(typeof RoleClassificationScalarFieldEnum)[keyof typeof RoleClassificationScalarFieldEnum];

export const SafeWalletScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	address: "address",
	chainId: "chainId",
	threshold: "threshold",
	nonce: "nonce",
	owners: "owners",
	tenantId: "tenantId",
} as const;

export type SafeWalletScalarFieldEnum =
	(typeof SafeWalletScalarFieldEnum)[keyof typeof SafeWalletScalarFieldEnum];

export const SafeTransactionScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	safeTxHash: "safeTxHash",
	safeWalletId: "safeWalletId",
	to: "to",
	value: "value",
	data: "data",
	nonce: "nonce",
	operation: "operation",
	tokenAddress: "tokenAddress",
	tokenSymbol: "tokenSymbol",
	tokenDecimals: "tokenDecimals",
	confirmationsRequired: "confirmationsRequired",
	isExecuted: "isExecuted",
	executionTxHash: "executionTxHash",
	executedAt: "executedAt",
} as const;

export type SafeTransactionScalarFieldEnum =
	(typeof SafeTransactionScalarFieldEnum)[keyof typeof SafeTransactionScalarFieldEnum];

export const SafeConfirmationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	safeTransactionId: "safeTransactionId",
	owner: "owner",
	signature: "signature",
} as const;

export type SafeConfirmationScalarFieldEnum =
	(typeof SafeConfirmationScalarFieldEnum)[keyof typeof SafeConfirmationScalarFieldEnum];

export const SpaceScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
} as const;

export type SpaceScalarFieldEnum =
	(typeof SpaceScalarFieldEnum)[keyof typeof SpaceScalarFieldEnum];

export const SpaceClassificationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	categoryId: "categoryId",
	spaceId: "spaceId",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
} as const;

export type SpaceClassificationScalarFieldEnum =
	(typeof SpaceClassificationScalarFieldEnum)[keyof typeof SpaceClassificationScalarFieldEnum];

export const SpaceAssociationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	spaceId: "spaceId",
	groupId: "groupId",
} as const;

export type SpaceAssociationScalarFieldEnum =
	(typeof SpaceAssociationScalarFieldEnum)[keyof typeof SpaceAssociationScalarFieldEnum];

export const GroundScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	label: "label",
	address: "address",
	phone: "phone",
	email: "email",
	businessNo: "businessNo",
	spaceId: "spaceId",
	logoImageFileId: "logoImageFileId",
	imageFileId: "imageFileId",
} as const;

export type GroundScalarFieldEnum =
	(typeof GroundScalarFieldEnum)[keyof typeof GroundScalarFieldEnum];

export const TimelineScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	tenantId: "tenantId",
	name: "name",
	description: "description",
} as const;

export type TimelineScalarFieldEnum =
	(typeof TimelineScalarFieldEnum)[keyof typeof TimelineScalarFieldEnum];

export const SessionScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	type: "type",
	repeatCycleType: "repeatCycleType",
	startDateTime: "startDateTime",
	endDateTime: "endDateTime",
	recurringDayOfWeek: "recurringDayOfWeek",
	timelineId: "timelineId",
	name: "name",
	description: "description",
} as const;

export type SessionScalarFieldEnum =
	(typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum];

export const ProgramScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	routineId: "routineId",
	sessionId: "sessionId",
	instructorId: "instructorId",
	capacity: "capacity",
	name: "name",
	level: "level",
} as const;

export type ProgramScalarFieldEnum =
	(typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum];

export const RoutineScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	label: "label",
} as const;

export type RoutineScalarFieldEnum =
	(typeof RoutineScalarFieldEnum)[keyof typeof RoutineScalarFieldEnum];

export const ActivityScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	routineId: "routineId",
	taskId: "taskId",
	order: "order",
	repetitions: "repetitions",
	restTime: "restTime",
	notes: "notes",
} as const;

export type ActivityScalarFieldEnum =
	(typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum];

export const TaskScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	tenantId: "tenantId",
} as const;

export type TaskScalarFieldEnum =
	(typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum];

export const ExerciseScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	duration: "duration",
	count: "count",
	taskId: "taskId",
	description: "description",
	imageFileId: "imageFileId",
	videoFileId: "videoFileId",
	name: "name",
} as const;

export type ExerciseScalarFieldEnum =
	(typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum];

export const UserScalarFieldEnum = {
	id: "id",
	seq: "seq",
	updatedAt: "updatedAt",
	createdAt: "createdAt",
	removedAt: "removedAt",
	phone: "phone",
	name: "name",
	email: "email",
	password: "password",
} as const;

export type UserScalarFieldEnum =
	(typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

export const UserClassificationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	categoryId: "categoryId",
	userId: "userId",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
} as const;

export type UserClassificationScalarFieldEnum =
	(typeof UserClassificationScalarFieldEnum)[keyof typeof UserClassificationScalarFieldEnum];

export const UserAssociationScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	userId: "userId",
	groupId: "groupId",
} as const;

export type UserAssociationScalarFieldEnum =
	(typeof UserAssociationScalarFieldEnum)[keyof typeof UserAssociationScalarFieldEnum];

export const ProfileScalarFieldEnum = {
	id: "id",
	seq: "seq",
	createdAt: "createdAt",
	updatedAt: "updatedAt",
	removedAt: "removedAt",
	name: "name",
	nickname: "nickname",
	userId: "userId",
	avatarFileId: "avatarFileId",
} as const;

export type ProfileScalarFieldEnum =
	(typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum];

export const SortOrder = {
	asc: "asc",
	desc: "desc",
} as const;

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

export const NullableJsonNullValueInput = {
	DbNull: DbNull,
	JsonNull: JsonNull,
} as const;

export type NullableJsonNullValueInput =
	(typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput];

export const QueryMode = {
	default: "default",
	insensitive: "insensitive",
} as const;

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

export const NullsOrder = {
	first: "first",
	last: "last",
} as const;

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

export const JsonNullValueFilter = {
	DbNull: DbNull,
	JsonNull: JsonNull,
	AnyNull: AnyNull,
} as const;

export type JsonNullValueFilter =
	(typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter];

/**
 * Field references
 */

/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"String"
>;

/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"String[]"
>;

/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Int"
>;

/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Int[]"
>;

/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"DateTime"
>;

/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"DateTime[]"
>;

/**
 * Reference to a field of type 'CategoryTypes'
 */
export type EnumCategoryTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"CategoryTypes"
>;

/**
 * Reference to a field of type 'CategoryTypes[]'
 */
export type ListEnumCategoryTypesFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "CategoryTypes[]">;

/**
 * Reference to a field of type 'GroupTypes'
 */
export type EnumGroupTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"GroupTypes"
>;

/**
 * Reference to a field of type 'GroupTypes[]'
 */
export type ListEnumGroupTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"GroupTypes[]"
>;

/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Boolean"
>;

/**
 * Reference to a field of type 'AbilityActions'
 */
export type EnumAbilityActionsFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"AbilityActions"
>;

/**
 * Reference to a field of type 'AbilityActions[]'
 */
export type ListEnumAbilityActionsFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "AbilityActions[]">;

/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Json"
>;

/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"QueryMode"
>;

/**
 * Reference to a field of type 'AbilityTypes'
 */
export type EnumAbilityTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"AbilityTypes"
>;

/**
 * Reference to a field of type 'AbilityTypes[]'
 */
export type ListEnumAbilityTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"AbilityTypes[]"
>;

/**
 * Reference to a field of type 'TextTypes'
 */
export type EnumTextTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"TextTypes"
>;

/**
 * Reference to a field of type 'TextTypes[]'
 */
export type ListEnumTextTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"TextTypes[]"
>;

/**
 * Reference to a field of type 'Roles'
 */
export type EnumRolesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Roles"
>;

/**
 * Reference to a field of type 'Roles[]'
 */
export type ListEnumRolesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Roles[]"
>;

/**
 * Reference to a field of type 'SessionTypes'
 */
export type EnumSessionTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"SessionTypes"
>;

/**
 * Reference to a field of type 'SessionTypes[]'
 */
export type ListEnumSessionTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"SessionTypes[]"
>;

/**
 * Reference to a field of type 'RepeatCycleTypes'
 */
export type EnumRepeatCycleTypesFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"RepeatCycleTypes"
>;

/**
 * Reference to a field of type 'RepeatCycleTypes[]'
 */
export type ListEnumRepeatCycleTypesFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "RepeatCycleTypes[]">;

/**
 * Reference to a field of type 'RecurringDayOfWeek'
 */
export type EnumRecurringDayOfWeekFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "RecurringDayOfWeek">;

/**
 * Reference to a field of type 'RecurringDayOfWeek[]'
 */
export type ListEnumRecurringDayOfWeekFieldRefInput<$PrismaModel> =
	FieldRefInputType<$PrismaModel, "RecurringDayOfWeek[]">;

/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Float"
>;

/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
	$PrismaModel,
	"Float[]"
>;

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
	count: number;
};

export const defineExtension = runtime.Extensions
	.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<
	"define",
	TypeMapCb,
	runtime.Types.Extensions.DefaultArgs
>;
export type DefaultPrismaClient = PrismaClient;
export type ErrorFormat = "pretty" | "colorless" | "minimal";
export type PrismaClientOptions = (
	| {
			/**
			 * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
			 */
			adapter: runtime.SqlDriverAdapterFactory;
			accelerateUrl?: never;
	  }
	| {
			/**
			 * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
			 */
			accelerateUrl: string;
			adapter?: never;
	  }
) & {
	/**
	 * @default "colorless"
	 */
	errorFormat?: ErrorFormat;
	/**
	 * @example
	 * ```
	 * // Shorthand for `emit: 'stdout'`
	 * log: ['query', 'info', 'warn', 'error']
	 *
	 * // Emit as events only
	 * log: [
	 *   { emit: 'event', level: 'query' },
	 *   { emit: 'event', level: 'info' },
	 *   { emit: 'event', level: 'warn' }
	 *   { emit: 'event', level: 'error' }
	 * ]
	 *
	 * / Emit as events and log to stdout
	 * og: [
	 *  { emit: 'stdout', level: 'query' },
	 *  { emit: 'stdout', level: 'info' },
	 *  { emit: 'stdout', level: 'warn' }
	 *  { emit: 'stdout', level: 'error' }
	 *
	 * ```
	 * Read more in our [docs](https://pris.ly/d/logging).
	 */
	log?: (LogLevel | LogDefinition)[];
	/**
	 * The default values for transactionOptions
	 * maxWait ?= 2000
	 * timeout ?= 5000
	 */
	transactionOptions?: {
		maxWait?: number;
		timeout?: number;
		isolationLevel?: TransactionIsolationLevel;
	};
	/**
	 * Global configuration for omitting model fields by default.
	 *
	 * @example
	 * ```
	 * const prisma = new PrismaClient({
	 *   omit: {
	 *     user: {
	 *       password: true
	 *     }
	 *   }
	 * })
	 * ```
	 */
	omit?: GlobalOmitConfig;
	/**
	 * SQL commenter plugins that add metadata to SQL queries as comments.
	 * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
	 *
	 * @example
	 * ```
	 * const prisma = new PrismaClient({
	 *   adapter,
	 *   comments: [
	 *     traceContext(),
	 *     queryInsights(),
	 *   ],
	 * })
	 * ```
	 */
	comments?: runtime.SqlCommenterPlugin[];
};
export type GlobalOmitConfig = {
	category?: Prisma.CategoryOmit;
	group?: Prisma.GroupOmit;
	tenant?: Prisma.TenantOmit;
	assignment?: Prisma.AssignmentOmit;
	action?: Prisma.ActionOmit;
	subject?: Prisma.SubjectOmit;
	ability?: Prisma.AbilityOmit;
	post?: Prisma.PostOmit;
	content?: Prisma.ContentOmit;
	file?: Prisma.FileOmit;
	fileClassification?: Prisma.FileClassificationOmit;
	fileAssociation?: Prisma.FileAssociationOmit;
	role?: Prisma.RoleOmit;
	roleAssociation?: Prisma.RoleAssociationOmit;
	roleClassification?: Prisma.RoleClassificationOmit;
	safeWallet?: Prisma.SafeWalletOmit;
	safeTransaction?: Prisma.SafeTransactionOmit;
	safeConfirmation?: Prisma.SafeConfirmationOmit;
	space?: Prisma.SpaceOmit;
	spaceClassification?: Prisma.SpaceClassificationOmit;
	spaceAssociation?: Prisma.SpaceAssociationOmit;
	ground?: Prisma.GroundOmit;
	timeline?: Prisma.TimelineOmit;
	session?: Prisma.SessionOmit;
	program?: Prisma.ProgramOmit;
	routine?: Prisma.RoutineOmit;
	activity?: Prisma.ActivityOmit;
	task?: Prisma.TaskOmit;
	exercise?: Prisma.ExerciseOmit;
	user?: Prisma.UserOmit;
	userClassification?: Prisma.UserClassificationOmit;
	userAssociation?: Prisma.UserAssociationOmit;
	profile?: Prisma.ProfileOmit;
};

/* Types for Logging */
export type LogLevel = "info" | "query" | "warn" | "error";
export type LogDefinition = {
	level: LogLevel;
	emit: "stdout" | "event";
};

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
	T extends LogDefinition ? T["level"] : T
>;

export type GetEvents<T extends any[]> = T extends Array<
	LogLevel | LogDefinition
>
	? GetLogType<T[number]>
	: never;

export type QueryEvent = {
	timestamp: Date;
	query: string;
	params: string;
	duration: number;
	target: string;
};

export type LogEvent = {
	timestamp: Date;
	message: string;
	target: string;
};
/* End Types for Logging */

export type PrismaAction =
	| "findUnique"
	| "findUniqueOrThrow"
	| "findMany"
	| "findFirst"
	| "findFirstOrThrow"
	| "create"
	| "createMany"
	| "createManyAndReturn"
	| "update"
	| "updateMany"
	| "updateManyAndReturn"
	| "upsert"
	| "delete"
	| "deleteMany"
	| "executeRaw"
	| "queryRaw"
	| "aggregate"
	| "count"
	| "runCommandRaw"
	| "findRaw"
	| "groupBy";

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<
	DefaultPrismaClient,
	runtime.ITXClientDenyList
>;
