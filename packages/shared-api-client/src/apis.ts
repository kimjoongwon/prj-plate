/**
 * Generated by orval v7.8.0 üç∫
 * Do not edit manually.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';

import type {
  Create200AllOf,
  CreateAbility200AllOf,
  CreateAbilityDto,
  CreateAction200AllOf,
  CreateActionDto,
  CreateCategory200AllOf,
  CreateCategoryDto,
  CreateDepot201AllOf,
  CreateDepotBody,
  CreateExercise200AllOf,
  CreateExerciseDto,
  CreateFile201AllOf,
  CreateFileClassification200AllOf,
  CreateFileClassificationDto,
  CreateFileDto,
  CreateGround200AllOf,
  CreateGroundDto,
  CreateGroupDto,
  CreateProgram200AllOf,
  CreateProgramDto,
  CreateRole200AllOf,
  CreateRoleClassificationDto,
  CreateRoleDto,
  CreateRoutine200AllOf,
  CreateRoutineDto,
  CreateSession200AllOf,
  CreateSessionDto,
  CreateSpace200AllOf,
  CreateSpaceClassification200AllOf,
  CreateSpaceClassificationDto,
  CreateSpaceDto,
  CreateSubject200AllOf,
  CreateSubjectDto,
  CreateTenant200AllOf,
  CreateTenantDto,
  CreateTimeline200AllOf,
  CreateTimelineDto,
  CreateUser200AllOf,
  CreateUserClassification200AllOf,
  CreateUserClassificationDto,
  CreateUserDto,
  DeleteAbility200AllOf,
  DeleteAction200AllOf,
  DeleteById200AllOf,
  DeleteCategory200AllOf,
  DeleteDepot200AllOf,
  DeleteExercise200AllOf,
  DeleteFileClassification200AllOf,
  DeleteGround200AllOf,
  DeleteGroup200AllOf,
  DeleteProgramById200AllOf,
  DeleteRole200AllOf,
  DeleteRoutine200AllOf,
  DeleteSession200AllOf,
  DeleteSpace200AllOf,
  DeleteSpaceClassification200AllOf,
  DeleteSubject200AllOf,
  DeleteTenant200AllOf,
  DeleteTimeline200AllOf,
  DeleteUser200AllOf,
  DeleteUserClassification200AllOf,
  GetAbilitiesByQuery200AllOf,
  GetAbilitiesByQueryParams,
  GetAbility200AllOf,
  GetAction200AllOf,
  GetActionsByQuery200AllOf,
  GetActionsByQueryParams,
  GetById200AllOf,
  GetCategoriesByQuery200AllOf,
  GetCategoriesByQueryParams,
  GetCategoryById200AllOf,
  GetDepotById200AllOf,
  GetDepotsByQuery200AllOf,
  GetDepotsByQueryParams,
  GetExercise200AllOf,
  GetExercisesByQuery200AllOf,
  GetExercisesByQueryParams,
  GetFileById200AllOf,
  GetFileClassification200AllOf,
  GetFileClassificationsByQuery200AllOf,
  GetFileClassificationsByQueryParams,
  GetGround200AllOf,
  GetGroundsByQuery200AllOf,
  GetGroundsByQueryParams,
  GetGroundsByUserId200AllOf,
  GetGroup200AllOf,
  GetGroupsByQuery200AllOf,
  GetGroupsByQueryParams,
  GetManyByQuery200AllOf,
  GetManyByQueryParams,
  GetProgramById200AllOf,
  GetProgramsByQuery200AllOf,
  GetProgramsByQueryParams,
  GetRole200AllOf,
  GetRolesByQuery200AllOf,
  GetRolesByQueryParams,
  GetRoutine200AllOf,
  GetRoutinesByQuery200AllOf,
  GetRoutinesByQueryParams,
  GetSession200AllOf,
  GetSessionsByQuery200AllOf,
  GetSessionsByQueryParams,
  GetSpace200AllOf,
  GetSpaceClassification200AllOf,
  GetSpaceClassificationsByQuery200AllOf,
  GetSpaceClassificationsByQueryParams,
  GetSpacesByQuery200AllOf,
  GetSpacesByQueryParams,
  GetSubject200AllOf,
  GetSubjectsByQuery200AllOf,
  GetSubjectsByQueryParams,
  GetTenantById200AllOf,
  GetTenantsByQuery200AllOf,
  GetTenantsByQueryParams,
  GetTimeline200AllOf,
  GetTimelinesByQuery200AllOf,
  GetTimelinesByQueryParams,
  GetToken200AllOf,
  GetUser200AllOf,
  GetUserClassification200AllOf,
  GetUserClassificationsByQuery200AllOf,
  GetUserClassificationsByQueryParams,
  GetUsersByQuery200AllOf,
  GetUsersByQueryParams,
  GroupDto,
  LoginPayloadDto,
  RemoveAbilities200AllOf,
  RemoveAbility200AllOf,
  RemoveAction200AllOf,
  RemoveActions200AllOf,
  RemoveById200AllOf,
  RemoveExercise200AllOf,
  RemoveFileById200AllOf,
  RemoveFileClassification200AllOf,
  RemoveGroundById200AllOf,
  RemoveGrounds200AllOf,
  RemoveGroups200AllOf,
  RemoveProgramById200AllOf,
  RemoveRole200AllOf,
  RemoveRoutine200AllOf,
  RemoveSession200AllOf,
  RemoveSessions200AllOf,
  RemoveSpace200AllOf,
  RemoveSpaceClassification200AllOf,
  RemoveSubject200AllOf,
  RemoveSubjects200AllOf,
  RemoveTenantById200AllOf,
  RemoveTimeline200AllOf,
  RemoveTimelines200AllOf,
  RemoveUser200AllOf,
  RemoveUserClassification200AllOf,
  RemoveUsers200AllOf,
  SignUpPayloadDto,
  SignUpUser201AllOf,
  TokenDto,
  UpdateAbility200AllOf,
  UpdateAbilityDto,
  UpdateAction200AllOf,
  UpdateActionDto,
  UpdateById200AllOf,
  UpdateCategory200AllOf,
  UpdateCategoryDto,
  UpdateDepotById200AllOf,
  UpdateDepotByIdBody,
  UpdateExercise200AllOf,
  UpdateExerciseDto,
  UpdateFileById200AllOf,
  UpdateFileByIdBody,
  UpdateFileClassification200AllOf,
  UpdateFileClassificationDto,
  UpdateGround200AllOf,
  UpdateGroundDto,
  UpdateGroup200AllOf,
  UpdateGroupDto,
  UpdateProgramById200AllOf,
  UpdateProgramDto,
  UpdateRole200AllOf,
  UpdateRoleClassificationDto,
  UpdateRoleDto,
  UpdateRoutine200AllOf,
  UpdateRoutineDto,
  UpdateSession200AllOf,
  UpdateSessionDto,
  UpdateSpace200AllOf,
  UpdateSpaceClassification200AllOf,
  UpdateSpaceClassificationDto,
  UpdateSpaceDto,
  UpdateSubject200AllOf,
  UpdateSubjectDto,
  UpdateTenantById200AllOf,
  UpdateTenantDto,
  UpdateTimeline200AllOf,
  UpdateTimelineDto,
  UpdateUser200AllOf,
  UpdateUserClassification200AllOf,
  UpdateUserClassificationDto,
  UpdateUserDto,
  VerifyToken200AllOf,
} from './model';

import { customInstance } from './libs/customAxios';
import type { ErrorType, BodyType } from './libs/customAxios';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const createGround = (
  createGroundDto: BodyType<CreateGroundDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateGround200AllOf>(
    {
      url: `/api/v1/grounds`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createGroundDto,
      signal,
    },
    options,
  );
};

export const getCreateGroundMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGround>>,
    TError,
    { data: BodyType<CreateGroundDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGround>>,
  TError,
  { data: BodyType<CreateGroundDto> },
  TContext
> => {
  const mutationKey = ['createGround'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGround>>,
    { data: BodyType<CreateGroundDto> }
  > = props => {
    const { data } = props ?? {};

    return createGround(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateGroundMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGround>>
>;
export type CreateGroundMutationBody = BodyType<CreateGroundDto>;
export type CreateGroundMutationError = ErrorType<void>;

export const useCreateGround = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGround>>,
      TError,
      { data: BodyType<CreateGroundDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createGround>>,
  TError,
  { data: BodyType<CreateGroundDto> },
  TContext
> => {
  const mutationOptions = getCreateGroundMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getGroundsByQuery = (
  params?: GetGroundsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetGroundsByQuery200AllOf>(
    { url: `/api/v1/grounds`, method: 'GET', params, signal },
    options,
  );
};

export const getGetGroundsByQueryQueryKey = (
  params?: GetGroundsByQueryParams,
) => {
  return [`/api/v1/grounds`, ...(params ? [params] : [])] as const;
};

export const getGetGroundsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroundsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroundsByQuery>>
  > = ({ signal }) => getGroundsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGroundsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroundsByQuery>>
>;
export type GetGroundsByQueryQueryError = ErrorType<void>;

export function useGetGroundsByQuery<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetGroundsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroundsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByQuery<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroundsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByQuery<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundsByQuery<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroundsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroundsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroundsByQuery>>
  > = ({ signal }) => getGroundsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGroundsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroundsByQuery>>
>;
export type GetGroundsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetGroundsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetGroundsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroundsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroundsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroundsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroundsByQuery>>
  > = ({ signal }) => getGroundsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGroundsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroundsByQuery>>
>;
export type GetGroundsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetGroundsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetGroundsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetGroundsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGround = (
  groundId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetGround200AllOf>(
    { url: `/api/v1/grounds/${groundId}`, method: 'GET', signal },
    options,
  );
};

export const getGetGroundQueryKey = (groundId: string) => {
  return [`/api/v1/grounds/${groundId}`] as const;
};

export const getGetGroundQueryOptions = <
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGround>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroundQueryKey(groundId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGround>>> = ({
    signal,
  }) => getGround(groundId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groundId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getGround>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetGroundQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGround>>
>;
export type GetGroundQueryError = ErrorType<void>;

export function useGetGround<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGround>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGround>>,
          TError,
          Awaited<ReturnType<typeof getGround>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGround<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGround>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGround>>,
          TError,
          Awaited<ReturnType<typeof getGround>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGround<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGround>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGround<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGround>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundQueryOptions(groundId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroundSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroundQueryKey(groundId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGround>>> = ({
    signal,
  }) => getGround(groundId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGround>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGround>>
>;
export type GetGroundSuspenseQueryError = ErrorType<void>;

export function useGetGroundSuspense<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundSuspense<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundSuspense<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundSuspense<
  TData = Awaited<ReturnType<typeof getGround>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundSuspenseQueryOptions(groundId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroundSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGround>>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroundQueryKey(groundId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGround>>> = ({
    signal,
  }) => getGround(groundId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGround>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGround>>
>;
export type GetGroundSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetGroundSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGround>>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGround>>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGround>>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGround>>>,
  TError = ErrorType<void>,
>(
  groundId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGround>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundSuspenseInfiniteQueryOptions(
    groundId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateGround = (
  groundId: string,
  updateGroundDto: BodyType<UpdateGroundDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateGround200AllOf>(
    {
      url: `/api/v1/grounds/${groundId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateGroundDto,
    },
    options,
  );
};

export const getUpdateGroundMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGround>>,
    TError,
    { groundId: string; data: BodyType<UpdateGroundDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGround>>,
  TError,
  { groundId: string; data: BodyType<UpdateGroundDto> },
  TContext
> => {
  const mutationKey = ['updateGround'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGround>>,
    { groundId: string; data: BodyType<UpdateGroundDto> }
  > = props => {
    const { groundId, data } = props ?? {};

    return updateGround(groundId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateGroundMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGround>>
>;
export type UpdateGroundMutationBody = BodyType<UpdateGroundDto>;
export type UpdateGroundMutationError = ErrorType<void>;

export const useUpdateGround = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateGround>>,
      TError,
      { groundId: string; data: BodyType<UpdateGroundDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateGround>>,
  TError,
  { groundId: string; data: BodyType<UpdateGroundDto> },
  TContext
> => {
  const mutationOptions = getUpdateGroundMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteGround = (
  groundId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteGround200AllOf>(
    { url: `/api/v1/grounds/${groundId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteGroundMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGround>>,
    TError,
    { groundId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGround>>,
  TError,
  { groundId: string },
  TContext
> => {
  const mutationKey = ['deleteGround'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGround>>,
    { groundId: string }
  > = props => {
    const { groundId } = props ?? {};

    return deleteGround(groundId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteGroundMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteGround>>
>;

export type DeleteGroundMutationError = ErrorType<void>;

export const useDeleteGround = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteGround>>,
      TError,
      { groundId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteGround>>,
  TError,
  { groundId: string },
  TContext
> => {
  const mutationOptions = getDeleteGroundMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeGrounds = (
  removeGroundsBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveGrounds200AllOf>(
    {
      url: `/api/v1/grounds/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeGroundsBody,
    },
    options,
  );
};

export const getRemoveGroundsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeGrounds>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeGrounds>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeGrounds'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeGrounds>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeGrounds(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveGroundsMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeGrounds>>
>;
export type RemoveGroundsMutationBody = BodyType<string[]>;
export type RemoveGroundsMutationError = ErrorType<void>;

export const useRemoveGrounds = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeGrounds>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeGrounds>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveGroundsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeGroundById = (
  groundId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveGroundById200AllOf>(
    { url: `/api/v1/grounds/${groundId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveGroundByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeGroundById>>,
    TError,
    { groundId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeGroundById>>,
  TError,
  { groundId: string },
  TContext
> => {
  const mutationKey = ['removeGroundById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeGroundById>>,
    { groundId: string }
  > = props => {
    const { groundId } = props ?? {};

    return removeGroundById(groundId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveGroundByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeGroundById>>
>;

export type RemoveGroundByIdMutationError = ErrorType<void>;

export const useRemoveGroundById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeGroundById>>,
      TError,
      { groundId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeGroundById>>,
  TError,
  { groundId: string },
  TContext
> => {
  const mutationOptions = getRemoveGroundByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createUserClassification = (
  createUserClassificationDto: BodyType<CreateUserClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateUserClassification200AllOf>(
    {
      url: `/api/v1/users/classifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createUserClassificationDto,
      signal,
    },
    options,
  );
};

export const getCreateUserClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUserClassification>>,
    TError,
    { data: BodyType<CreateUserClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUserClassification>>,
  TError,
  { data: BodyType<CreateUserClassificationDto> },
  TContext
> => {
  const mutationKey = ['createUserClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUserClassification>>,
    { data: BodyType<CreateUserClassificationDto> }
  > = props => {
    const { data } = props ?? {};

    return createUserClassification(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUserClassification>>
>;
export type CreateUserClassificationMutationBody =
  BodyType<CreateUserClassificationDto>;
export type CreateUserClassificationMutationError = ErrorType<void>;

export const useCreateUserClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUserClassification>>,
      TError,
      { data: BodyType<CreateUserClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUserClassification>>,
  TError,
  { data: BodyType<CreateUserClassificationDto> },
  TContext
> => {
  const mutationOptions = getCreateUserClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getUserClassificationsByQuery = (
  params?: GetUserClassificationsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUserClassificationsByQuery200AllOf>(
    { url: `/api/v1/users/classifications`, method: 'GET', params, signal },
    options,
  );
};

export const getGetUserClassificationsByQueryQueryKey = (
  params?: GetUserClassificationsByQueryParams,
) => {
  return [
    `/api/v1/users/classifications`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetUserClassificationsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  > = ({ signal }) =>
    getUserClassificationsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserClassificationsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserClassificationsByQuery>>
>;
export type GetUserClassificationsByQueryQueryError = ErrorType<void>;

export function useGetUserClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetUserClassificationsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getUserClassificationsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getUserClassificationsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserClassificationsByQueryQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserClassificationsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  > = ({ signal }) =>
    getUserClassificationsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserClassificationsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserClassificationsByQuery>>
>;
export type GetUserClassificationsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetUserClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetUserClassificationsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserClassificationsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserClassificationsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  > = ({ signal }) =>
    getUserClassificationsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserClassificationsByQuerySuspenseInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof getUserClassificationsByQuery>>>;
export type GetUserClassificationsByQuerySuspenseInfiniteQueryError =
  ErrorType<void>;

export function useGetUserClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params: undefined | GetUserClassificationsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getUserClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetUserClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetUserClassificationsByQuerySuspenseInfiniteQueryOptions(
      params,
      options,
    );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUserClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUserClassification200AllOf>(
    { url: `/api/v1/users/classifications/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetUserClassificationQueryKey = (id: string) => {
  return [`/api/v1/users/classifications/${id}`] as const;
};

export const getGetUserClassificationQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserClassification>>
  > = ({ signal }) => getUserClassification(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUserClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserClassificationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserClassification>>
>;
export type GetUserClassificationQueryError = ErrorType<void>;

export function useGetUserClassification<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserClassification>>,
          TError,
          Awaited<ReturnType<typeof getUserClassification>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassification<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserClassification>>,
          TError,
          Awaited<ReturnType<typeof getUserClassification>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassification<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserClassification<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserClassificationQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserClassificationSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserClassification>>
  > = ({ signal }) => getUserClassification(id, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUserClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserClassificationSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserClassification>>
>;
export type GetUserClassificationSuspenseQueryError = ErrorType<void>;

export function useGetUserClassificationSuspense<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationSuspense<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationSuspense<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserClassificationSuspense<
  TData = Awaited<ReturnType<typeof getUserClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserClassificationSuspenseQueryOptions(
    id,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserClassificationSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserClassification>>
  > = ({ signal }) => getUserClassification(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUserClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserClassificationSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserClassification>>
>;
export type GetUserClassificationSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetUserClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUserClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserClassificationSuspenseInfiniteQueryOptions(
    id,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateUserClassification = (
  id: string,
  updateUserClassificationDto: BodyType<UpdateUserClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateUserClassification200AllOf>(
    {
      url: `/api/v1/users/classifications/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateUserClassificationDto,
    },
    options,
  );
};

export const getUpdateUserClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUserClassification>>,
    TError,
    { id: string; data: BodyType<UpdateUserClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUserClassification>>,
  TError,
  { id: string; data: BodyType<UpdateUserClassificationDto> },
  TContext
> => {
  const mutationKey = ['updateUserClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUserClassification>>,
    { id: string; data: BodyType<UpdateUserClassificationDto> }
  > = props => {
    const { id, data } = props ?? {};

    return updateUserClassification(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUserClassification>>
>;
export type UpdateUserClassificationMutationBody =
  BodyType<UpdateUserClassificationDto>;
export type UpdateUserClassificationMutationError = ErrorType<void>;

export const useUpdateUserClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUserClassification>>,
      TError,
      { id: string; data: BodyType<UpdateUserClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateUserClassification>>,
  TError,
  { id: string; data: BodyType<UpdateUserClassificationDto> },
  TContext
> => {
  const mutationOptions = getUpdateUserClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteUserClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteUserClassification200AllOf>(
    { url: `/api/v1/users/classifications/${id}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteUserClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUserClassification>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUserClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteUserClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUserClassification>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return deleteUserClassification(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUserClassification>>
>;

export type DeleteUserClassificationMutationError = ErrorType<void>;

export const useDeleteUserClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUserClassification>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUserClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteUserClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeUserClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveUserClassification200AllOf>(
    { url: `/api/v1/users/classifications/${id}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveUserClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserClassification>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUserClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['removeUserClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUserClassification>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return removeUserClassification(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUserClassification>>
>;

export type RemoveUserClassificationMutationError = ErrorType<void>;

export const useRemoveUserClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeUserClassification>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeUserClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRemoveUserClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Create a new roleclassification
 * @summary Create RoleClassification
 */
export const create = (
  createRoleClassificationDto: BodyType<CreateRoleClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<Create200AllOf>(
    {
      url: `/api/v1/roles/classifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createRoleClassificationDto,
      signal,
    },
    options,
  );
};

export const getCreateMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof create>>,
    TError,
    { data: BodyType<CreateRoleClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof create>>,
  TError,
  { data: BodyType<CreateRoleClassificationDto> },
  TContext
> => {
  const mutationKey = ['create'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof create>>,
    { data: BodyType<CreateRoleClassificationDto> }
  > = props => {
    const { data } = props ?? {};

    return create(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof create>>
>;
export type CreateMutationBody = BodyType<CreateRoleClassificationDto>;
export type CreateMutationError = ErrorType<void>;

/**
 * @summary Create RoleClassification
 */
export const useCreate = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof create>>,
      TError,
      { data: BodyType<CreateRoleClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof create>>,
  TError,
  { data: BodyType<CreateRoleClassificationDto> },
  TContext
> => {
  const mutationOptions = getCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Retrieve multiple roleclassifications with query parameters
 * @summary Get multiple RoleClassifications
 */
export const getManyByQuery = (
  params?: GetManyByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetManyByQuery200AllOf>(
    { url: `/api/v1/roles/classifications`, method: 'GET', params, signal },
    options,
  );
};

export const getGetManyByQueryQueryKey = (params?: GetManyByQueryParams) => {
  return [
    `/api/v1/roles/classifications`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetManyByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getManyByQuery>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetManyByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getManyByQuery>>> = ({
    signal,
  }) => getManyByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getManyByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetManyByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getManyByQuery>>
>;
export type GetManyByQueryQueryError = ErrorType<void>;

export function useGetManyByQuery<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetManyByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getManyByQuery>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getManyByQuery>>,
          TError,
          Awaited<ReturnType<typeof getManyByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetManyByQuery<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getManyByQuery>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getManyByQuery>>,
          TError,
          Awaited<ReturnType<typeof getManyByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetManyByQuery<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getManyByQuery>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get multiple RoleClassifications
 */

export function useGetManyByQuery<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getManyByQuery>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetManyByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetManyByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetManyByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getManyByQuery>>> = ({
    signal,
  }) => getManyByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getManyByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetManyByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getManyByQuery>>
>;
export type GetManyByQuerySuspenseQueryError = ErrorType<void>;

export function useGetManyByQuerySuspense<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetManyByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetManyByQuerySuspense<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetManyByQuerySuspense<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get multiple RoleClassifications
 */

export function useGetManyByQuerySuspense<
  TData = Awaited<ReturnType<typeof getManyByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetManyByQuerySuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetManyByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getManyByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetManyByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getManyByQuery>>> = ({
    signal,
  }) => getManyByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getManyByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetManyByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getManyByQuery>>
>;
export type GetManyByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetManyByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getManyByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetManyByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetManyByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getManyByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetManyByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getManyByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get multiple RoleClassifications
 */

export function useGetManyByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getManyByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetManyByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getManyByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetManyByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve a roleclassification by its ID
 * @summary Get RoleClassification by ID
 */
export const getById = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetById200AllOf>(
    { url: `/api/v1/roles/classifications/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetByIdQueryKey = (id: string) => {
  return [`/api/v1/roles/classifications/${id}`] as const;
};

export const getGetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById>>> = ({
    signal,
  }) => getById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getById>>
>;
export type GetByIdQueryError = ErrorType<void>;

export function useGetById<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getById>>,
          TError,
          Awaited<ReturnType<typeof getById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetById<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getById>>,
          TError,
          Awaited<ReturnType<typeof getById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetById<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get RoleClassification by ID
 */

export function useGetById<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById>>> = ({
    signal,
  }) => getById(id, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getById>>
>;
export type GetByIdSuspenseQueryError = ErrorType<void>;

export function useGetByIdSuspense<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByIdSuspense<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByIdSuspense<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get RoleClassification by ID
 */

export function useGetByIdSuspense<
  TData = Awaited<ReturnType<typeof getById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByIdSuspenseQueryOptions(id, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetByIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getById>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetByIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById>>> = ({
    signal,
  }) => getById(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetByIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getById>>
>;
export type GetByIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getById>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getById>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getById>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get RoleClassification by ID
 */

export function useGetByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getById>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByIdSuspenseInfiniteQueryOptions(id, options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update a roleclassification by its ID
 * @summary Update RoleClassification by ID
 */
export const updateById = (
  id: string,
  updateRoleClassificationDto: BodyType<UpdateRoleClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateById200AllOf>(
    {
      url: `/api/v1/roles/classifications/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateRoleClassificationDto,
    },
    options,
  );
};

export const getUpdateByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateById>>,
    TError,
    { id: string; data: BodyType<UpdateRoleClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateById>>,
  TError,
  { id: string; data: BodyType<UpdateRoleClassificationDto> },
  TContext
> => {
  const mutationKey = ['updateById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateById>>,
    { id: string; data: BodyType<UpdateRoleClassificationDto> }
  > = props => {
    const { id, data } = props ?? {};

    return updateById(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateById>>
>;
export type UpdateByIdMutationBody = BodyType<UpdateRoleClassificationDto>;
export type UpdateByIdMutationError = ErrorType<void>;

/**
 * @summary Update RoleClassification by ID
 */
export const useUpdateById = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateById>>,
      TError,
      { id: string; data: BodyType<UpdateRoleClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateById>>,
  TError,
  { id: string; data: BodyType<UpdateRoleClassificationDto> },
  TContext
> => {
  const mutationOptions = getUpdateByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Permanently delete a roleclassification by its ID
 * @summary Delete RoleClassification by ID
 */
export const deleteById = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteById200AllOf>(
    { url: `/api/v1/roles/classifications/${id}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteById>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteById>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return deleteById(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteById>>
>;

export type DeleteByIdMutationError = ErrorType<void>;

/**
 * @summary Delete RoleClassification by ID
 */
export const useDeleteById = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteById>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * Soft delete a roleclassification by its ID
 * @summary Remove RoleClassification by ID
 */
export const removeById = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveById200AllOf>(
    { url: `/api/v1/roles/classifications/${id}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeById>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['removeById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeById>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return removeById(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeById>>
>;

export type RemoveByIdMutationError = ErrorType<void>;

/**
 * @summary Remove RoleClassification by ID
 */
export const useRemoveById = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeById>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeById>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRemoveByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createFileClassification = (
  createFileClassificationDto: BodyType<CreateFileClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateFileClassification200AllOf>(
    {
      url: `/api/v1/files/classifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createFileClassificationDto,
      signal,
    },
    options,
  );
};

export const getCreateFileClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFileClassification>>,
    TError,
    { data: BodyType<CreateFileClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFileClassification>>,
  TError,
  { data: BodyType<CreateFileClassificationDto> },
  TContext
> => {
  const mutationKey = ['createFileClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFileClassification>>,
    { data: BodyType<CreateFileClassificationDto> }
  > = props => {
    const { data } = props ?? {};

    return createFileClassification(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateFileClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFileClassification>>
>;
export type CreateFileClassificationMutationBody =
  BodyType<CreateFileClassificationDto>;
export type CreateFileClassificationMutationError = ErrorType<void>;

export const useCreateFileClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFileClassification>>,
      TError,
      { data: BodyType<CreateFileClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createFileClassification>>,
  TError,
  { data: BodyType<CreateFileClassificationDto> },
  TContext
> => {
  const mutationOptions = getCreateFileClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getFileClassificationsByQuery = (
  params?: GetFileClassificationsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetFileClassificationsByQuery200AllOf>(
    { url: `/api/v1/files/classifications`, method: 'GET', params, signal },
    options,
  );
};

export const getGetFileClassificationsByQueryQueryKey = (
  params?: GetFileClassificationsByQueryParams,
) => {
  return [
    `/api/v1/files/classifications`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetFileClassificationsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  > = ({ signal }) =>
    getFileClassificationsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileClassificationsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileClassificationsByQuery>>
>;
export type GetFileClassificationsByQueryQueryError = ErrorType<void>;

export function useGetFileClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetFileClassificationsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getFileClassificationsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileClassificationsByQueryQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFileClassificationsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  > = ({ signal }) =>
    getFileClassificationsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileClassificationsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileClassificationsByQuery>>
>;
export type GetFileClassificationsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetFileClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetFileClassificationsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileClassificationsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFileClassificationsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  > = ({ signal }) =>
    getFileClassificationsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileClassificationsByQuerySuspenseInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof getFileClassificationsByQuery>>>;
export type GetFileClassificationsByQuerySuspenseInfiniteQueryError =
  ErrorType<void>;

export function useGetFileClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params: undefined | GetFileClassificationsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getFileClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetFileClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetFileClassificationsByQuerySuspenseInfiniteQueryOptions(
      params,
      options,
    );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFileClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetFileClassification200AllOf>(
    { url: `/api/v1/files/classifications/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetFileClassificationQueryKey = (id: string) => {
  return [`/api/v1/files/classifications/${id}`] as const;
};

export const getGetFileClassificationQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileClassification>>
  > = ({ signal }) => getFileClassification(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFileClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileClassificationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileClassification>>
>;
export type GetFileClassificationQueryError = ErrorType<void>;

export function useGetFileClassification<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassification>>,
          TError,
          Awaited<ReturnType<typeof getFileClassification>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassification<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileClassification>>,
          TError,
          Awaited<ReturnType<typeof getFileClassification>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassification<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileClassification<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileClassificationQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFileClassificationSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileClassification>>
  > = ({ signal }) => getFileClassification(id, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getFileClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileClassificationSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileClassification>>
>;
export type GetFileClassificationSuspenseQueryError = ErrorType<void>;

export function useGetFileClassificationSuspense<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationSuspense<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationSuspense<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileClassificationSuspense<
  TData = Awaited<ReturnType<typeof getFileClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileClassificationSuspenseQueryOptions(
    id,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFileClassificationSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFileClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFileClassification>>
  > = ({ signal }) => getFileClassification(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFileClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileClassificationSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileClassification>>
>;
export type GetFileClassificationSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetFileClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileClassificationSuspenseInfiniteQueryOptions(
    id,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateFileClassification = (
  id: string,
  updateFileClassificationDto: BodyType<UpdateFileClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateFileClassification200AllOf>(
    {
      url: `/api/v1/files/classifications/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateFileClassificationDto,
    },
    options,
  );
};

export const getUpdateFileClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFileClassification>>,
    TError,
    { id: string; data: BodyType<UpdateFileClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFileClassification>>,
  TError,
  { id: string; data: BodyType<UpdateFileClassificationDto> },
  TContext
> => {
  const mutationKey = ['updateFileClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFileClassification>>,
    { id: string; data: BodyType<UpdateFileClassificationDto> }
  > = props => {
    const { id, data } = props ?? {};

    return updateFileClassification(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateFileClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFileClassification>>
>;
export type UpdateFileClassificationMutationBody =
  BodyType<UpdateFileClassificationDto>;
export type UpdateFileClassificationMutationError = ErrorType<void>;

export const useUpdateFileClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFileClassification>>,
      TError,
      { id: string; data: BodyType<UpdateFileClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateFileClassification>>,
  TError,
  { id: string; data: BodyType<UpdateFileClassificationDto> },
  TContext
> => {
  const mutationOptions = getUpdateFileClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteFileClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteFileClassification200AllOf>(
    { url: `/api/v1/files/classifications/${id}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteFileClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteFileClassification>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteFileClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteFileClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteFileClassification>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return deleteFileClassification(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteFileClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteFileClassification>>
>;

export type DeleteFileClassificationMutationError = ErrorType<void>;

export const useDeleteFileClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteFileClassification>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteFileClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteFileClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeFileClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveFileClassification200AllOf>(
    { url: `/api/v1/files/classifications/${id}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveFileClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFileClassification>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeFileClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['removeFileClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeFileClassification>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return removeFileClassification(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveFileClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeFileClassification>>
>;

export type RemoveFileClassificationMutationError = ErrorType<void>;

export const useRemoveFileClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeFileClassification>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeFileClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRemoveFileClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createSpaceClassification = (
  createSpaceClassificationDto: BodyType<CreateSpaceClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateSpaceClassification200AllOf>(
    {
      url: `/api/v1/spaces/classifications`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSpaceClassificationDto,
      signal,
    },
    options,
  );
};

export const getCreateSpaceClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSpaceClassification>>,
    TError,
    { data: BodyType<CreateSpaceClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSpaceClassification>>,
  TError,
  { data: BodyType<CreateSpaceClassificationDto> },
  TContext
> => {
  const mutationKey = ['createSpaceClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSpaceClassification>>,
    { data: BodyType<CreateSpaceClassificationDto> }
  > = props => {
    const { data } = props ?? {};

    return createSpaceClassification(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSpaceClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSpaceClassification>>
>;
export type CreateSpaceClassificationMutationBody =
  BodyType<CreateSpaceClassificationDto>;
export type CreateSpaceClassificationMutationError = ErrorType<void>;

export const useCreateSpaceClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSpaceClassification>>,
      TError,
      { data: BodyType<CreateSpaceClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSpaceClassification>>,
  TError,
  { data: BodyType<CreateSpaceClassificationDto> },
  TContext
> => {
  const mutationOptions = getCreateSpaceClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSpaceClassificationsByQuery = (
  params?: GetSpaceClassificationsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSpaceClassificationsByQuery200AllOf>(
    { url: `/api/v1/spaces/classifications`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSpaceClassificationsByQueryQueryKey = (
  params?: GetSpaceClassificationsByQueryParams,
) => {
  return [
    `/api/v1/spaces/classifications`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetSpaceClassificationsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpaceClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  > = ({ signal }) =>
    getSpaceClassificationsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceClassificationsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
>;
export type GetSpaceClassificationsByQueryQueryError = ErrorType<void>;

export function useGetSpaceClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSpaceClassificationsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceClassificationsByQuery<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceClassificationsByQueryQueryOptions(
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpaceClassificationsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpaceClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  > = ({ signal }) =>
    getSpaceClassificationsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceClassificationsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
>;
export type GetSpaceClassificationsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetSpaceClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSpaceClassificationsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceClassificationsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceClassificationsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpaceClassificationsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpaceClassificationsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  > = ({ signal }) =>
    getSpaceClassificationsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceClassificationsByQuerySuspenseInfiniteQueryResult =
  NonNullable<Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>>;
export type GetSpaceClassificationsByQuerySuspenseInfiniteQueryError =
  ErrorType<void>;

export function useGetSpaceClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params: undefined | GetSpaceClassificationsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceClassificationsByQuerySuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>
  >,
  TError = ErrorType<void>,
>(
  params?: GetSpaceClassificationsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassificationsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetSpaceClassificationsByQuerySuspenseInfiniteQueryOptions(
      params,
      options,
    );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSpaceClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSpaceClassification200AllOf>(
    { url: `/api/v1/spaces/classifications/${id}`, method: 'GET', signal },
    options,
  );
};

export const getGetSpaceClassificationQueryKey = (id: string) => {
  return [`/api/v1/spaces/classifications/${id}`] as const;
};

export const getGetSpaceClassificationQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpaceClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpaceClassification>>
  > = ({ signal }) => getSpaceClassification(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSpaceClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceClassificationQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpaceClassification>>
>;
export type GetSpaceClassificationQueryError = ErrorType<void>;

export function useGetSpaceClassification<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassification>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassification>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassification<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpaceClassification>>,
          TError,
          Awaited<ReturnType<typeof getSpaceClassification>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassification<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceClassification<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceClassificationQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpaceClassificationSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpaceClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpaceClassification>>
  > = ({ signal }) => getSpaceClassification(id, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSpaceClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceClassificationSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpaceClassification>>
>;
export type GetSpaceClassificationSuspenseQueryError = ErrorType<void>;

export function useGetSpaceClassificationSuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationSuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationSuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceClassificationSuspense<
  TData = Awaited<ReturnType<typeof getSpaceClassification>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceClassificationSuspenseQueryOptions(
    id,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpaceClassificationSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpaceClassificationQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpaceClassification>>
  > = ({ signal }) => getSpaceClassification(id, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSpaceClassification>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceClassificationSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpaceClassification>>
>;
export type GetSpaceClassificationSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSpaceClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceClassificationSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpaceClassification>>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpaceClassification>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceClassificationSuspenseInfiniteQueryOptions(
    id,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateSpaceClassification = (
  id: string,
  updateSpaceClassificationDto: BodyType<UpdateSpaceClassificationDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateSpaceClassification200AllOf>(
    {
      url: `/api/v1/spaces/classifications/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateSpaceClassificationDto,
    },
    options,
  );
};

export const getUpdateSpaceClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSpaceClassification>>,
    TError,
    { id: string; data: BodyType<UpdateSpaceClassificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSpaceClassification>>,
  TError,
  { id: string; data: BodyType<UpdateSpaceClassificationDto> },
  TContext
> => {
  const mutationKey = ['updateSpaceClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSpaceClassification>>,
    { id: string; data: BodyType<UpdateSpaceClassificationDto> }
  > = props => {
    const { id, data } = props ?? {};

    return updateSpaceClassification(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSpaceClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSpaceClassification>>
>;
export type UpdateSpaceClassificationMutationBody =
  BodyType<UpdateSpaceClassificationDto>;
export type UpdateSpaceClassificationMutationError = ErrorType<void>;

export const useUpdateSpaceClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSpaceClassification>>,
      TError,
      { id: string; data: BodyType<UpdateSpaceClassificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSpaceClassification>>,
  TError,
  { id: string; data: BodyType<UpdateSpaceClassificationDto> },
  TContext
> => {
  const mutationOptions = getUpdateSpaceClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteSpaceClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteSpaceClassification200AllOf>(
    { url: `/api/v1/spaces/classifications/${id}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteSpaceClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSpaceClassification>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSpaceClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['deleteSpaceClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSpaceClassification>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return deleteSpaceClassification(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSpaceClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSpaceClassification>>
>;

export type DeleteSpaceClassificationMutationError = ErrorType<void>;

export const useDeleteSpaceClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSpaceClassification>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSpaceClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteSpaceClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeSpaceClassification = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveSpaceClassification200AllOf>(
    { url: `/api/v1/spaces/classifications/${id}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveSpaceClassificationMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeSpaceClassification>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeSpaceClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['removeSpaceClassification'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeSpaceClassification>>,
    { id: string }
  > = props => {
    const { id } = props ?? {};

    return removeSpaceClassification(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveSpaceClassificationMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeSpaceClassification>>
>;

export type RemoveSpaceClassificationMutationError = ErrorType<void>;

export const useRemoveSpaceClassification = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeSpaceClassification>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeSpaceClassification>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getRemoveSpaceClassificationMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAppBuilder = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    { url: `/api/v1/appBuilder`, method: 'GET', signal },
    options,
  );
};

export const getGetAppBuilderQueryKey = () => {
  return [`/api/v1/appBuilder`] as const;
};

export const getGetAppBuilderQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({
    signal,
  }) => getAppBuilder(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAppBuilder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAppBuilderQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppBuilder>>
>;
export type GetAppBuilderQueryError = ErrorType<void>;

export function useGetAppBuilder<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppBuilder>>,
          TError,
          Awaited<ReturnType<typeof getAppBuilder>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppBuilder<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAppBuilder>>,
          TError,
          Awaited<ReturnType<typeof getAppBuilder>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppBuilder<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAppBuilder<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAppBuilder>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAppBuilderQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAppBuilderSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAppBuilder>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({
    signal,
  }) => getAppBuilder(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAppBuilder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAppBuilderSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppBuilder>>
>;
export type GetAppBuilderSuspenseQueryError = ErrorType<void>;

export function useGetAppBuilderSuspense<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppBuilderSuspense<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppBuilderSuspense<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAppBuilderSuspense<
  TData = Awaited<ReturnType<typeof getAppBuilder>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAppBuilderSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAppBuilderSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getAppBuilder>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAppBuilderQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAppBuilder>>> = ({
    signal,
  }) => getAppBuilder(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAppBuilder>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAppBuilderSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAppBuilder>>
>;
export type GetAppBuilderSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetAppBuilderSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppBuilderSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAppBuilderSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAppBuilderSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAppBuilder>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAppBuilder>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAppBuilderSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const loginButton = (
  loginPayloadDto: BodyType<LoginPayloadDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<void>(
    {
      url: `/api/v1/appBuilder/login-button`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginPayloadDto,
      signal,
    },
    options,
  );
};

export const getLoginButtonMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginButton>>,
    TError,
    { data: BodyType<LoginPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginButton>>,
  TError,
  { data: BodyType<LoginPayloadDto> },
  TContext
> => {
  const mutationKey = ['loginButton'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginButton>>,
    { data: BodyType<LoginPayloadDto> }
  > = props => {
    const { data } = props ?? {};

    return loginButton(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LoginButtonMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginButton>>
>;
export type LoginButtonMutationBody = BodyType<LoginPayloadDto>;
export type LoginButtonMutationError = ErrorType<unknown>;

export const useLoginButton = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof loginButton>>,
      TError,
      { data: BodyType<LoginPayloadDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof loginButton>>,
  TError,
  { data: BodyType<LoginPayloadDto> },
  TContext
> => {
  const mutationOptions = getLoginButtonMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getToken = (
  loginPayloadDto: BodyType<LoginPayloadDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetToken200AllOf>(
    {
      url: `/api/v1/auth/token`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: loginPayloadDto,
      signal,
    },
    options,
  );
};

export const getGetTokenMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof getToken>>,
    TError,
    { data: BodyType<LoginPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof getToken>>,
  TError,
  { data: BodyType<LoginPayloadDto> },
  TContext
> => {
  const mutationKey = ['getToken'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof getToken>>,
    { data: BodyType<LoginPayloadDto> }
  > = props => {
    const { data } = props ?? {};

    return getToken(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GetTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof getToken>>
>;
export type GetTokenMutationBody = BodyType<LoginPayloadDto>;
export type GetTokenMutationError = ErrorType<unknown>;

export const useGetToken = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof getToken>>,
      TError,
      { data: BodyType<LoginPayloadDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof getToken>>,
  TError,
  { data: BodyType<LoginPayloadDto> },
  TContext
> => {
  const mutationOptions = getGetTokenMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getNewToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<TokenDto>(
    { url: `/api/v1/auth/new-token`, method: 'GET', signal },
    options,
  );
};

export const getGetNewTokenQueryKey = () => {
  return [`/api/v1/auth/new-token`] as const;
};

export const getGetNewTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({
    signal,
  }) => getNewToken(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNewToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNewTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNewToken>>
>;
export type GetNewTokenQueryError = ErrorType<void>;

export function useGetNewToken<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          Awaited<ReturnType<typeof getNewToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewToken<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNewToken>>,
          TError,
          Awaited<ReturnType<typeof getNewToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewToken<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetNewToken<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getNewToken>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNewTokenQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetNewTokenSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getNewToken>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({
    signal,
  }) => getNewToken(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getNewToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNewTokenSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNewToken>>
>;
export type GetNewTokenSuspenseQueryError = ErrorType<void>;

export function useGetNewTokenSuspense<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspense<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspense<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetNewTokenSuspense<
  TData = Awaited<ReturnType<typeof getNewToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNewTokenSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetNewTokenSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof getNewToken>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetNewTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getNewToken>>> = ({
    signal,
  }) => getNewToken(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getNewToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNewTokenSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNewToken>>
>;
export type GetNewTokenSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetNewTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNewTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetNewTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getNewToken>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getNewToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNewTokenSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const signUpUser = (
  signUpPayloadDto: BodyType<SignUpPayloadDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<SignUpUser201AllOf>(
    {
      url: `/api/v1/auth/sign-up`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: signUpPayloadDto,
      signal,
    },
    options,
  );
};

export const getSignUpUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signUpUser>>,
    TError,
    { data: BodyType<SignUpPayloadDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof signUpUser>>,
  TError,
  { data: BodyType<SignUpPayloadDto> },
  TContext
> => {
  const mutationKey = ['signUpUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signUpUser>>,
    { data: BodyType<SignUpPayloadDto> }
  > = props => {
    const { data } = props ?? {};

    return signUpUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SignUpUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof signUpUser>>
>;
export type SignUpUserMutationBody = BodyType<SignUpPayloadDto>;
export type SignUpUserMutationError = ErrorType<unknown>;

export const useSignUpUser = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof signUpUser>>,
      TError,
      { data: BodyType<SignUpPayloadDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof signUpUser>>,
  TError,
  { data: BodyType<SignUpPayloadDto> },
  TContext
> => {
  const mutationOptions = getSignUpUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const verifyToken = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<VerifyToken200AllOf>(
    { url: `/api/v1/auth/verify-token`, method: 'GET', signal },
    options,
  );
};

export const getVerifyTokenQueryKey = () => {
  return [`/api/v1/auth/verify-token`] as const;
};

export const getVerifyTokenQueryOptions = <
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVerifyTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({
    signal,
  }) => verifyToken(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof verifyToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VerifyTokenQueryResult = NonNullable<
  Awaited<ReturnType<typeof verifyToken>>
>;
export type VerifyTokenQueryError = ErrorType<void>;

export function useVerifyToken<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyToken>>,
          TError,
          Awaited<ReturnType<typeof verifyToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyToken<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof verifyToken>>,
          TError,
          Awaited<ReturnType<typeof verifyToken>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyToken<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVerifyToken<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof verifyToken>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVerifyTokenQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVerifyTokenSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof verifyToken>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVerifyTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({
    signal,
  }) => verifyToken(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof verifyToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VerifyTokenSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof verifyToken>>
>;
export type VerifyTokenSuspenseQueryError = ErrorType<void>;

export function useVerifyTokenSuspense<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspense<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspense<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVerifyTokenSuspense<
  TData = Awaited<ReturnType<typeof verifyToken>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVerifyTokenSuspenseQueryOptions(options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getVerifyTokenSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseInfiniteQueryOptions<
      Awaited<ReturnType<typeof verifyToken>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getVerifyTokenQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof verifyToken>>> = ({
    signal,
  }) => verifyToken(requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof verifyToken>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VerifyTokenSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof verifyToken>>
>;
export type VerifyTokenSuspenseInfiniteQueryError = ErrorType<void>;

export function useVerifyTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVerifyTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useVerifyTokenSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof verifyToken>>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof verifyToken>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getVerifyTokenSuspenseInfiniteQueryOptions(options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getCategoriesByQuery = (
  params: GetCategoriesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetCategoriesByQuery200AllOf>(
    { url: `/api/v1/categories`, method: 'GET', params, signal },
    options,
  );
};

export const getGetCategoriesByQueryQueryKey = (
  params: GetCategoriesByQueryParams,
) => {
  return [`/api/v1/categories`, ...(params ? [params] : [])] as const;
};

export const getGetCategoriesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoriesByQuery>>
  > = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoriesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoriesByQuery>>
>;
export type GetCategoriesByQueryQueryError = ErrorType<void>;

export function useGetCategoriesByQuery<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesByQuery<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoriesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getCategoriesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesByQuery<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetCategoriesByQuery<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCategoriesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoriesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoriesByQuery>>
  > = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getCategoriesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoriesByQuery>>
>;
export type GetCategoriesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetCategoriesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetCategoriesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getCategoriesByQuery>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCategoriesByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoriesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoriesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCategoriesByQuery>>
  > = ({ signal }) => getCategoriesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategoriesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoriesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoriesByQuery>>
>;
export type GetCategoriesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetCategoriesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoriesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetCategoriesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoriesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: GetCategoriesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoriesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCategoriesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createCategory = (
  createCategoryDto: BodyType<CreateCategoryDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateCategory200AllOf>(
    {
      url: `/api/v1/categories`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createCategoryDto,
      signal,
    },
    options,
  );
};

export const getCreateCategoryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCategory>>,
    TError,
    { data: BodyType<CreateCategoryDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: BodyType<CreateCategoryDto> },
  TContext
> => {
  const mutationKey = ['createCategory'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCategory>>,
    { data: BodyType<CreateCategoryDto> }
  > = props => {
    const { data } = props ?? {};

    return createCategory(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCategory>>
>;
export type CreateCategoryMutationBody = BodyType<CreateCategoryDto>;
export type CreateCategoryMutationError = ErrorType<void>;

export const useCreateCategory = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCategory>>,
      TError,
      { data: BodyType<CreateCategoryDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createCategory>>,
  TError,
  { data: BodyType<CreateCategoryDto> },
  TContext
> => {
  const mutationOptions = getCreateCategoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getCategoryById = (
  categoryId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetCategoryById200AllOf>(
    { url: `/api/v1/categories/${categoryId}`, method: 'GET', signal },
    options,
  );
};

export const getGetCategoryByIdQueryKey = (categoryId: string) => {
  return [`/api/v1/categories/${categoryId}`] as const;
};

export const getGetCategoryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({
    signal,
  }) => getCategoryById(categoryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!categoryId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getCategoryById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoryByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryById>>
>;
export type GetCategoryByIdQueryError = ErrorType<void>;

export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCategoryById>>,
          TError,
          Awaited<ReturnType<typeof getCategoryById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetCategoryById<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCategoryByIdQueryOptions(categoryId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoryByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({
    signal,
  }) => getCategoryById(categoryId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getCategoryById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoryByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryById>>
>;
export type GetCategoryByIdSuspenseQueryError = ErrorType<void>;

export function useGetCategoryByIdSuspense<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryByIdSuspense<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryByIdSuspense<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetCategoryByIdSuspense<
  TData = Awaited<ReturnType<typeof getCategoryById>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCategoryByIdSuspenseQueryOptions(
    categoryId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetCategoryByIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetCategoryByIdQueryKey(categoryId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCategoryById>>> = ({
    signal,
  }) => getCategoryById(categoryId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getCategoryById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCategoryByIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCategoryById>>
>;
export type GetCategoryByIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetCategoryByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetCategoryByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetCategoryByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getCategoryById>>>,
  TError = ErrorType<void>,
>(
  categoryId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getCategoryById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetCategoryByIdSuspenseInfiniteQueryOptions(
    categoryId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateCategory = (
  categoryId: string,
  updateCategoryDto: BodyType<UpdateCategoryDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateCategory200AllOf>(
    {
      url: `/api/v1/categories/${categoryId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateCategoryDto,
    },
    options,
  );
};

export const getUpdateCategoryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCategory>>,
    TError,
    { categoryId: string; data: BodyType<UpdateCategoryDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { categoryId: string; data: BodyType<UpdateCategoryDto> },
  TContext
> => {
  const mutationKey = ['updateCategory'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCategory>>,
    { categoryId: string; data: BodyType<UpdateCategoryDto> }
  > = props => {
    const { categoryId, data } = props ?? {};

    return updateCategory(categoryId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCategory>>
>;
export type UpdateCategoryMutationBody = BodyType<UpdateCategoryDto>;
export type UpdateCategoryMutationError = ErrorType<void>;

export const useUpdateCategory = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateCategory>>,
      TError,
      { categoryId: string; data: BodyType<UpdateCategoryDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateCategory>>,
  TError,
  { categoryId: string; data: BodyType<UpdateCategoryDto> },
  TContext
> => {
  const mutationOptions = getUpdateCategoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteCategory = (
  categoryId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteCategory200AllOf>(
    { url: `/api/v1/categories/${categoryId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteCategoryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCategory>>,
    TError,
    { categoryId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { categoryId: string },
  TContext
> => {
  const mutationKey = ['deleteCategory'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCategory>>,
    { categoryId: string }
  > = props => {
    const { categoryId } = props ?? {};

    return deleteCategory(categoryId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCategoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCategory>>
>;

export type DeleteCategoryMutationError = ErrorType<void>;

export const useDeleteCategory = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteCategory>>,
      TError,
      { categoryId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteCategory>>,
  TError,
  { categoryId: string },
  TContext
> => {
  const mutationOptions = getDeleteCategoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createGroup = (
  createGroupDto: BodyType<CreateGroupDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GroupDto>(
    {
      url: `/api/v1/groups`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createGroupDto,
      signal,
    },
    options,
  );
};

export const getCreateGroupMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGroup>>,
    TError,
    { data: BodyType<CreateGroupDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGroup>>,
  TError,
  { data: BodyType<CreateGroupDto> },
  TContext
> => {
  const mutationKey = ['createGroup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGroup>>,
    { data: BodyType<CreateGroupDto> }
  > = props => {
    const { data } = props ?? {};

    return createGroup(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGroup>>
>;
export type CreateGroupMutationBody = BodyType<CreateGroupDto>;
export type CreateGroupMutationError = ErrorType<void>;

export const useCreateGroup = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGroup>>,
      TError,
      { data: BodyType<CreateGroupDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createGroup>>,
  TError,
  { data: BodyType<CreateGroupDto> },
  TContext
> => {
  const mutationOptions = getCreateGroupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getGroupsByQuery = (
  params?: GetGroupsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetGroupsByQuery200AllOf>(
    { url: `/api/v1/groups`, method: 'GET', params, signal },
    options,
  );
};

export const getGetGroupsByQueryQueryKey = (
  params?: GetGroupsByQueryParams,
) => {
  return [`/api/v1/groups`, ...(params ? [params] : [])] as const;
};

export const getGetGroupsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroupsByQuery>>
  > = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGroupsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroupsByQuery>>
>;
export type GetGroupsByQueryQueryError = ErrorType<unknown>;

export function useGetGroupsByQuery<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | GetGroupsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroupsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupsByQuery<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroupsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getGroupsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupsByQuery<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroupsByQuery<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroupsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroupsByQuery>>
  > = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGroupsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroupsByQuery>>
>;
export type GetGroupsByQuerySuspenseQueryError = ErrorType<unknown>;

export function useGetGroupsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | GetGroupsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroupsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getGroupsByQuery>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupsByQuerySuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroupsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroupsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroupsByQuery>>
  > = ({ signal }) => getGroupsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGroupsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroupsByQuery>>
>;
export type GetGroupsByQuerySuspenseInfiniteQueryError = ErrorType<unknown>;

export function useGetGroupsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | GetGroupsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroupsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroupsByQuery>>>,
  TError = ErrorType<unknown>,
>(
  params?: GetGroupsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroupsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGroup = (
  groupId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetGroup200AllOf>(
    { url: `/api/v1/groups/${groupId}`, method: 'GET', signal },
    options,
  );
};

export const getGetGroupQueryKey = (groupId: string) => {
  return [`/api/v1/groups/${groupId}`] as const;
};

export const getGetGroupQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({
    signal,
  }) => getGroup(groupId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!groupId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetGroupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroup>>
>;
export type GetGroupQueryError = ErrorType<unknown>;

export function useGetGroup<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroup>>,
          TError,
          Awaited<ReturnType<typeof getGroup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroup<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroup>>,
          TError,
          Awaited<ReturnType<typeof getGroup>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroup<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroup<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGroup>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupQueryOptions(groupId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroupSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({
    signal,
  }) => getGroup(groupId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGroup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroup>>
>;
export type GetGroupSuspenseQueryError = ErrorType<unknown>;

export function useGetGroupSuspense<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupSuspense<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupSuspense<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroupSuspense<
  TData = Awaited<ReturnType<typeof getGroup>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupSuspenseQueryOptions(groupId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroupSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupQueryKey(groupId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroup>>> = ({
    signal,
  }) => getGroup(groupId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGroup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroup>>
>;
export type GetGroupSuspenseInfiniteQueryError = ErrorType<unknown>;

export function useGetGroupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroupSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroup>>>,
  TError = ErrorType<unknown>,
>(
  groupId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroupSuspenseInfiniteQueryOptions(
    groupId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateGroup = (
  groupId: string,
  updateGroupDto: BodyType<UpdateGroupDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateGroup200AllOf>(
    {
      url: `/api/v1/groups/${groupId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateGroupDto,
    },
    options,
  );
};

export const getUpdateGroupMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGroup>>,
    TError,
    { groupId: string; data: BodyType<UpdateGroupDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGroup>>,
  TError,
  { groupId: string; data: BodyType<UpdateGroupDto> },
  TContext
> => {
  const mutationKey = ['updateGroup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGroup>>,
    { groupId: string; data: BodyType<UpdateGroupDto> }
  > = props => {
    const { groupId, data } = props ?? {};

    return updateGroup(groupId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGroup>>
>;
export type UpdateGroupMutationBody = BodyType<UpdateGroupDto>;
export type UpdateGroupMutationError = ErrorType<unknown>;

export const useUpdateGroup = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateGroup>>,
      TError,
      { groupId: string; data: BodyType<UpdateGroupDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateGroup>>,
  TError,
  { groupId: string; data: BodyType<UpdateGroupDto> },
  TContext
> => {
  const mutationOptions = getUpdateGroupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteGroup = (
  groupId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteGroup200AllOf>(
    { url: `/api/v1/groups/${groupId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteGroupMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGroup>>,
    TError,
    { groupId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGroup>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationKey = ['deleteGroup'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGroup>>,
    { groupId: string }
  > = props => {
    const { groupId } = props ?? {};

    return deleteGroup(groupId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteGroup>>
>;

export type DeleteGroupMutationError = ErrorType<unknown>;

export const useDeleteGroup = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteGroup>>,
      TError,
      { groupId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteGroup>>,
  TError,
  { groupId: string },
  TContext
> => {
  const mutationOptions = getDeleteGroupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeGroups = (
  groupIds: string[],
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveGroups200AllOf>(
    { url: `/api/v1/groups/${groupIds}`, method: 'PATCH' },
    options,
  );
};

export const getRemoveGroupsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeGroups>>,
    TError,
    { groupIds: string[] },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeGroups>>,
  TError,
  { groupIds: string[] },
  TContext
> => {
  const mutationKey = ['removeGroups'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeGroups>>,
    { groupIds: string[] }
  > = props => {
    const { groupIds } = props ?? {};

    return removeGroups(groupIds, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveGroupsMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeGroups>>
>;

export type RemoveGroupsMutationError = ErrorType<unknown>;

export const useRemoveGroups = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeGroups>>,
      TError,
      { groupIds: string[] },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeGroups>>,
  TError,
  { groupIds: string[] },
  TContext
> => {
  const mutationOptions = getRemoveGroupsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createSpace = (
  createSpaceDto: BodyType<CreateSpaceDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateSpace200AllOf>(
    {
      url: `/api/v1/spaces`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSpaceDto,
      signal,
    },
    options,
  );
};

export const getCreateSpaceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSpace>>,
    TError,
    { data: BodyType<CreateSpaceDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSpace>>,
  TError,
  { data: BodyType<CreateSpaceDto> },
  TContext
> => {
  const mutationKey = ['createSpace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSpace>>,
    { data: BodyType<CreateSpaceDto> }
  > = props => {
    const { data } = props ?? {};

    return createSpace(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSpaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSpace>>
>;
export type CreateSpaceMutationBody = BodyType<CreateSpaceDto>;
export type CreateSpaceMutationError = ErrorType<void>;

export const useCreateSpace = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSpace>>,
      TError,
      { data: BodyType<CreateSpaceDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSpace>>,
  TError,
  { data: BodyType<CreateSpaceDto> },
  TContext
> => {
  const mutationOptions = getCreateSpaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSpacesByQuery = (
  params?: GetSpacesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSpacesByQuery200AllOf>(
    { url: `/api/v1/spaces`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSpacesByQueryQueryKey = (
  params?: GetSpacesByQueryParams,
) => {
  return [`/api/v1/spaces`, ...(params ? [params] : [])] as const;
};

export const getGetSpacesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpacesByQuery>>
  > = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSpacesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpacesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpacesByQuery>>
>;
export type GetSpacesByQueryQueryError = ErrorType<void>;

export function useGetSpacesByQuery<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSpacesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpacesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpacesByQuery<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpacesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSpacesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpacesByQuery<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpacesByQuery<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpacesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpacesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpacesByQuery>>
  > = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSpacesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpacesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpacesByQuery>>
>;
export type GetSpacesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetSpacesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSpacesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpacesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpacesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpacesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSpacesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpacesByQuerySuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpacesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSpacesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSpacesByQuery>>
  > = ({ signal }) => getSpacesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSpacesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpacesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpacesByQuery>>
>;
export type GetSpacesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSpacesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSpacesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpacesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpacesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpacesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpacesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSpacesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpacesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpacesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSpace = (
  spaceId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSpace200AllOf>(
    { url: `/api/v1/spaces/${spaceId}`, method: 'GET', signal },
    options,
  );
};

export const getGetSpaceQueryKey = (spaceId: string) => {
  return [`/api/v1/spaces/${spaceId}`] as const;
};

export const getGetSpaceQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({
    signal,
  }) => getSpace(spaceId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!spaceId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetSpaceQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpace>>
>;
export type GetSpaceQueryError = ErrorType<void>;

export function useGetSpace<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          Awaited<ReturnType<typeof getSpace>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpace<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSpace>>,
          TError,
          Awaited<ReturnType<typeof getSpace>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpace<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpace<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSpace>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceQueryOptions(spaceId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpaceSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({
    signal,
  }) => getSpace(spaceId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSpace>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpace>>
>;
export type GetSpaceSuspenseQueryError = ErrorType<void>;

export function useGetSpaceSuspense<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceSuspense<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceSuspense<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceSuspense<
  TData = Awaited<ReturnType<typeof getSpace>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceSuspenseQueryOptions(spaceId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSpaceSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSpaceQueryKey(spaceId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSpace>>> = ({
    signal,
  }) => getSpace(spaceId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSpace>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSpaceSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSpace>>
>;
export type GetSpaceSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSpaceSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSpaceSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSpaceSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSpace>>>,
  TError = ErrorType<void>,
>(
  spaceId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSpace>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSpaceSuspenseInfiniteQueryOptions(
    spaceId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateSpace = (
  spaceId: string,
  updateSpaceDto: BodyType<UpdateSpaceDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateSpace200AllOf>(
    {
      url: `/api/v1/spaces/${spaceId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateSpaceDto,
    },
    options,
  );
};

export const getUpdateSpaceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSpace>>,
    TError,
    { spaceId: string; data: BodyType<UpdateSpaceDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSpace>>,
  TError,
  { spaceId: string; data: BodyType<UpdateSpaceDto> },
  TContext
> => {
  const mutationKey = ['updateSpace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSpace>>,
    { spaceId: string; data: BodyType<UpdateSpaceDto> }
  > = props => {
    const { spaceId, data } = props ?? {};

    return updateSpace(spaceId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSpaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSpace>>
>;
export type UpdateSpaceMutationBody = BodyType<UpdateSpaceDto>;
export type UpdateSpaceMutationError = ErrorType<void>;

export const useUpdateSpace = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSpace>>,
      TError,
      { spaceId: string; data: BodyType<UpdateSpaceDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSpace>>,
  TError,
  { spaceId: string; data: BodyType<UpdateSpaceDto> },
  TContext
> => {
  const mutationOptions = getUpdateSpaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteSpace = (
  spaceId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteSpace200AllOf>(
    { url: `/api/v1/spaces/${spaceId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteSpaceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSpace>>,
    TError,
    { spaceId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSpace>>,
  TError,
  { spaceId: string },
  TContext
> => {
  const mutationKey = ['deleteSpace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSpace>>,
    { spaceId: string }
  > = props => {
    const { spaceId } = props ?? {};

    return deleteSpace(spaceId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSpaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSpace>>
>;

export type DeleteSpaceMutationError = ErrorType<void>;

export const useDeleteSpace = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSpace>>,
      TError,
      { spaceId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSpace>>,
  TError,
  { spaceId: string },
  TContext
> => {
  const mutationOptions = getDeleteSpaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeSpace = (
  spaceId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveSpace200AllOf>(
    { url: `/api/v1/spaces/${spaceId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveSpaceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeSpace>>,
    TError,
    { spaceId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeSpace>>,
  TError,
  { spaceId: string },
  TContext
> => {
  const mutationKey = ['removeSpace'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeSpace>>,
    { spaceId: string }
  > = props => {
    const { spaceId } = props ?? {};

    return removeSpace(spaceId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveSpaceMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeSpace>>
>;

export type RemoveSpaceMutationError = ErrorType<void>;

export const useRemoveSpace = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeSpace>>,
      TError,
      { spaceId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeSpace>>,
  TError,
  { spaceId: string },
  TContext
> => {
  const mutationOptions = getRemoveSpaceMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getGroundsByUserId = (
  userId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetGroundsByUserId200AllOf>(
    { url: `/api/v1/users/${userId}/grounds`, method: 'GET', signal },
    options,
  );
};

export const getGetGroundsByUserIdQueryKey = (userId: string) => {
  return [`/api/v1/users/${userId}/grounds`] as const;
};

export const getGetGroundsByUserIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroundsByUserIdQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroundsByUserId>>
  > = ({ signal }) => getGroundsByUserId(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGroundsByUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundsByUserIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroundsByUserId>>
>;
export type GetGroundsByUserIdQueryError = ErrorType<void>;

export function useGetGroundsByUserId<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundsByUserId>>,
          TError,
          Awaited<ReturnType<typeof getGroundsByUserId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByUserId<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroundsByUserId>>,
          TError,
          Awaited<ReturnType<typeof getGroundsByUserId>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByUserId<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundsByUserId<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundsByUserIdQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroundsByUserIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroundsByUserIdQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroundsByUserId>>
  > = ({ signal }) => getGroundsByUserId(userId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGroundsByUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundsByUserIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroundsByUserId>>
>;
export type GetGroundsByUserIdSuspenseQueryError = ErrorType<void>;

export function useGetGroundsByUserIdSuspense<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByUserIdSuspense<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByUserIdSuspense<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundsByUserIdSuspense<
  TData = Awaited<ReturnType<typeof getGroundsByUserId>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundsByUserIdSuspenseQueryOptions(
    userId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetGroundsByUserIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByUserId>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGroundsByUserIdQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGroundsByUserId>>
  > = ({ signal }) => getGroundsByUserId(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getGroundsByUserId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroundsByUserIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGroundsByUserId>>
>;
export type GetGroundsByUserIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetGroundsByUserIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByUserId>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByUserIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByUserId>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGroundsByUserIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByUserId>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGroundsByUserIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getGroundsByUserId>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getGroundsByUserId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGroundsByUserIdSuspenseInfiniteQueryOptions(
    userId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createUser = (
  createUserDto: BodyType<CreateUserDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateUser200AllOf>(
    {
      url: `/api/v1/users`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createUserDto,
      signal,
    },
    options,
  );
};

export const getCreateUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: BodyType<CreateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserDto> },
  TContext
> => {
  const mutationKey = ['createUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    { data: BodyType<CreateUserDto> }
  > = props => {
    const { data } = props ?? {};

    return createUser(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>;
export type CreateUserMutationBody = BodyType<CreateUserDto>;
export type CreateUserMutationError = ErrorType<void>;

export const useCreateUser = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: BodyType<CreateUserDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: BodyType<CreateUserDto> },
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getUsersByQuery = (
  params?: GetUsersByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUsersByQuery200AllOf>(
    { url: `/api/v1/users`, method: 'GET', params, signal },
    options,
  );
};

export const getGetUsersByQueryQueryKey = (params?: GetUsersByQueryParams) => {
  return [`/api/v1/users`, ...(params ? [params] : [])] as const;
};

export const getGetUsersByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({
    signal,
  }) => getUsersByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsersByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsersByQuery>>
>;
export type GetUsersByQueryQueryError = ErrorType<void>;

export function useGetUsersByQuery<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetUsersByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          Awaited<ReturnType<typeof getUsersByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersByQuery<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersByQuery>>,
          TError,
          Awaited<ReturnType<typeof getUsersByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersByQuery<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUsersByQuery<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsersByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUsersByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({
    signal,
  }) => getUsersByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUsersByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsersByQuery>>
>;
export type GetUsersByQuerySuspenseQueryError = ErrorType<void>;

export function useGetUsersByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetUsersByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUsersByQuerySuspense<
  TData = Awaited<ReturnType<typeof getUsersByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsersByQuerySuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUsersByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersByQuery>>> = ({
    signal,
  }) => getUsersByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUsersByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsersByQuery>>
>;
export type GetUsersByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetUsersByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetUsersByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUsersByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUsersByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetUsersByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUsersByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsersByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getUser = (
  userId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetUser200AllOf>(
    { url: `/api/v1/users/${userId}`, method: 'GET', signal },
    options,
  );
};

export const getGetUserQueryKey = (userId: string) => {
  return [`/api/v1/users/${userId}`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserQueryError = ErrorType<void>;

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserQueryOptions(userId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(userId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserSuspenseQueryError = ErrorType<void>;

export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserSuspense<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserSuspenseQueryOptions(userId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey(userId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetUserSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUserSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUserSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUser>>>,
  TError = ErrorType<void>,
>(
  userId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getUser>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUserSuspenseInfiniteQueryOptions(userId, options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateUser = (
  userId: string,
  updateUserDto: BodyType<UpdateUserDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateUser200AllOf>(
    {
      url: `/api/v1/users/${userId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateUserDto,
    },
    options,
  );
};

export const getUpdateUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { userId: string; data: BodyType<UpdateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { userId: string; data: BodyType<UpdateUserDto> },
  TContext
> => {
  const mutationKey = ['updateUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { userId: string; data: BodyType<UpdateUserDto> }
  > = props => {
    const { userId, data } = props ?? {};

    return updateUser(userId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>;
export type UpdateUserMutationBody = BodyType<UpdateUserDto>;
export type UpdateUserMutationError = ErrorType<void>;

export const useUpdateUser = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { userId: string; data: BodyType<UpdateUserDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { userId: string; data: BodyType<UpdateUserDto> },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteUser = (
  userId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteUser200AllOf>(
    { url: `/api/v1/users/${userId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { userId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationKey = ['deleteUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { userId: string }
  > = props => {
    const { userId } = props ?? {};

    return deleteUser(userId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>;

export type DeleteUserMutationError = ErrorType<void>;

export const useDeleteUser = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { userId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeUsers = (
  removeUsersBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveUsers200AllOf>(
    {
      url: `/api/v1/users/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeUsersBody,
    },
    options,
  );
};

export const getRemoveUsersMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUsers>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUsers>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeUsers'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUsers>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeUsers(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUsersMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUsers>>
>;
export type RemoveUsersMutationBody = BodyType<string[]>;
export type RemoveUsersMutationError = ErrorType<void>;

export const useRemoveUsers = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeUsers>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeUsers>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveUsersMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeUser = (
  userId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveUser200AllOf>(
    { url: `/api/v1/users/${userId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUser>>,
    TError,
    { userId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationKey = ['removeUser'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUser>>,
    { userId: string }
  > = props => {
    const { userId } = props ?? {};

    return removeUser(userId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUser>>
>;

export type RemoveUserMutationError = ErrorType<void>;

export const useRemoveUser = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeUser>>,
      TError,
      { userId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeUser>>,
  TError,
  { userId: string },
  TContext
> => {
  const mutationOptions = getRemoveUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createRole = (
  createRoleDto: BodyType<CreateRoleDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateRole200AllOf>(
    {
      url: `/api/v1/roles`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createRoleDto,
      signal,
    },
    options,
  );
};

export const getCreateRoleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRole>>,
    TError,
    { data: BodyType<CreateRoleDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRole>>,
  TError,
  { data: BodyType<CreateRoleDto> },
  TContext
> => {
  const mutationKey = ['createRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRole>>,
    { data: BodyType<CreateRoleDto> }
  > = props => {
    const { data } = props ?? {};

    return createRole(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRole>>
>;
export type CreateRoleMutationBody = BodyType<CreateRoleDto>;
export type CreateRoleMutationError = ErrorType<void>;

export const useCreateRole = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRole>>,
      TError,
      { data: BodyType<CreateRoleDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createRole>>,
  TError,
  { data: BodyType<CreateRoleDto> },
  TContext
> => {
  const mutationOptions = getCreateRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getRolesByQuery = (
  params?: GetRolesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetRolesByQuery200AllOf>(
    { url: `/api/v1/roles`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRolesByQueryQueryKey = (params?: GetRolesByQueryParams) => {
  return [`/api/v1/roles`, ...(params ? [params] : [])] as const;
};

export const getGetRolesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({
    signal,
  }) => getRolesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRolesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRolesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRolesByQuery>>
>;
export type GetRolesByQueryQueryError = ErrorType<void>;

export function useGetRolesByQuery<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetRolesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRolesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRolesByQuery<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRolesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRolesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRolesByQuery<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRolesByQuery<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRolesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRolesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({
    signal,
  }) => getRolesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRolesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRolesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRolesByQuery>>
>;
export type GetRolesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetRolesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetRolesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRolesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRolesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRolesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRolesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRolesByQuerySuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRolesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRolesByQueryQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRolesByQuery>>> = ({
    signal,
  }) => getRolesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getRolesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRolesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRolesByQuery>>
>;
export type GetRolesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetRolesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetRolesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRolesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRolesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRolesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRolesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRolesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRolesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRolesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRole = (
  roleId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetRole200AllOf>(
    { url: `/api/v1/roles/${roleId}`, method: 'GET', signal },
    options,
  );
};

export const getGetRoleQueryKey = (roleId: string) => {
  return [`/api/v1/roles/${roleId}`] as const;
};

export const getGetRoleQueryOptions = <
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({
    signal,
  }) => getRole(roleId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!roleId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetRoleQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRole>>
>;
export type GetRoleQueryError = ErrorType<void>;

export function useGetRole<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          Awaited<ReturnType<typeof getRole>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRole<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRole>>,
          TError,
          Awaited<ReturnType<typeof getRole>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRole<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRole<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRole>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoleQueryOptions(roleId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRoleSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({
    signal,
  }) => getRole(roleId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRole>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoleSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRole>>
>;
export type GetRoleSuspenseQueryError = ErrorType<void>;

export function useGetRoleSuspense<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoleSuspense<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoleSuspense<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoleSuspense<
  TData = Awaited<ReturnType<typeof getRole>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoleSuspenseQueryOptions(roleId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRoleSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRoleQueryKey(roleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRole>>> = ({
    signal,
  }) => getRole(roleId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getRole>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoleSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRole>>
>;
export type GetRoleSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetRoleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoleSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRole>>>,
  TError = ErrorType<void>,
>(
  roleId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRole>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoleSuspenseInfiniteQueryOptions(roleId, options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateRole = (
  roleId: string,
  updateRoleDto: BodyType<UpdateRoleDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateRole200AllOf>(
    {
      url: `/api/v1/roles/${roleId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateRoleDto,
    },
    options,
  );
};

export const getUpdateRoleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRole>>,
    TError,
    { roleId: string; data: BodyType<UpdateRoleDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  { roleId: string; data: BodyType<UpdateRoleDto> },
  TContext
> => {
  const mutationKey = ['updateRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRole>>,
    { roleId: string; data: BodyType<UpdateRoleDto> }
  > = props => {
    const { roleId, data } = props ?? {};

    return updateRole(roleId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRole>>
>;
export type UpdateRoleMutationBody = BodyType<UpdateRoleDto>;
export type UpdateRoleMutationError = ErrorType<void>;

export const useUpdateRole = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRole>>,
      TError,
      { roleId: string; data: BodyType<UpdateRoleDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  { roleId: string; data: BodyType<UpdateRoleDto> },
  TContext
> => {
  const mutationOptions = getUpdateRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteRole = (
  roleId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteRole200AllOf>(
    { url: `/api/v1/roles/${roleId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteRoleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRole>>,
    TError,
    { roleId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationKey = ['deleteRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRole>>,
    { roleId: string }
  > = props => {
    const { roleId } = props ?? {};

    return deleteRole(roleId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRole>>
>;

export type DeleteRoleMutationError = ErrorType<void>;

export const useDeleteRole = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRole>>,
      TError,
      { roleId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationOptions = getDeleteRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeRole = (
  roleId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveRole200AllOf>(
    { url: `/api/v1/roles/${roleId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveRoleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeRole>>,
    TError,
    { roleId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationKey = ['removeRole'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeRole>>,
    { roleId: string }
  > = props => {
    const { roleId } = props ?? {};

    return removeRole(roleId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeRole>>
>;

export type RemoveRoleMutationError = ErrorType<void>;

export const useRemoveRole = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeRole>>,
      TError,
      { roleId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeRole>>,
  TError,
  { roleId: string },
  TContext
> => {
  const mutationOptions = getRemoveRoleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createAction = (
  createActionDto: BodyType<CreateActionDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateAction200AllOf>(
    {
      url: `/api/v1/actions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createActionDto,
      signal,
    },
    options,
  );
};

export const getCreateActionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAction>>,
    TError,
    { data: BodyType<CreateActionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAction>>,
  TError,
  { data: BodyType<CreateActionDto> },
  TContext
> => {
  const mutationKey = ['createAction'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAction>>,
    { data: BodyType<CreateActionDto> }
  > = props => {
    const { data } = props ?? {};

    return createAction(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateActionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAction>>
>;
export type CreateActionMutationBody = BodyType<CreateActionDto>;
export type CreateActionMutationError = ErrorType<void>;

export const useCreateAction = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAction>>,
      TError,
      { data: BodyType<CreateActionDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAction>>,
  TError,
  { data: BodyType<CreateActionDto> },
  TContext
> => {
  const mutationOptions = getCreateActionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getActionsByQuery = (
  params?: GetActionsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetActionsByQuery200AllOf>(
    { url: `/api/v1/actions`, method: 'GET', params, signal },
    options,
  );
};

export const getGetActionsByQueryQueryKey = (
  params?: GetActionsByQueryParams,
) => {
  return [`/api/v1/actions`, ...(params ? [params] : [])] as const;
};

export const getGetActionsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActionsByQuery>>
  > = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActionsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActionsByQuery>>
>;
export type GetActionsByQueryQueryError = ErrorType<void>;

export function useGetActionsByQuery<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetActionsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getActionsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionsByQuery<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getActionsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionsByQuery<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActionsByQuery<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActionsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetActionsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActionsByQuery>>
  > = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getActionsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActionsByQuery>>
>;
export type GetActionsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetActionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetActionsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getActionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActionsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetActionsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetActionsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActionsByQuery>>
  > = ({ signal }) => getActionsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getActionsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActionsByQuery>>
>;
export type GetActionsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetActionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetActionsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getActionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetActionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getActionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActionsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAction = (
  actionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetAction200AllOf>(
    { url: `/api/v1/actions/${actionId}`, method: 'GET', signal },
    options,
  );
};

export const getGetActionQueryKey = (actionId: string) => {
  return [`/api/v1/actions/${actionId}`] as const;
};

export const getGetActionQueryOptions = <
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({
    signal,
  }) => getAction(actionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!actionId,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetActionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAction>>
>;
export type GetActionQueryError = ErrorType<void>;

export function useGetAction<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          Awaited<ReturnType<typeof getAction>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAction<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAction>>,
          TError,
          Awaited<ReturnType<typeof getAction>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAction<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAction<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAction>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActionQueryOptions(actionId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetActionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({
    signal,
  }) => getAction(actionId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAction>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAction>>
>;
export type GetActionSuspenseQueryError = ErrorType<void>;

export function useGetActionSuspense<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionSuspense<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionSuspense<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActionSuspense<
  TData = Awaited<ReturnType<typeof getAction>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActionSuspenseQueryOptions(actionId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetActionSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActionQueryKey(actionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAction>>> = ({
    signal,
  }) => getAction(actionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAction>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActionSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAction>>
>;
export type GetActionSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetActionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAction>>>,
  TError = ErrorType<void>,
>(
  actionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAction>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActionSuspenseInfiniteQueryOptions(
    actionId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateAction = (
  actionId: string,
  updateActionDto: BodyType<UpdateActionDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateAction200AllOf>(
    {
      url: `/api/v1/actions/${actionId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateActionDto,
    },
    options,
  );
};

export const getUpdateActionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAction>>,
    TError,
    { actionId: string; data: BodyType<UpdateActionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAction>>,
  TError,
  { actionId: string; data: BodyType<UpdateActionDto> },
  TContext
> => {
  const mutationKey = ['updateAction'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAction>>,
    { actionId: string; data: BodyType<UpdateActionDto> }
  > = props => {
    const { actionId, data } = props ?? {};

    return updateAction(actionId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateActionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAction>>
>;
export type UpdateActionMutationBody = BodyType<UpdateActionDto>;
export type UpdateActionMutationError = ErrorType<void>;

export const useUpdateAction = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAction>>,
      TError,
      { actionId: string; data: BodyType<UpdateActionDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateAction>>,
  TError,
  { actionId: string; data: BodyType<UpdateActionDto> },
  TContext
> => {
  const mutationOptions = getUpdateActionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteAction = (
  actionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteAction200AllOf>(
    { url: `/api/v1/actions/${actionId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteActionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAction>>,
    TError,
    { actionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAction>>,
  TError,
  { actionId: string },
  TContext
> => {
  const mutationKey = ['deleteAction'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAction>>,
    { actionId: string }
  > = props => {
    const { actionId } = props ?? {};

    return deleteAction(actionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteActionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAction>>
>;

export type DeleteActionMutationError = ErrorType<void>;

export const useDeleteAction = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAction>>,
      TError,
      { actionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAction>>,
  TError,
  { actionId: string },
  TContext
> => {
  const mutationOptions = getDeleteActionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeActions = (
  removeActionsBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveActions200AllOf>(
    {
      url: `/api/v1/actions/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeActionsBody,
    },
    options,
  );
};

export const getRemoveActionsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeActions>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeActions>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeActions'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeActions>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeActions(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveActionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeActions>>
>;
export type RemoveActionsMutationBody = BodyType<string[]>;
export type RemoveActionsMutationError = ErrorType<void>;

export const useRemoveActions = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeActions>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeActions>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveActionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeAction = (
  actionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveAction200AllOf>(
    { url: `/api/v1/actions/${actionId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveActionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeAction>>,
    TError,
    { actionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeAction>>,
  TError,
  { actionId: string },
  TContext
> => {
  const mutationKey = ['removeAction'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeAction>>,
    { actionId: string }
  > = props => {
    const { actionId } = props ?? {};

    return removeAction(actionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveActionMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeAction>>
>;

export type RemoveActionMutationError = ErrorType<void>;

export const useRemoveAction = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeAction>>,
      TError,
      { actionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeAction>>,
  TError,
  { actionId: string },
  TContext
> => {
  const mutationOptions = getRemoveActionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createAbility = (
  createAbilityDto: BodyType<CreateAbilityDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateAbility200AllOf>(
    {
      url: `/api/v1/abilities`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createAbilityDto,
      signal,
    },
    options,
  );
};

export const getCreateAbilityMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAbility>>,
    TError,
    { data: BodyType<CreateAbilityDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAbility>>,
  TError,
  { data: BodyType<CreateAbilityDto> },
  TContext
> => {
  const mutationKey = ['createAbility'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAbility>>,
    { data: BodyType<CreateAbilityDto> }
  > = props => {
    const { data } = props ?? {};

    return createAbility(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateAbilityMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAbility>>
>;
export type CreateAbilityMutationBody = BodyType<CreateAbilityDto>;
export type CreateAbilityMutationError = ErrorType<void>;

export const useCreateAbility = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createAbility>>,
      TError,
      { data: BodyType<CreateAbilityDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createAbility>>,
  TError,
  { data: BodyType<CreateAbilityDto> },
  TContext
> => {
  const mutationOptions = getCreateAbilityMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getAbilitiesByQuery = (
  params?: GetAbilitiesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetAbilitiesByQuery200AllOf>(
    { url: `/api/v1/abilities`, method: 'GET', params, signal },
    options,
  );
};

export const getGetAbilitiesByQueryQueryKey = (
  params?: GetAbilitiesByQueryParams,
) => {
  return [`/api/v1/abilities`, ...(params ? [params] : [])] as const;
};

export const getGetAbilitiesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAbilitiesByQuery>>
  > = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAbilitiesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAbilitiesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAbilitiesByQuery>>
>;
export type GetAbilitiesByQueryQueryError = ErrorType<void>;

export function useGetAbilitiesByQuery<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetAbilitiesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbilitiesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getAbilitiesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitiesByQuery<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbilitiesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getAbilitiesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitiesByQuery<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAbilitiesByQuery<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAbilitiesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAbilitiesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAbilitiesByQuery>>
  > = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAbilitiesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAbilitiesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAbilitiesByQuery>>
>;
export type GetAbilitiesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetAbilitiesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetAbilitiesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitiesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitiesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAbilitiesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getAbilitiesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAbilitiesByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAbilitiesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAbilitiesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAbilitiesByQuery>>
  > = ({ signal }) => getAbilitiesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAbilitiesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAbilitiesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAbilitiesByQuery>>
>;
export type GetAbilitiesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetAbilitiesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetAbilitiesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitiesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitiesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAbilitiesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbilitiesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetAbilitiesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbilitiesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAbilitiesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getAbility = (
  abilityId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetAbility200AllOf>(
    { url: `/api/v1/abilities/${abilityId}`, method: 'GET', signal },
    options,
  );
};

export const getGetAbilityQueryKey = (abilityId: string) => {
  return [`/api/v1/abilities/${abilityId}`] as const;
};

export const getGetAbilityQueryOptions = <
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({
    signal,
  }) => getAbility(abilityId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!abilityId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAbility>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAbilityQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAbility>>
>;
export type GetAbilityQueryError = ErrorType<void>;

export function useGetAbility<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbility>>,
          TError,
          Awaited<ReturnType<typeof getAbility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbility<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAbility>>,
          TError,
          Awaited<ReturnType<typeof getAbility>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbility<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAbility<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAbility>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAbilityQueryOptions(abilityId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAbilitySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({
    signal,
  }) => getAbility(abilityId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAbility>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAbilitySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAbility>>
>;
export type GetAbilitySuspenseQueryError = ErrorType<void>;

export function useGetAbilitySuspense<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitySuspense<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitySuspense<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAbilitySuspense<
  TData = Awaited<ReturnType<typeof getAbility>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAbilitySuspenseQueryOptions(abilityId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetAbilitySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAbilityQueryKey(abilityId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAbility>>> = ({
    signal,
  }) => getAbility(abilityId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAbility>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAbilitySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAbility>>
>;
export type GetAbilitySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetAbilitySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAbilitySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAbilitySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getAbility>>>,
  TError = ErrorType<void>,
>(
  abilityId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAbility>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAbilitySuspenseInfiniteQueryOptions(
    abilityId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateAbility = (
  abilityId: string,
  updateAbilityDto: BodyType<UpdateAbilityDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateAbility200AllOf>(
    {
      url: `/api/v1/abilities/${abilityId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateAbilityDto,
    },
    options,
  );
};

export const getUpdateAbilityMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAbility>>,
    TError,
    { abilityId: string; data: BodyType<UpdateAbilityDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAbility>>,
  TError,
  { abilityId: string; data: BodyType<UpdateAbilityDto> },
  TContext
> => {
  const mutationKey = ['updateAbility'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAbility>>,
    { abilityId: string; data: BodyType<UpdateAbilityDto> }
  > = props => {
    const { abilityId, data } = props ?? {};

    return updateAbility(abilityId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAbilityMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateAbility>>
>;
export type UpdateAbilityMutationBody = BodyType<UpdateAbilityDto>;
export type UpdateAbilityMutationError = ErrorType<void>;

export const useUpdateAbility = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAbility>>,
      TError,
      { abilityId: string; data: BodyType<UpdateAbilityDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateAbility>>,
  TError,
  { abilityId: string; data: BodyType<UpdateAbilityDto> },
  TContext
> => {
  const mutationOptions = getUpdateAbilityMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteAbility = (
  abilityId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteAbility200AllOf>(
    { url: `/api/v1/abilities/${abilityId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteAbilityMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAbility>>,
    TError,
    { abilityId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAbility>>,
  TError,
  { abilityId: string },
  TContext
> => {
  const mutationKey = ['deleteAbility'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAbility>>,
    { abilityId: string }
  > = props => {
    const { abilityId } = props ?? {};

    return deleteAbility(abilityId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteAbilityMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAbility>>
>;

export type DeleteAbilityMutationError = ErrorType<void>;

export const useDeleteAbility = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteAbility>>,
      TError,
      { abilityId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAbility>>,
  TError,
  { abilityId: string },
  TContext
> => {
  const mutationOptions = getDeleteAbilityMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeAbilities = (
  removeAbilitiesBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveAbilities200AllOf>(
    {
      url: `/api/v1/abilities/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeAbilitiesBody,
    },
    options,
  );
};

export const getRemoveAbilitiesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeAbilities>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeAbilities>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeAbilities'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeAbilities>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeAbilities(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveAbilitiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeAbilities>>
>;
export type RemoveAbilitiesMutationBody = BodyType<string[]>;
export type RemoveAbilitiesMutationError = ErrorType<void>;

export const useRemoveAbilities = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeAbilities>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeAbilities>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveAbilitiesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeAbility = (
  abilityId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveAbility200AllOf>(
    { url: `/api/v1/abilities/${abilityId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveAbilityMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeAbility>>,
    TError,
    { abilityId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeAbility>>,
  TError,
  { abilityId: string },
  TContext
> => {
  const mutationKey = ['removeAbility'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeAbility>>,
    { abilityId: string }
  > = props => {
    const { abilityId } = props ?? {};

    return removeAbility(abilityId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveAbilityMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeAbility>>
>;

export type RemoveAbilityMutationError = ErrorType<void>;

export const useRemoveAbility = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeAbility>>,
      TError,
      { abilityId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeAbility>>,
  TError,
  { abilityId: string },
  TContext
> => {
  const mutationOptions = getRemoveAbilityMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createSubject = (
  createSubjectDto: BodyType<CreateSubjectDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateSubject200AllOf>(
    {
      url: `/api/v1/subjects`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSubjectDto,
      signal,
    },
    options,
  );
};

export const getCreateSubjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSubject>>,
    TError,
    { data: BodyType<CreateSubjectDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSubject>>,
  TError,
  { data: BodyType<CreateSubjectDto> },
  TContext
> => {
  const mutationKey = ['createSubject'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSubject>>,
    { data: BodyType<CreateSubjectDto> }
  > = props => {
    const { data } = props ?? {};

    return createSubject(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSubject>>
>;
export type CreateSubjectMutationBody = BodyType<CreateSubjectDto>;
export type CreateSubjectMutationError = ErrorType<void>;

export const useCreateSubject = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSubject>>,
      TError,
      { data: BodyType<CreateSubjectDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSubject>>,
  TError,
  { data: BodyType<CreateSubjectDto> },
  TContext
> => {
  const mutationOptions = getCreateSubjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSubjectsByQuery = (
  params?: GetSubjectsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSubjectsByQuery200AllOf>(
    { url: `/api/v1/subjects`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSubjectsByQueryQueryKey = (
  params?: GetSubjectsByQueryParams,
) => {
  return [`/api/v1/subjects`, ...(params ? [params] : [])] as const;
};

export const getGetSubjectsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubjectsByQuery>>
  > = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubjectsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubjectsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubjectsByQuery>>
>;
export type GetSubjectsByQueryQueryError = ErrorType<void>;

export function useGetSubjectsByQuery<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSubjectsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSubjectsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectsByQuery<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubjectsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSubjectsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectsByQuery<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSubjectsByQuery<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubjectsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSubjectsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubjectsByQuery>>
  > = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSubjectsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubjectsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubjectsByQuery>>
>;
export type GetSubjectsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetSubjectsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSubjectsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSubjectsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSubjectsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubjectsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSubjectsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSubjectsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSubjectsByQuery>>
  > = ({ signal }) => getSubjectsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSubjectsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubjectsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubjectsByQuery>>
>;
export type GetSubjectsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSubjectsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSubjectsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSubjectsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubjectsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSubjectsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubjectsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubjectsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSubject = (
  subjectId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSubject200AllOf>(
    { url: `/api/v1/subjects/${subjectId}`, method: 'GET', signal },
    options,
  );
};

export const getGetSubjectQueryKey = (subjectId: string) => {
  return [`/api/v1/subjects/${subjectId}`] as const;
};

export const getGetSubjectQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({
    signal,
  }) => getSubject(subjectId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!subjectId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSubject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubjectQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubject>>
>;
export type GetSubjectQueryError = ErrorType<void>;

export function useGetSubject<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubject<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSubject>>,
          TError,
          Awaited<ReturnType<typeof getSubject>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubject<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSubject<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSubject>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubjectQueryOptions(subjectId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSubjectSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({
    signal,
  }) => getSubject(subjectId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSubject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubjectSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubject>>
>;
export type GetSubjectSuspenseQueryError = ErrorType<void>;

export function useGetSubjectSuspense<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectSuspense<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectSuspense<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSubjectSuspense<
  TData = Awaited<ReturnType<typeof getSubject>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubjectSuspenseQueryOptions(subjectId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSubjectSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSubjectQueryKey(subjectId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSubject>>> = ({
    signal,
  }) => getSubject(subjectId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSubject>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSubjectSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSubject>>
>;
export type GetSubjectSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSubjectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSubjectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSubjectSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSubject>>>,
  TError = ErrorType<void>,
>(
  subjectId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSubject>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSubjectSuspenseInfiniteQueryOptions(
    subjectId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateSubject = (
  subjectId: string,
  updateSubjectDto: BodyType<UpdateSubjectDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateSubject200AllOf>(
    {
      url: `/api/v1/subjects/${subjectId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateSubjectDto,
    },
    options,
  );
};

export const getUpdateSubjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSubject>>,
    TError,
    { subjectId: string; data: BodyType<UpdateSubjectDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSubject>>,
  TError,
  { subjectId: string; data: BodyType<UpdateSubjectDto> },
  TContext
> => {
  const mutationKey = ['updateSubject'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSubject>>,
    { subjectId: string; data: BodyType<UpdateSubjectDto> }
  > = props => {
    const { subjectId, data } = props ?? {};

    return updateSubject(subjectId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSubject>>
>;
export type UpdateSubjectMutationBody = BodyType<UpdateSubjectDto>;
export type UpdateSubjectMutationError = ErrorType<void>;

export const useUpdateSubject = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSubject>>,
      TError,
      { subjectId: string; data: BodyType<UpdateSubjectDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSubject>>,
  TError,
  { subjectId: string; data: BodyType<UpdateSubjectDto> },
  TContext
> => {
  const mutationOptions = getUpdateSubjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteSubject = (
  subjectId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteSubject200AllOf>(
    { url: `/api/v1/subjects/${subjectId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteSubjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSubject>>,
    TError,
    { subjectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSubject>>,
  TError,
  { subjectId: string },
  TContext
> => {
  const mutationKey = ['deleteSubject'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSubject>>,
    { subjectId: string }
  > = props => {
    const { subjectId } = props ?? {};

    return deleteSubject(subjectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSubject>>
>;

export type DeleteSubjectMutationError = ErrorType<void>;

export const useDeleteSubject = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSubject>>,
      TError,
      { subjectId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSubject>>,
  TError,
  { subjectId: string },
  TContext
> => {
  const mutationOptions = getDeleteSubjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeSubjects = (
  removeSubjectsBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveSubjects200AllOf>(
    {
      url: `/api/v1/subjects/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeSubjectsBody,
    },
    options,
  );
};

export const getRemoveSubjectsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeSubjects>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeSubjects>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeSubjects'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeSubjects>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeSubjects(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveSubjectsMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeSubjects>>
>;
export type RemoveSubjectsMutationBody = BodyType<string[]>;
export type RemoveSubjectsMutationError = ErrorType<void>;

export const useRemoveSubjects = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeSubjects>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeSubjects>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveSubjectsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeSubject = (
  subjectId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveSubject200AllOf>(
    { url: `/api/v1/subjects/${subjectId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveSubjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeSubject>>,
    TError,
    { subjectId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeSubject>>,
  TError,
  { subjectId: string },
  TContext
> => {
  const mutationKey = ['removeSubject'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeSubject>>,
    { subjectId: string }
  > = props => {
    const { subjectId } = props ?? {};

    return removeSubject(subjectId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveSubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeSubject>>
>;

export type RemoveSubjectMutationError = ErrorType<void>;

export const useRemoveSubject = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeSubject>>,
      TError,
      { subjectId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeSubject>>,
  TError,
  { subjectId: string },
  TContext
> => {
  const mutationOptions = getRemoveSubjectMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createTimeline = (
  createTimelineDto: BodyType<CreateTimelineDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateTimeline200AllOf>(
    {
      url: `/api/v1/timelines`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createTimelineDto,
      signal,
    },
    options,
  );
};

export const getCreateTimelineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTimeline>>,
    TError,
    { data: BodyType<CreateTimelineDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTimeline>>,
  TError,
  { data: BodyType<CreateTimelineDto> },
  TContext
> => {
  const mutationKey = ['createTimeline'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTimeline>>,
    { data: BodyType<CreateTimelineDto> }
  > = props => {
    const { data } = props ?? {};

    return createTimeline(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTimelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTimeline>>
>;
export type CreateTimelineMutationBody = BodyType<CreateTimelineDto>;
export type CreateTimelineMutationError = ErrorType<void>;

export const useCreateTimeline = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTimeline>>,
      TError,
      { data: BodyType<CreateTimelineDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTimeline>>,
  TError,
  { data: BodyType<CreateTimelineDto> },
  TContext
> => {
  const mutationOptions = getCreateTimelineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTimelinesByQuery = (
  params?: GetTimelinesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTimelinesByQuery200AllOf>(
    { url: `/api/v1/timelines`, method: 'GET', params, signal },
    options,
  );
};

export const getGetTimelinesByQueryQueryKey = (
  params?: GetTimelinesByQueryParams,
) => {
  return [`/api/v1/timelines`, ...(params ? [params] : [])] as const;
};

export const getGetTimelinesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimelinesByQuery>>
  > = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimelinesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelinesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimelinesByQuery>>
>;
export type GetTimelinesByQueryQueryError = ErrorType<void>;

export function useGetTimelinesByQuery<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetTimelinesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTimelinesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelinesByQuery<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimelinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTimelinesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelinesByQuery<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTimelinesByQuery<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelinesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTimelinesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimelinesByQuery>>
  > = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTimelinesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelinesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimelinesByQuery>>
>;
export type GetTimelinesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetTimelinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetTimelinesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTimelinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTimelinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelinesByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTimelinesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTimelinesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimelinesByQuery>>
  > = ({ signal }) => getTimelinesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTimelinesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelinesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimelinesByQuery>>
>;
export type GetTimelinesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetTimelinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetTimelinesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTimelinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimelinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTimelinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimelinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelinesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTimeline = (
  timelineId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTimeline200AllOf>(
    { url: `/api/v1/timelines/${timelineId}`, method: 'GET', signal },
    options,
  );
};

export const getGetTimelineQueryKey = (timelineId: string) => {
  return [`/api/v1/timelines/${timelineId}`] as const;
};

export const getGetTimelineQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({
    signal,
  }) => getTimeline(timelineId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!timelineId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeline>>
>;
export type GetTimelineQueryError = ErrorType<void>;

export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          Awaited<ReturnType<typeof getTimeline>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTimeline>>,
          TError,
          Awaited<ReturnType<typeof getTimeline>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTimeline<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTimeline>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelineQueryOptions(timelineId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTimelineSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({
    signal,
  }) => getTimeline(timelineId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeline>>
>;
export type GetTimelineSuspenseQueryError = ErrorType<void>;

export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTimelineSuspense<
  TData = Awaited<ReturnType<typeof getTimeline>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelineSuspenseQueryOptions(timelineId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTimelineSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTimelineQueryKey(timelineId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTimeline>>> = ({
    signal,
  }) => getTimeline(timelineId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTimeline>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTimelineSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeline>>
>;
export type GetTimelineSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetTimelineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTimelineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTimelineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTimeline>>>,
  TError = ErrorType<void>,
>(
  timelineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTimeline>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTimelineSuspenseInfiniteQueryOptions(
    timelineId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTimeline = (
  timelineId: string,
  updateTimelineDto: BodyType<UpdateTimelineDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateTimeline200AllOf>(
    {
      url: `/api/v1/timelines/${timelineId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateTimelineDto,
    },
    options,
  );
};

export const getUpdateTimelineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTimeline>>,
    TError,
    { timelineId: string; data: BodyType<UpdateTimelineDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTimeline>>,
  TError,
  { timelineId: string; data: BodyType<UpdateTimelineDto> },
  TContext
> => {
  const mutationKey = ['updateTimeline'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTimeline>>,
    { timelineId: string; data: BodyType<UpdateTimelineDto> }
  > = props => {
    const { timelineId, data } = props ?? {};

    return updateTimeline(timelineId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTimelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTimeline>>
>;
export type UpdateTimelineMutationBody = BodyType<UpdateTimelineDto>;
export type UpdateTimelineMutationError = ErrorType<void>;

export const useUpdateTimeline = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTimeline>>,
      TError,
      { timelineId: string; data: BodyType<UpdateTimelineDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTimeline>>,
  TError,
  { timelineId: string; data: BodyType<UpdateTimelineDto> },
  TContext
> => {
  const mutationOptions = getUpdateTimelineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteTimeline = (
  timelineId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteTimeline200AllOf>(
    { url: `/api/v1/timelines/${timelineId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteTimelineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTimeline>>,
    TError,
    { timelineId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTimeline>>,
  TError,
  { timelineId: string },
  TContext
> => {
  const mutationKey = ['deleteTimeline'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTimeline>>,
    { timelineId: string }
  > = props => {
    const { timelineId } = props ?? {};

    return deleteTimeline(timelineId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTimelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTimeline>>
>;

export type DeleteTimelineMutationError = ErrorType<void>;

export const useDeleteTimeline = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTimeline>>,
      TError,
      { timelineId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTimeline>>,
  TError,
  { timelineId: string },
  TContext
> => {
  const mutationOptions = getDeleteTimelineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeTimelines = (
  removeTimelinesBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveTimelines200AllOf>(
    {
      url: `/api/v1/timelines/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeTimelinesBody,
    },
    options,
  );
};

export const getRemoveTimelinesMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeTimelines>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeTimelines>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeTimelines'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeTimelines>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeTimelines(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveTimelinesMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeTimelines>>
>;
export type RemoveTimelinesMutationBody = BodyType<string[]>;
export type RemoveTimelinesMutationError = ErrorType<void>;

export const useRemoveTimelines = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeTimelines>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeTimelines>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveTimelinesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeTimeline = (
  timelineId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveTimeline200AllOf>(
    { url: `/api/v1/timelines/${timelineId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveTimelineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeTimeline>>,
    TError,
    { timelineId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeTimeline>>,
  TError,
  { timelineId: string },
  TContext
> => {
  const mutationKey = ['removeTimeline'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeTimeline>>,
    { timelineId: string }
  > = props => {
    const { timelineId } = props ?? {};

    return removeTimeline(timelineId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveTimelineMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeTimeline>>
>;

export type RemoveTimelineMutationError = ErrorType<void>;

export const useRemoveTimeline = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeTimeline>>,
      TError,
      { timelineId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeTimeline>>,
  TError,
  { timelineId: string },
  TContext
> => {
  const mutationOptions = getRemoveTimelineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createSession = (
  createSessionDto: BodyType<CreateSessionDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateSession200AllOf>(
    {
      url: `/api/v1/sessions`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createSessionDto,
      signal,
    },
    options,
  );
};

export const getCreateSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createSession>>,
    TError,
    { data: BodyType<CreateSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createSession>>,
  TError,
  { data: BodyType<CreateSessionDto> },
  TContext
> => {
  const mutationKey = ['createSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createSession>>,
    { data: BodyType<CreateSessionDto> }
  > = props => {
    const { data } = props ?? {};

    return createSession(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createSession>>
>;
export type CreateSessionMutationBody = BodyType<CreateSessionDto>;
export type CreateSessionMutationError = ErrorType<void>;

export const useCreateSession = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createSession>>,
      TError,
      { data: BodyType<CreateSessionDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createSession>>,
  TError,
  { data: BodyType<CreateSessionDto> },
  TContext
> => {
  const mutationOptions = getCreateSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getSessionsByQuery = (
  params?: GetSessionsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSessionsByQuery200AllOf>(
    { url: `/api/v1/sessions`, method: 'GET', params, signal },
    options,
  );
};

export const getGetSessionsByQueryQueryKey = (
  params?: GetSessionsByQueryParams,
) => {
  return [`/api/v1/sessions`, ...(params ? [params] : [])] as const;
};

export const getGetSessionsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionsByQuery>>
  > = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSessionsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSessionsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionsByQuery>>
>;
export type GetSessionsByQueryQueryError = ErrorType<void>;

export function useGetSessionsByQuery<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSessionsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSessionsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionsByQuery<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSessionsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getSessionsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionsByQuery<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSessionsByQuery<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSessionsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSessionsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionsByQuery>>
  > = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSessionsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSessionsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionsByQuery>>
>;
export type GetSessionsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetSessionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSessionsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSessionsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getSessionsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSessionsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSessionsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSessionsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSessionsByQuery>>
  > = ({ signal }) => getSessionsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSessionsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSessionsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSessionsByQuery>>
>;
export type GetSessionsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSessionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetSessionsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSessionsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSessionsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetSessionsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSessionsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSessionsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getSession = (
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetSession200AllOf>(
    { url: `/api/v1/sessions/${sessionId}`, method: 'GET', signal },
    options,
  );
};

export const getGetSessionQueryKey = (sessionId: string) => {
  return [`/api/v1/sessions/${sessionId}`] as const;
};

export const getGetSessionQueryOptions = <
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({
    signal,
  }) => getSession(sessionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!sessionId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSessionQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSession>>
>;
export type GetSessionQueryError = ErrorType<void>;

export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSession>>,
          TError,
          Awaited<ReturnType<typeof getSession>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSession<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getSession>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSessionQueryOptions(sessionId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSessionSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({
    signal,
  }) => getSession(sessionId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSessionSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSession>>
>;
export type GetSessionSuspenseQueryError = ErrorType<void>;

export function useGetSessionSuspense<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionSuspense<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionSuspense<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSessionSuspense<
  TData = Awaited<ReturnType<typeof getSession>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSessionSuspenseQueryOptions(sessionId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetSessionSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSessionQueryKey(sessionId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getSession>>> = ({
    signal,
  }) => getSession(sessionId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getSession>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSessionSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSession>>
>;
export type GetSessionSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetSessionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetSessionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetSessionSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getSession>>>,
  TError = ErrorType<void>,
>(
  sessionId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getSession>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetSessionSuspenseInfiniteQueryOptions(
    sessionId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateSession = (
  sessionId: string,
  updateSessionDto: BodyType<UpdateSessionDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateSession200AllOf>(
    {
      url: `/api/v1/sessions/${sessionId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateSessionDto,
    },
    options,
  );
};

export const getUpdateSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateSession>>,
    TError,
    { sessionId: string; data: BodyType<UpdateSessionDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateSession>>,
  TError,
  { sessionId: string; data: BodyType<UpdateSessionDto> },
  TContext
> => {
  const mutationKey = ['updateSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateSession>>,
    { sessionId: string; data: BodyType<UpdateSessionDto> }
  > = props => {
    const { sessionId, data } = props ?? {};

    return updateSession(sessionId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateSession>>
>;
export type UpdateSessionMutationBody = BodyType<UpdateSessionDto>;
export type UpdateSessionMutationError = ErrorType<void>;

export const useUpdateSession = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateSession>>,
      TError,
      { sessionId: string; data: BodyType<UpdateSessionDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateSession>>,
  TError,
  { sessionId: string; data: BodyType<UpdateSessionDto> },
  TContext
> => {
  const mutationOptions = getUpdateSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteSession = (
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteSession200AllOf>(
    { url: `/api/v1/sessions/${sessionId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteSession>>,
    TError,
    { sessionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationKey = ['deleteSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteSession>>,
    { sessionId: string }
  > = props => {
    const { sessionId } = props ?? {};

    return deleteSession(sessionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteSession>>
>;

export type DeleteSessionMutationError = ErrorType<void>;

export const useDeleteSession = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteSession>>,
      TError,
      { sessionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationOptions = getDeleteSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeSessions = (
  removeSessionsBody: BodyType<string[]>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveSessions200AllOf>(
    {
      url: `/api/v1/sessions/removedAt`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: removeSessionsBody,
    },
    options,
  );
};

export const getRemoveSessionsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeSessions>>,
    TError,
    { data: BodyType<string[]> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeSessions>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationKey = ['removeSessions'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeSessions>>,
    { data: BodyType<string[]> }
  > = props => {
    const { data } = props ?? {};

    return removeSessions(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveSessionsMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeSessions>>
>;
export type RemoveSessionsMutationBody = BodyType<string[]>;
export type RemoveSessionsMutationError = ErrorType<void>;

export const useRemoveSessions = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeSessions>>,
      TError,
      { data: BodyType<string[]> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeSessions>>,
  TError,
  { data: BodyType<string[]> },
  TContext
> => {
  const mutationOptions = getRemoveSessionsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeSession = (
  sessionId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveSession200AllOf>(
    { url: `/api/v1/sessions/${sessionId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveSessionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeSession>>,
    TError,
    { sessionId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationKey = ['removeSession'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeSession>>,
    { sessionId: string }
  > = props => {
    const { sessionId } = props ?? {};

    return removeSession(sessionId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveSessionMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeSession>>
>;

export type RemoveSessionMutationError = ErrorType<void>;

export const useRemoveSession = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeSession>>,
      TError,
      { sessionId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeSession>>,
  TError,
  { sessionId: string },
  TContext
> => {
  const mutationOptions = getRemoveSessionMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createProgram = (
  createProgramDto: BodyType<CreateProgramDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateProgram200AllOf>(
    {
      url: `/api/v1/programs`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createProgramDto,
      signal,
    },
    options,
  );
};

export const getCreateProgramMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProgram>>,
    TError,
    { data: BodyType<CreateProgramDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProgram>>,
  TError,
  { data: BodyType<CreateProgramDto> },
  TContext
> => {
  const mutationKey = ['createProgram'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProgram>>,
    { data: BodyType<CreateProgramDto> }
  > = props => {
    const { data } = props ?? {};

    return createProgram(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateProgramMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProgram>>
>;
export type CreateProgramMutationBody = BodyType<CreateProgramDto>;
export type CreateProgramMutationError = ErrorType<void>;

export const useCreateProgram = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createProgram>>,
      TError,
      { data: BodyType<CreateProgramDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createProgram>>,
  TError,
  { data: BodyType<CreateProgramDto> },
  TContext
> => {
  const mutationOptions = getCreateProgramMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getProgramsByQuery = (
  params?: GetProgramsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetProgramsByQuery200AllOf>(
    { url: `/api/v1/programs`, method: 'GET', params, signal },
    options,
  );
};

export const getGetProgramsByQueryQueryKey = (
  params?: GetProgramsByQueryParams,
) => {
  return [`/api/v1/programs`, ...(params ? [params] : [])] as const;
};

export const getGetProgramsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProgramsByQuery>>
  > = ({ signal }) => getProgramsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getProgramsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgramsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgramsByQuery>>
>;
export type GetProgramsByQueryQueryError = ErrorType<void>;

export function useGetProgramsByQuery<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetProgramsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getProgramsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramsByQuery<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getProgramsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramsByQuery<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProgramsByQuery<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProgramsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProgramsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProgramsByQuery>>
  > = ({ signal }) => getProgramsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProgramsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgramsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgramsByQuery>>
>;
export type GetProgramsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetProgramsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetProgramsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProgramsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getProgramsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProgramsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProgramsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProgramsByQuery>>
  > = ({ signal }) => getProgramsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getProgramsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgramsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgramsByQuery>>
>;
export type GetProgramsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetProgramsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetProgramsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProgramsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetProgramsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProgramsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getProgramById = (
  programId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetProgramById200AllOf>(
    { url: `/api/v1/programs/${programId}`, method: 'GET', signal },
    options,
  );
};

export const getGetProgramByIdQueryKey = (programId: string) => {
  return [`/api/v1/programs/${programId}`] as const;
};

export const getGetProgramByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramByIdQueryKey(programId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramById>>> = ({
    signal,
  }) => getProgramById(programId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!programId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getProgramById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgramByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgramById>>
>;
export type GetProgramByIdQueryError = ErrorType<void>;

export function useGetProgramById<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramById>>,
          TError,
          Awaited<ReturnType<typeof getProgramById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramById<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getProgramById>>,
          TError,
          Awaited<ReturnType<typeof getProgramById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramById<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProgramById<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProgramById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProgramByIdQueryOptions(programId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProgramByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramByIdQueryKey(programId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramById>>> = ({
    signal,
  }) => getProgramById(programId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProgramById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgramByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgramById>>
>;
export type GetProgramByIdSuspenseQueryError = ErrorType<void>;

export function useGetProgramByIdSuspense<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramByIdSuspense<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramByIdSuspense<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProgramByIdSuspense<
  TData = Awaited<ReturnType<typeof getProgramById>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProgramByIdSuspenseQueryOptions(
    programId,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetProgramByIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetProgramByIdQueryKey(programId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProgramById>>> = ({
    signal,
  }) => getProgramById(programId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getProgramById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetProgramByIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProgramById>>
>;
export type GetProgramByIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetProgramByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetProgramByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetProgramByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getProgramById>>>,
  TError = ErrorType<void>,
>(
  programId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getProgramById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetProgramByIdSuspenseInfiniteQueryOptions(
    programId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateProgramById = (
  programId: string,
  updateProgramDto: BodyType<UpdateProgramDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateProgramById200AllOf>(
    {
      url: `/api/v1/programs/${programId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateProgramDto,
    },
    options,
  );
};

export const getUpdateProgramByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProgramById>>,
    TError,
    { programId: string; data: BodyType<UpdateProgramDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProgramById>>,
  TError,
  { programId: string; data: BodyType<UpdateProgramDto> },
  TContext
> => {
  const mutationKey = ['updateProgramById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProgramById>>,
    { programId: string; data: BodyType<UpdateProgramDto> }
  > = props => {
    const { programId, data } = props ?? {};

    return updateProgramById(programId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateProgramByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProgramById>>
>;
export type UpdateProgramByIdMutationBody = BodyType<UpdateProgramDto>;
export type UpdateProgramByIdMutationError = ErrorType<void>;

export const useUpdateProgramById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateProgramById>>,
      TError,
      { programId: string; data: BodyType<UpdateProgramDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateProgramById>>,
  TError,
  { programId: string; data: BodyType<UpdateProgramDto> },
  TContext
> => {
  const mutationOptions = getUpdateProgramByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteProgramById = (
  programId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteProgramById200AllOf>(
    { url: `/api/v1/programs/${programId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteProgramByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProgramById>>,
    TError,
    { programId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProgramById>>,
  TError,
  { programId: string },
  TContext
> => {
  const mutationKey = ['deleteProgramById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProgramById>>,
    { programId: string }
  > = props => {
    const { programId } = props ?? {};

    return deleteProgramById(programId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteProgramByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProgramById>>
>;

export type DeleteProgramByIdMutationError = ErrorType<void>;

export const useDeleteProgramById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteProgramById>>,
      TError,
      { programId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteProgramById>>,
  TError,
  { programId: string },
  TContext
> => {
  const mutationOptions = getDeleteProgramByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeProgramById = (
  programId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveProgramById200AllOf>(
    { url: `/api/v1/programs/${programId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveProgramByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeProgramById>>,
    TError,
    { programId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeProgramById>>,
  TError,
  { programId: string },
  TContext
> => {
  const mutationKey = ['removeProgramById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeProgramById>>,
    { programId: string }
  > = props => {
    const { programId } = props ?? {};

    return removeProgramById(programId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveProgramByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeProgramById>>
>;

export type RemoveProgramByIdMutationError = ErrorType<void>;

export const useRemoveProgramById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeProgramById>>,
      TError,
      { programId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeProgramById>>,
  TError,
  { programId: string },
  TContext
> => {
  const mutationOptions = getRemoveProgramByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createRoutine = (
  createRoutineDto: BodyType<CreateRoutineDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateRoutine200AllOf>(
    {
      url: `/api/v1/routines`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createRoutineDto,
      signal,
    },
    options,
  );
};

export const getCreateRoutineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRoutine>>,
    TError,
    { data: BodyType<CreateRoutineDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRoutine>>,
  TError,
  { data: BodyType<CreateRoutineDto> },
  TContext
> => {
  const mutationKey = ['createRoutine'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRoutine>>,
    { data: BodyType<CreateRoutineDto> }
  > = props => {
    const { data } = props ?? {};

    return createRoutine(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateRoutineMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRoutine>>
>;
export type CreateRoutineMutationBody = BodyType<CreateRoutineDto>;
export type CreateRoutineMutationError = ErrorType<void>;

export const useCreateRoutine = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRoutine>>,
      TError,
      { data: BodyType<CreateRoutineDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createRoutine>>,
  TError,
  { data: BodyType<CreateRoutineDto> },
  TContext
> => {
  const mutationOptions = getCreateRoutineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getRoutinesByQuery = (
  params?: GetRoutinesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetRoutinesByQuery200AllOf>(
    { url: `/api/v1/routines`, method: 'GET', params, signal },
    options,
  );
};

export const getGetRoutinesByQueryQueryKey = (
  params?: GetRoutinesByQueryParams,
) => {
  return [`/api/v1/routines`, ...(params ? [params] : [])] as const;
};

export const getGetRoutinesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRoutinesByQuery>>
  > = ({ signal }) => getRoutinesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRoutinesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutinesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutinesByQuery>>
>;
export type GetRoutinesByQueryQueryError = ErrorType<void>;

export function useGetRoutinesByQuery<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetRoutinesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRoutinesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutinesByQuery<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutinesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getRoutinesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutinesByQuery<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutinesByQuery<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutinesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRoutinesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRoutinesByQuery>>
  > = ({ signal }) => getRoutinesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRoutinesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutinesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutinesByQuery>>
>;
export type GetRoutinesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetRoutinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetRoutinesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutinesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getRoutinesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutinesByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRoutinesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRoutinesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRoutinesByQuery>>
  > = ({ signal }) => getRoutinesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getRoutinesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutinesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutinesByQuery>>
>;
export type GetRoutinesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetRoutinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetRoutinesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutinesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutinesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetRoutinesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutinesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutinesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getRoutine = (
  routineId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetRoutine200AllOf>(
    { url: `/api/v1/routines/${routineId}`, method: 'GET', signal },
    options,
  );
};

export const getGetRoutineQueryKey = (routineId: string) => {
  return [`/api/v1/routines/${routineId}`] as const;
};

export const getGetRoutineQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({
    signal,
  }) => getRoutine(routineId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!routineId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getRoutine>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutineQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutine>>
>;
export type GetRoutineQueryError = ErrorType<void>;

export function useGetRoutine<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutine>>,
          TError,
          Awaited<ReturnType<typeof getRoutine>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutine<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRoutine>>,
          TError,
          Awaited<ReturnType<typeof getRoutine>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutine<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutine<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoutine>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutineQueryOptions(routineId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRoutineSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({
    signal,
  }) => getRoutine(routineId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRoutine>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutineSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutine>>
>;
export type GetRoutineSuspenseQueryError = ErrorType<void>;

export function useGetRoutineSuspense<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutineSuspense<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutineSuspense<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutineSuspense<
  TData = Awaited<ReturnType<typeof getRoutine>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutineSuspenseQueryOptions(routineId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetRoutineSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRoutineQueryKey(routineId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoutine>>> = ({
    signal,
  }) => getRoutine(routineId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getRoutine>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRoutineSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoutine>>
>;
export type GetRoutineSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetRoutineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetRoutineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetRoutineSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getRoutine>>>,
  TError = ErrorType<void>,
>(
  routineId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getRoutine>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetRoutineSuspenseInfiniteQueryOptions(
    routineId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateRoutine = (
  routineId: string,
  updateRoutineDto: BodyType<UpdateRoutineDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateRoutine200AllOf>(
    {
      url: `/api/v1/routines/${routineId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateRoutineDto,
    },
    options,
  );
};

export const getUpdateRoutineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRoutine>>,
    TError,
    { routineId: string; data: BodyType<UpdateRoutineDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRoutine>>,
  TError,
  { routineId: string; data: BodyType<UpdateRoutineDto> },
  TContext
> => {
  const mutationKey = ['updateRoutine'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRoutine>>,
    { routineId: string; data: BodyType<UpdateRoutineDto> }
  > = props => {
    const { routineId, data } = props ?? {};

    return updateRoutine(routineId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateRoutineMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRoutine>>
>;
export type UpdateRoutineMutationBody = BodyType<UpdateRoutineDto>;
export type UpdateRoutineMutationError = ErrorType<void>;

export const useUpdateRoutine = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateRoutine>>,
      TError,
      { routineId: string; data: BodyType<UpdateRoutineDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateRoutine>>,
  TError,
  { routineId: string; data: BodyType<UpdateRoutineDto> },
  TContext
> => {
  const mutationOptions = getUpdateRoutineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteRoutine = (
  routineId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteRoutine200AllOf>(
    { url: `/api/v1/routines/${routineId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteRoutineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRoutine>>,
    TError,
    { routineId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRoutine>>,
  TError,
  { routineId: string },
  TContext
> => {
  const mutationKey = ['deleteRoutine'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRoutine>>,
    { routineId: string }
  > = props => {
    const { routineId } = props ?? {};

    return deleteRoutine(routineId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRoutineMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRoutine>>
>;

export type DeleteRoutineMutationError = ErrorType<void>;

export const useDeleteRoutine = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRoutine>>,
      TError,
      { routineId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRoutine>>,
  TError,
  { routineId: string },
  TContext
> => {
  const mutationOptions = getDeleteRoutineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeRoutine = (
  routineId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveRoutine200AllOf>(
    { url: `/api/v1/routines/${routineId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveRoutineMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeRoutine>>,
    TError,
    { routineId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeRoutine>>,
  TError,
  { routineId: string },
  TContext
> => {
  const mutationKey = ['removeRoutine'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeRoutine>>,
    { routineId: string }
  > = props => {
    const { routineId } = props ?? {};

    return removeRoutine(routineId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveRoutineMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeRoutine>>
>;

export type RemoveRoutineMutationError = ErrorType<void>;

export const useRemoveRoutine = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeRoutine>>,
      TError,
      { routineId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeRoutine>>,
  TError,
  { routineId: string },
  TContext
> => {
  const mutationOptions = getRemoveRoutineMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createDepot = (
  createDepotBody?: BodyType<CreateDepotBody>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  if (createDepotBody?.files !== undefined) {
    createDepotBody?.files.forEach(value => formData.append('files', value));
  }

  return customInstance<CreateDepot201AllOf>(
    {
      url: `/api/v1/depots`,
      method: 'POST',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
      signal,
    },
    options,
  );
};

export const getCreateDepotMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDepot>>,
    TError,
    { data: BodyType<CreateDepotBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDepot>>,
  TError,
  { data: BodyType<CreateDepotBody> },
  TContext
> => {
  const mutationKey = ['createDepot'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDepot>>,
    { data: BodyType<CreateDepotBody> }
  > = props => {
    const { data } = props ?? {};

    return createDepot(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateDepotMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDepot>>
>;
export type CreateDepotMutationBody = BodyType<CreateDepotBody>;
export type CreateDepotMutationError = ErrorType<void>;

export const useCreateDepot = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createDepot>>,
      TError,
      { data: BodyType<CreateDepotBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createDepot>>,
  TError,
  { data: BodyType<CreateDepotBody> },
  TContext
> => {
  const mutationOptions = getCreateDepotMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getDepotsByQuery = (
  params?: GetDepotsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetDepotsByQuery200AllOf>(
    { url: `/api/v1/depots`, method: 'GET', params, signal },
    options,
  );
};

export const getGetDepotsByQueryQueryKey = (
  params?: GetDepotsByQueryParams,
) => {
  return [`/api/v1/depots`, ...(params ? [params] : [])] as const;
};

export const getGetDepotsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDepotsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDepotsByQuery>>
  > = ({ signal }) => getDepotsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDepotsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDepotsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDepotsByQuery>>
>;
export type GetDepotsByQueryQueryError = ErrorType<void>;

export function useGetDepotsByQuery<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetDepotsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getDepotsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotsByQuery<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getDepotsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotsByQuery<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDepotsByQuery<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDepotsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDepotsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDepotsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDepotsByQuery>>
  > = ({ signal }) => getDepotsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getDepotsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDepotsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDepotsByQuery>>
>;
export type GetDepotsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetDepotsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetDepotsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDepotsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getDepotsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDepotsByQuerySuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDepotsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDepotsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDepotsByQuery>>
  > = ({ signal }) => getDepotsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDepotsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDepotsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDepotsByQuery>>
>;
export type GetDepotsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetDepotsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetDepotsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDepotsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetDepotsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDepotsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getDepotById = (
  depotId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetDepotById200AllOf>(
    { url: `/api/v1/depots/${depotId}`, method: 'GET', signal },
    options,
  );
};

export const getGetDepotByIdQueryKey = (depotId: string) => {
  return [`/api/v1/depots/${depotId}`] as const;
};

export const getGetDepotByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDepotByIdQueryKey(depotId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotById>>> = ({
    signal,
  }) => getDepotById(depotId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!depotId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getDepotById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDepotByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDepotById>>
>;
export type GetDepotByIdQueryError = ErrorType<void>;

export function useGetDepotById<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotById>>,
          TError,
          Awaited<ReturnType<typeof getDepotById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotById<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDepotById>>,
          TError,
          Awaited<ReturnType<typeof getDepotById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotById<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDepotById<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getDepotById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDepotByIdQueryOptions(depotId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDepotByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDepotByIdQueryKey(depotId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotById>>> = ({
    signal,
  }) => getDepotById(depotId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getDepotById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDepotByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDepotById>>
>;
export type GetDepotByIdSuspenseQueryError = ErrorType<void>;

export function useGetDepotByIdSuspense<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotByIdSuspense<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotByIdSuspense<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDepotByIdSuspense<
  TData = Awaited<ReturnType<typeof getDepotById>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDepotByIdSuspenseQueryOptions(depotId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetDepotByIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDepotByIdQueryKey(depotId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDepotById>>> = ({
    signal,
  }) => getDepotById(depotId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getDepotById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDepotByIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDepotById>>
>;
export type GetDepotByIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetDepotByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetDepotByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetDepotByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getDepotById>>>,
  TError = ErrorType<void>,
>(
  depotId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getDepotById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetDepotByIdSuspenseInfiniteQueryOptions(
    depotId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateDepotById = (
  depotId: string,
  updateDepotByIdBody?: BodyType<UpdateDepotByIdBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formData = new FormData();
  if (updateDepotByIdBody?.thumbnails !== undefined) {
    updateDepotByIdBody?.thumbnails.forEach(value =>
      formData.append('thumbnails', value),
    );
  }
  if (updateDepotByIdBody?.videos !== undefined) {
    updateDepotByIdBody?.videos.forEach(value =>
      formData.append('videos', value),
    );
  }
  if (updateDepotByIdBody?.images !== undefined) {
    updateDepotByIdBody?.images.forEach(value =>
      formData.append('images', value),
    );
  }

  return customInstance<UpdateDepotById200AllOf>(
    {
      url: `/api/v1/depots/${depotId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
    },
    options,
  );
};

export const getUpdateDepotByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDepotById>>,
    TError,
    { depotId: string; data: BodyType<UpdateDepotByIdBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDepotById>>,
  TError,
  { depotId: string; data: BodyType<UpdateDepotByIdBody> },
  TContext
> => {
  const mutationKey = ['updateDepotById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDepotById>>,
    { depotId: string; data: BodyType<UpdateDepotByIdBody> }
  > = props => {
    const { depotId, data } = props ?? {};

    return updateDepotById(depotId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateDepotByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDepotById>>
>;
export type UpdateDepotByIdMutationBody = BodyType<UpdateDepotByIdBody>;
export type UpdateDepotByIdMutationError = ErrorType<void>;

export const useUpdateDepotById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateDepotById>>,
      TError,
      { depotId: string; data: BodyType<UpdateDepotByIdBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateDepotById>>,
  TError,
  { depotId: string; data: BodyType<UpdateDepotByIdBody> },
  TContext
> => {
  const mutationOptions = getUpdateDepotByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteDepot = (
  depotId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteDepot200AllOf>(
    { url: `/api/v1/depots/${depotId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteDepotMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDepot>>,
    TError,
    { depotId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDepot>>,
  TError,
  { depotId: string },
  TContext
> => {
  const mutationKey = ['deleteDepot'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDepot>>,
    { depotId: string }
  > = props => {
    const { depotId } = props ?? {};

    return deleteDepot(depotId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDepotMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDepot>>
>;

export type DeleteDepotMutationError = ErrorType<void>;

export const useDeleteDepot = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteDepot>>,
      TError,
      { depotId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteDepot>>,
  TError,
  { depotId: string },
  TContext
> => {
  const mutationOptions = getDeleteDepotMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getExercisesByQuery = (
  params?: GetExercisesByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetExercisesByQuery200AllOf>(
    { url: `/api/v1/exercises`, method: 'GET', params, signal },
    options,
  );
};

export const getGetExercisesByQueryQueryKey = (
  params?: GetExercisesByQueryParams,
) => {
  return [`/api/v1/exercises`, ...(params ? [params] : [])] as const;
};

export const getGetExercisesByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExercisesByQuery>>
  > = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExercisesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExercisesByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExercisesByQuery>>
>;
export type GetExercisesByQueryQueryError = ErrorType<void>;

export function useGetExercisesByQuery<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetExercisesByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getExercisesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercisesByQuery<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercisesByQuery>>,
          TError,
          Awaited<ReturnType<typeof getExercisesByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercisesByQuery<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExercisesByQuery<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExercisesByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetExercisesByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExercisesByQuery>>
  > = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getExercisesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExercisesByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExercisesByQuery>>
>;
export type GetExercisesByQuerySuspenseQueryError = ErrorType<void>;

export function useGetExercisesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetExercisesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercisesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercisesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExercisesByQuerySuspense<
  TData = Awaited<ReturnType<typeof getExercisesByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExercisesByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetExercisesByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetExercisesByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExercisesByQuery>>
  > = ({ signal }) => getExercisesByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getExercisesByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExercisesByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExercisesByQuery>>
>;
export type GetExercisesByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetExercisesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetExercisesByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercisesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercisesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExercisesByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercisesByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetExercisesByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercisesByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExercisesByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const createExercise = (
  createExerciseDto: BodyType<CreateExerciseDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateExercise200AllOf>(
    {
      url: `/api/v1/exercises`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createExerciseDto,
      signal,
    },
    options,
  );
};

export const getCreateExerciseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createExercise>>,
    TError,
    { data: BodyType<CreateExerciseDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createExercise>>,
  TError,
  { data: BodyType<CreateExerciseDto> },
  TContext
> => {
  const mutationKey = ['createExercise'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createExercise>>,
    { data: BodyType<CreateExerciseDto> }
  > = props => {
    const { data } = props ?? {};

    return createExercise(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateExerciseMutationResult = NonNullable<
  Awaited<ReturnType<typeof createExercise>>
>;
export type CreateExerciseMutationBody = BodyType<CreateExerciseDto>;
export type CreateExerciseMutationError = ErrorType<void>;

export const useCreateExercise = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createExercise>>,
      TError,
      { data: BodyType<CreateExerciseDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createExercise>>,
  TError,
  { data: BodyType<CreateExerciseDto> },
  TContext
> => {
  const mutationOptions = getCreateExerciseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getExercise = (
  exerciseId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetExercise200AllOf>(
    { url: `/api/v1/exercises/${exerciseId}`, method: 'GET', signal },
    options,
  );
};

export const getGetExerciseQueryKey = (exerciseId: string) => {
  return [`/api/v1/exercises/${exerciseId}`] as const;
};

export const getGetExerciseQueryOptions = <
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({
    signal,
  }) => getExercise(exerciseId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!exerciseId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getExercise>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExerciseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExercise>>
>;
export type GetExerciseQueryError = ErrorType<void>;

export function useGetExercise<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercise>>,
          TError,
          Awaited<ReturnType<typeof getExercise>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercise<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExercise>>,
          TError,
          Awaited<ReturnType<typeof getExercise>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExercise<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExercise<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getExercise>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExerciseQueryOptions(exerciseId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetExerciseSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({
    signal,
  }) => getExercise(exerciseId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getExercise>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExerciseSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExercise>>
>;
export type GetExerciseSuspenseQueryError = ErrorType<void>;

export function useGetExerciseSuspense<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExerciseSuspense<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExerciseSuspense<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExerciseSuspense<
  TData = Awaited<ReturnType<typeof getExercise>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExerciseSuspenseQueryOptions(exerciseId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetExerciseSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetExerciseQueryKey(exerciseId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getExercise>>> = ({
    signal,
  }) => getExercise(exerciseId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getExercise>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExerciseSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExercise>>
>;
export type GetExerciseSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetExerciseSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExerciseSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetExerciseSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetExerciseSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getExercise>>>,
  TError = ErrorType<void>,
>(
  exerciseId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getExercise>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetExerciseSuspenseInfiniteQueryOptions(
    exerciseId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateExercise = (
  exerciseId: string,
  updateExerciseDto: BodyType<UpdateExerciseDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateExercise200AllOf>(
    {
      url: `/api/v1/exercises/${exerciseId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateExerciseDto,
    },
    options,
  );
};

export const getUpdateExerciseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateExercise>>,
    TError,
    { exerciseId: string; data: BodyType<UpdateExerciseDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateExercise>>,
  TError,
  { exerciseId: string; data: BodyType<UpdateExerciseDto> },
  TContext
> => {
  const mutationKey = ['updateExercise'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateExercise>>,
    { exerciseId: string; data: BodyType<UpdateExerciseDto> }
  > = props => {
    const { exerciseId, data } = props ?? {};

    return updateExercise(exerciseId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateExerciseMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateExercise>>
>;
export type UpdateExerciseMutationBody = BodyType<UpdateExerciseDto>;
export type UpdateExerciseMutationError = ErrorType<void>;

export const useUpdateExercise = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateExercise>>,
      TError,
      { exerciseId: string; data: BodyType<UpdateExerciseDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateExercise>>,
  TError,
  { exerciseId: string; data: BodyType<UpdateExerciseDto> },
  TContext
> => {
  const mutationOptions = getUpdateExerciseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteExercise = (
  exerciseId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteExercise200AllOf>(
    { url: `/api/v1/exercises/${exerciseId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteExerciseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteExercise>>,
    TError,
    { exerciseId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteExercise>>,
  TError,
  { exerciseId: string },
  TContext
> => {
  const mutationKey = ['deleteExercise'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteExercise>>,
    { exerciseId: string }
  > = props => {
    const { exerciseId } = props ?? {};

    return deleteExercise(exerciseId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteExerciseMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteExercise>>
>;

export type DeleteExerciseMutationError = ErrorType<void>;

export const useDeleteExercise = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteExercise>>,
      TError,
      { exerciseId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteExercise>>,
  TError,
  { exerciseId: string },
  TContext
> => {
  const mutationOptions = getDeleteExerciseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeExercise = (
  exerciseId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveExercise200AllOf>(
    { url: `/api/v1/exercises/${exerciseId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveExerciseMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeExercise>>,
    TError,
    { exerciseId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeExercise>>,
  TError,
  { exerciseId: string },
  TContext
> => {
  const mutationKey = ['removeExercise'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeExercise>>,
    { exerciseId: string }
  > = props => {
    const { exerciseId } = props ?? {};

    return removeExercise(exerciseId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveExerciseMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeExercise>>
>;

export type RemoveExerciseMutationError = ErrorType<void>;

export const useRemoveExercise = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeExercise>>,
      TError,
      { exerciseId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeExercise>>,
  TError,
  { exerciseId: string },
  TContext
> => {
  const mutationOptions = getRemoveExerciseMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getFileById = (
  fileId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetFileById200AllOf>(
    { url: `/api/v1/files/${fileId}`, method: 'GET', signal },
    options,
  );
};

export const getGetFileByIdQueryKey = (fileId: string) => {
  return [`/api/v1/files/${fileId}`] as const;
};

export const getGetFileByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({
    signal,
  }) => getFileById(fileId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!fileId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFileById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileById>>
>;
export type GetFileByIdQueryError = ErrorType<void>;

export function useGetFileById<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          Awaited<ReturnType<typeof getFileById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileById<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFileById>>,
          TError,
          Awaited<ReturnType<typeof getFileById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileById<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileById<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFileById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileByIdQueryOptions(fileId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFileByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({
    signal,
  }) => getFileById(fileId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getFileById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileById>>
>;
export type GetFileByIdSuspenseQueryError = ErrorType<void>;

export function useGetFileByIdSuspense<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileByIdSuspense<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileByIdSuspense<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileByIdSuspense<
  TData = Awaited<ReturnType<typeof getFileById>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileByIdSuspenseQueryOptions(fileId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetFileByIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFileByIdQueryKey(fileId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileById>>> = ({
    signal,
  }) => getFileById(fileId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getFileById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFileByIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFileById>>
>;
export type GetFileByIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetFileByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFileByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFileByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getFileById>>>,
  TError = ErrorType<void>,
>(
  fileId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getFileById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFileByIdSuspenseInfiniteQueryOptions(
    fileId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateFileById = (
  fileId: string,
  updateFileByIdBody?: BodyType<UpdateFileByIdBody>,
  options?: SecondParameter<typeof customInstance>,
) => {
  const formData = new FormData();
  if (updateFileByIdBody?.files !== undefined) {
    formData.append('files', updateFileByIdBody.files);
  }

  return customInstance<UpdateFileById200AllOf>(
    {
      url: `/api/v1/files/${fileId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'multipart/form-data' },
      data: formData,
    },
    options,
  );
};

export const getUpdateFileByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateFileById>>,
    TError,
    { fileId: string; data: BodyType<UpdateFileByIdBody> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateFileById>>,
  TError,
  { fileId: string; data: BodyType<UpdateFileByIdBody> },
  TContext
> => {
  const mutationKey = ['updateFileById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateFileById>>,
    { fileId: string; data: BodyType<UpdateFileByIdBody> }
  > = props => {
    const { fileId, data } = props ?? {};

    return updateFileById(fileId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateFileByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateFileById>>
>;
export type UpdateFileByIdMutationBody = BodyType<UpdateFileByIdBody>;
export type UpdateFileByIdMutationError = ErrorType<void>;

export const useUpdateFileById = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateFileById>>,
      TError,
      { fileId: string; data: BodyType<UpdateFileByIdBody> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateFileById>>,
  TError,
  { fileId: string; data: BodyType<UpdateFileByIdBody> },
  TContext
> => {
  const mutationOptions = getUpdateFileByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createFile = (
  createFileDto: BodyType<CreateFileDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateFile201AllOf>(
    {
      url: `/api/v1/files`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createFileDto,
      signal,
    },
    options,
  );
};

export const getCreateFileMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createFile>>,
    TError,
    { data: BodyType<CreateFileDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createFile>>,
  TError,
  { data: BodyType<CreateFileDto> },
  TContext
> => {
  const mutationKey = ['createFile'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createFile>>,
    { data: BodyType<CreateFileDto> }
  > = props => {
    const { data } = props ?? {};

    return createFile(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateFileMutationResult = NonNullable<
  Awaited<ReturnType<typeof createFile>>
>;
export type CreateFileMutationBody = BodyType<CreateFileDto>;
export type CreateFileMutationError = ErrorType<void>;

export const useCreateFile = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createFile>>,
      TError,
      { data: BodyType<CreateFileDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createFile>>,
  TError,
  { data: BodyType<CreateFileDto> },
  TContext
> => {
  const mutationOptions = getCreateFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeFileById = (
  fileId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveFileById200AllOf>(
    { url: `/api/v1/files/${fileId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveFileByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeFileById>>,
    TError,
    { fileId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeFileById>>,
  TError,
  { fileId: string },
  TContext
> => {
  const mutationKey = ['removeFileById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeFileById>>,
    { fileId: string }
  > = props => {
    const { fileId } = props ?? {};

    return removeFileById(fileId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveFileByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeFileById>>
>;

export type RemoveFileByIdMutationError = ErrorType<void>;

export const useRemoveFileById = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeFileById>>,
      TError,
      { fileId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeFileById>>,
  TError,
  { fileId: string },
  TContext
> => {
  const mutationOptions = getRemoveFileByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const createTenant = (
  createTenantDto: BodyType<CreateTenantDto>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<CreateTenant200AllOf>(
    {
      url: `/`,
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      data: createTenantDto,
      signal,
    },
    options,
  );
};

export const getCreateTenantMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTenant>>,
    TError,
    { data: BodyType<CreateTenantDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTenant>>,
  TError,
  { data: BodyType<CreateTenantDto> },
  TContext
> => {
  const mutationKey = ['createTenant'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTenant>>,
    { data: BodyType<CreateTenantDto> }
  > = props => {
    const { data } = props ?? {};

    return createTenant(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateTenantMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTenant>>
>;
export type CreateTenantMutationBody = BodyType<CreateTenantDto>;
export type CreateTenantMutationError = ErrorType<void>;

export const useCreateTenant = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createTenant>>,
      TError,
      { data: BodyType<CreateTenantDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createTenant>>,
  TError,
  { data: BodyType<CreateTenantDto> },
  TContext
> => {
  const mutationOptions = getCreateTenantMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const getTenantsByQuery = (
  params?: GetTenantsByQueryParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTenantsByQuery200AllOf>(
    { url: `/`, method: 'GET', params, signal },
    options,
  );
};

export const getGetTenantsByQueryQueryKey = (
  params?: GetTenantsByQueryParams,
) => {
  return [`/`, ...(params ? [params] : [])] as const;
};

export const getGetTenantsByQueryQueryOptions = <
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTenantsByQuery>>
  > = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTenantsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTenantsByQueryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenantsByQuery>>
>;
export type GetTenantsByQueryQueryError = ErrorType<void>;

export function useGetTenantsByQuery<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetTenantsByQueryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTenantsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantsByQuery<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantsByQuery>>,
          TError,
          Awaited<ReturnType<typeof getTenantsByQuery>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantsByQuery<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTenantsByQuery<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTenantsByQueryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTenantsByQuerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTenantsByQuery>>
  > = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTenantsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTenantsByQuerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenantsByQuery>>
>;
export type GetTenantsByQuerySuspenseQueryError = ErrorType<void>;

export function useGetTenantsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetTenantsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTenantsByQuerySuspense<
  TData = Awaited<ReturnType<typeof getTenantsByQuery>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTenantsByQuerySuspenseQueryOptions(
    params,
    options,
  );

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTenantsByQuerySuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTenantsByQueryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTenantsByQuery>>
  > = ({ signal }) => getTenantsByQuery(params, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTenantsByQuery>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTenantsByQuerySuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenantsByQuery>>
>;
export type GetTenantsByQuerySuspenseInfiniteQueryError = ErrorType<void>;

export function useGetTenantsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>,
  TError = ErrorType<void>,
>(
  params: undefined | GetTenantsByQueryParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTenantsByQuerySuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantsByQuery>>>,
  TError = ErrorType<void>,
>(
  params?: GetTenantsByQueryParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantsByQuery>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTenantsByQuerySuspenseInfiniteQueryOptions(
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTenantById = (
  tenantId: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<GetTenantById200AllOf>(
    { url: `/${tenantId}`, method: 'GET', signal },
    options,
  );
};

export const getGetTenantByIdQueryKey = (tenantId: string) => {
  return [`/${tenantId}`] as const;
};

export const getGetTenantByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({
    signal,
  }) => getTenantById(tenantId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tenantId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getTenantById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTenantByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenantById>>
>;
export type GetTenantByIdQueryError = ErrorType<void>;

export function useGetTenantById<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantById>>,
          TError,
          Awaited<ReturnType<typeof getTenantById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantById<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTenantById>>,
          TError,
          Awaited<ReturnType<typeof getTenantById>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantById<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTenantById<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTenantById>>, TError, TData>
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTenantByIdQueryOptions(tenantId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTenantByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({
    signal,
  }) => getTenantById(tenantId, requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTenantById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTenantByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenantById>>
>;
export type GetTenantByIdSuspenseQueryError = ErrorType<void>;

export function useGetTenantByIdSuspense<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantByIdSuspense<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantByIdSuspense<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTenantByIdSuspense<
  TData = Awaited<ReturnType<typeof getTenantById>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTenantByIdSuspenseQueryOptions(tenantId, options);

  const query = useSuspenseQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetTenantByIdSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTenantByIdQueryKey(tenantId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTenantById>>> = ({
    signal,
  }) => getTenantById(tenantId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    ...queryOptions,
  } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getTenantById>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTenantByIdSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTenantById>>
>;
export type GetTenantByIdSuspenseInfiniteQueryError = ErrorType<void>;

export function useGetTenantByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetTenantByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetTenantByIdSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getTenantById>>>,
  TError = ErrorType<void>,
>(
  tenantId: string,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getTenantById>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetTenantByIdSuspenseInfiniteQueryOptions(
    tenantId,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTenantById = (
  tenantId: string,
  updateTenantDto: BodyType<UpdateTenantDto>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UpdateTenantById200AllOf>(
    {
      url: `/${tenantId}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      data: updateTenantDto,
    },
    options,
  );
};

export const getUpdateTenantByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTenantById>>,
    TError,
    { tenantId: string; data: BodyType<UpdateTenantDto> },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTenantById>>,
  TError,
  { tenantId: string; data: BodyType<UpdateTenantDto> },
  TContext
> => {
  const mutationKey = ['updateTenantById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTenantById>>,
    { tenantId: string; data: BodyType<UpdateTenantDto> }
  > = props => {
    const { tenantId, data } = props ?? {};

    return updateTenantById(tenantId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTenantByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTenantById>>
>;
export type UpdateTenantByIdMutationBody = BodyType<UpdateTenantDto>;
export type UpdateTenantByIdMutationError = ErrorType<void>;

export const useUpdateTenantById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTenantById>>,
      TError,
      { tenantId: string; data: BodyType<UpdateTenantDto> },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTenantById>>,
  TError,
  { tenantId: string; data: BodyType<UpdateTenantDto> },
  TContext
> => {
  const mutationOptions = getUpdateTenantByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const deleteTenant = (
  tenantId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteTenant200AllOf>(
    { url: `/${tenantId}`, method: 'DELETE' },
    options,
  );
};

export const getDeleteTenantMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTenant>>,
    TError,
    { tenantId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTenant>>,
  TError,
  { tenantId: string },
  TContext
> => {
  const mutationKey = ['deleteTenant'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTenant>>,
    { tenantId: string }
  > = props => {
    const { tenantId } = props ?? {};

    return deleteTenant(tenantId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTenantMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTenant>>
>;

export type DeleteTenantMutationError = ErrorType<void>;

export const useDeleteTenant = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTenant>>,
      TError,
      { tenantId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTenant>>,
  TError,
  { tenantId: string },
  TContext
> => {
  const mutationOptions = getDeleteTenantMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const removeTenantById = (
  tenantId: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<RemoveTenantById200AllOf>(
    { url: `/${tenantId}/removedAt`, method: 'PATCH' },
    options,
  );
};

export const getRemoveTenantByIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeTenantById>>,
    TError,
    { tenantId: string },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeTenantById>>,
  TError,
  { tenantId: string },
  TContext
> => {
  const mutationKey = ['removeTenantById'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeTenantById>>,
    { tenantId: string }
  > = props => {
    const { tenantId } = props ?? {};

    return removeTenantById(tenantId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveTenantByIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeTenantById>>
>;

export type RemoveTenantByIdMutationError = ErrorType<void>;

export const useRemoveTenantById = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeTenantById>>,
      TError,
      { tenantId: string },
      TContext
    >;
    request?: SecondParameter<typeof customInstance>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeTenantById>>,
  TError,
  { tenantId: string },
  TContext
> => {
  const mutationOptions = getRemoveTenantByIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
